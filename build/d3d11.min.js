const D3D11_APPEND_ALIGNED_ELEMENT=4294967295,D3D11_BIND_VERTEX_BUFFER=1,D3D11_BIND_INDEX_BUFFER=2,D3D11_BIND_CONSTANT_BUFFER=4,D3D11_BIND_SHADER_RESOURCE=8,D3D11_BIND_RENDER_TARGET=32,D3D11_BIND_DEPTH_STENCIL=64,D3D11_COMPARISON_NEVER=1,D3D11_COMPARISON_LESS=2,D3D11_COMPARISON_EQUAL=3,D3D11_COMPARISON_LESS_EQUAL=4,D3D11_COMPARISON_GREATER=5,D3D11_COMPARISON_NOT_EQUAL=6,D3D11_COMPARISON_GREATER_EQUAL=7,D3D11_COMPARISON_ALWAYS=8,D3D11_CPU_ACCESS_WRITE=65536,D3D11_CPU_ACCESS_READ=131072,D3D11_JS_CREATE_DEVICE_ALPHA_CANVAS=1,D3D11_JS_CREATE_DEVICE_PREMULTIPLIED_ALPHA=2,D3D11_CULL_NONE=1,D3D11_CULL_FRONT=2,D3D11_CULL_BACK=3,D3D11_DEFAULT_STENCIL_READ_MASK=255,D3D11_DEFAULT_STENCIL_WRITE_MASK=255,D3D11_DEPTH_WRITE_MASK_ZERO=0,D3D11_DEPTH_WRITE_MASK_ALL=1,D3D11_DSV_DIMENSION_TEXTURE1D=1,D3D11_DSV_DIMENSION_TEXTURE1DARRAY=2,D3D11_DSV_DIMENSION_TEXTURE2D=3,D3D11_DSV_DIMENSION_TEXTURE2DARRAY=4,D3D11_DSV_READ_ONLY_DEPTH=1,D3D11_DSV_READ_ONLY_STENCIL=2,D3D11_JS_FEATURE_ANISOTROPIC_FILTER_SUPPORT=0,D3D11_JS_FEATURE_FLOAT_TEXTURE_SUPPORT=1,D3D11_JS_FEATURE_FLOAT_TEXTURE_FILTER_SUPPORT=2,D3D11_JS_FEATURE_COMPRESSED_TEXTURE_S3TC_SUPPORT=3,D3D11_FILL_WIREFRAME=2,D3D11_FILL_SOLID=3,D3D11_FILTER_MIN_MAG_MIP_POINT=0,D3D11_FILTER_MIN_MAG_POINT_MIP_LINEAR=1,D3D11_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT=4,D3D11_FILTER_MIN_POINT_MAG_MIP_LINEAR=5,D3D11_FILTER_MIN_LINEAR_MAG_MIP_POINT=16,D3D11_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR=17,D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT=20,D3D11_FILTER_MIN_MAG_MIP_LINEAR=21,D3D11_FILTER_ANISOTROPIC=85,D3D11_FILTER_COMPARISON_MIN_MAG_MIP_POINT=128,D3D11_FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR=129,D3D11_FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT=132,D3D11_FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR=133,D3D11_FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT=144,D3D11_FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR=145,D3D11_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT=148,D3D11_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR=149,D3D11_FILTER_COMPARISON_ANISOTROPIC=213,D3D11_FLOAT32_MAX=3402823466e29,D3D11_CLEAR_DEPTH=1,D3D11_CLEAR_STENCIL=2,D3D11_INPUT_PER_VERTEX_DATA=0,D3D11_INPUT_PER_INSTANCE_DATA=1,D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED=0,D3D11_PRIMITIVE_TOPOLOGY_POINTLIST=1,D3D11_PRIMITIVE_TOPOLOGY_LINELIST=2,D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP=3,D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST=4,D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP=5,D3D11_RESOURCE_DIMENSION_UNKNOWN=0,D3D11_RESOURCE_DIMENSION_BUFFER=1,D3D11_RESOURCE_DIMENSION_TEXTURE1D=2,D3D11_RESOURCE_DIMENSION_TEXTURE2D=3,D3D11_RESOURCE_DIMENSION_TEXTURE3D=4,D3D11_RESOURCE_MISC_GENERATE_MIPS=1,D3D11_RESOURCE_MISC_TEXTURECUBE=4,D3D11_SRV_DIMENSION_TEXTURE1D=2,D3D11_SRV_DIMENSION_TEXTURE1DARRAY=3,D3D11_SRV_DIMENSION_TEXTURE2D=4,D3D11_SRV_DIMENSION_TEXTURE2DARRAY=5,D3D11_SRV_DIMENSION_TEXTURE3D=8,D3D11_SRV_DIMENSION_TEXTURECUBE=9,D3D11_STENCIL_OP_KEEP=1,D3D11_STENCIL_OP_ZERO=2,D3D11_STENCIL_OP_REPLACE=3,D3D11_STENCIL_OP_INCR_SAT=4,D3D11_STENCIL_OP_DECR_SAT=5,D3D11_STENCIL_OP_INVERT=6,D3D11_STENCIL_OP_INCR=7,D3D11_STENCIL_OP_DECR=8,D3D11_RTV_DIMENSION_TEXTURE1D=2,D3D11_RTV_DIMENSION_TEXTURE1DARRAY=3,D3D11_RTV_DIMENSION_TEXTURE2D=4,D3D11_RTV_DIMENSION_TEXTURE2DARRAY=5,D3D11_RTV_DIMENSION_TEXTURE3D=8,D3D11_TEXTURE_ADDRESS_WRAP=1,D3D11_TEXTURE_ADDRESS_MIRROR=2,D3D11_TEXTURE_ADDRESS_CLAMP=3,D3D11_TEXTURE_ADDRESS_BORDER=4,D3D11_TEXTURE_ADDRESS_MIRROR_ONCE=5,D3D11_USAGE_DEFAULT=0,D3D11_USAGE_IMMUTABLE=1,D3D11_USAGE_DYNAMIC=2,D3D11_USAGE_STAGING=3,DXGI_FORMAT_UNKNOWN=0,DXGI_FORMAT_R32G32B32A32_FLOAT=2,DXGI_FORMAT_R32G32B32_FLOAT=6,DXGI_FORMAT_R16G16B16A16_FLOAT=10,DXGI_FORMAT_R32G32_FLOAT=16,DXGI_FORMAT_R8G8B8A8_UNORM=28,DXGI_FORMAT_R8G8B8A8_UNORM_SRGB=29,DXGI_FORMAT_R16G16_FLOAT=34,DXGI_FORMAT_D32_FLOAT=40,DXGI_FORMAT_R32_FLOAT=41,DXGI_FORMAT_R32_UINT=42,DXGI_FORMAT_D24_UNORM_S8_UINT=45,DXGI_FORMAT_D16_UNORM=55,DXGI_FORMAT_R16_UINT=57,DXGI_FORMAT_BC1_UNORM=71,DXGI_FORMAT_BC2_UNORM=74,DXGI_FORMAT_BC3_UNORM=77,DXGI_FORMAT_B8G8R8A8_UNORM=87,DXGI_FORMAT_B8G8R8X8_UNORM=88;class D3D11_BUFFER_DESC{ByteWidth;Usage;BindFlags;CPUAccessFlags;MiscFlags;StructureByteStride;constructor(e,t,r,i=0,s=0,a=0){this.ByteWidth=e,this.Usage=t,this.BindFlags=r,this.CPUAccessFlags=i,this.MiscFlags=s,this.StructureByteStride=a}Copy(){return new D3D11_BUFFER_DESC(this.ByteWidth,this.Usage,this.BindFlags,this.CPUAccessFlags,this.MiscFlags,this.StructureByteStride)}}class D3D11_DEPTH_STENCIL_DESC{DepthEnable;DepthWriteMask;DepthFunc;StencilEnable;StencilReadMask;StencilWriteMask;FrontFace;BackFace;constructor(e=!0,t=1,r=2,i=!1,s=255,a=255,n=new D3D11_DEPTH_STENCILOP_DESC,l=new D3D11_DEPTH_STENCILOP_DESC){this.DepthEnable=e,this.DepthWriteMask=t,this.DepthFunc=r,this.StencilEnable=i,this.StencilReadMask=s,this.StencilWriteMask=a,this.FrontFace=n.Copy(),this.BackFace=l.Copy()}Copy(){return new D3D11_DEPTH_STENCIL_DESC(this.DepthEnable,this.DepthWriteMask,this.DepthFunc,this.StencilEnable,this.StencilReadMask,this.StencilWriteMask,this.FrontFace.Copy(),this.BackFace.Copy())}}class D3D11_DEPTH_STENCILOP_DESC{StencilFailOp;StencilDepthFailOp;StencilPassOp;StencilFunc;constructor(e=1,t=1,r=1,i=8){this.StencilFailOp=e,this.StencilDepthFailOp=t,this.StencilPassOp=r,this.StencilFunc=i}Copy(){return new D3D11_DEPTH_STENCILOP_DESC(this.StencilFailOp,this.StencilDepthFailOp,this.StencilPassOp,this.StencilFunc)}}class D3D11_DEPTH_STENCIL_VIEW_DESC{Format;ViewDimension;Flags;MipSlice;FirstArraySlice;ArraySize;constructor(e,t,r=0,i=0,s=0,a=1){this.Format=e,this.ViewDimension=t,this.Flags=r,this.MipSlice=i,this.FirstArraySlice=s,this.ArraySize=a}Copy(){return new D3D11_DEPTH_STENCIL_VIEW_DESC(this.Format,this.ViewDimension,this.Flags,this.MipSlice,this.FirstArraySlice,this.ArraySize)}}class D3D11_INPUT_ELEMENT_DESC{SemanticName;SemanticIndex;Format;InputSlot;AlignedByteOffset;InputSlotClass;InstanceDataStepRate;constructor(e,t,r,i,s,a,n){this.SemanticName=e,this.SemanticIndex=t,this.Format=r,this.InputSlot=i,this.AlignedByteOffset=s,this.InputSlotClass=a,this.InstanceDataStepRate=n}Copy(){return new D3D11_INPUT_ELEMENT_DESC(this.SemanticName,this.SemanticIndex,this.Format,this.InputSlot,this.AlignedByteOffset,this.InputSlotClass,this.InstanceDataStepRate)}}class D3D11_RASTERIZER_DESC{FillMode;CullMode;FrontCounterClockwise;DepthBias;DepthBiasClamp;SlopeScaledDepthBias;DepthClipEnable;ScissorEnable;MultisampleEnable;AntiasliasedLineEnable;constructor(e,t,r=!1,i=0,s=0,a=0,n=!0,l=!1,h=!1,o=!1){this.FillMode=e,this.CullMode=t,this.FrontCounterClockwise=r,this.DepthBias=i,this.DepthBiasClamp=s,this.SlopeScaledDepthBias=a,this.DepthClipEnable=n,this.ScissorEnable=l,this.MultisampleEnable=h,this.AntiasliasedLineEnable=o}Copy(){return new D3D11_RASTERIZER_DESC(this.FillMode,this.CullMode,this.FrontCounterClockwise,this.DepthBias,this.DepthBiasClamp,this.SlopeScaledDepthBias,this.DepthClipEnable,this.ScissorEnable,this.MultisampleEnable,this.AntiasliasedLineEnable)}}class D3D11_RENDER_TARGET_VIEW_DESC{Format;ViewDimension;MipSlice;FirstArraySlice;ArraySize;constructor(e,t,r=0,i=0,s=1){this.Format=e,this.ViewDimension=t,this.MipSlice=r,this.FirstArraySlice=i,this.ArraySize=s}Copy(){return new D3D11_RENDER_TARGET_VIEW_DESC(this.Format,this.ViewDimension,this.MipSlice,this.FirstArraySlice,this.ArraySize)}}class D3D11_SAMPLER_DESC{Filter;AddressU;AddressV;AddressW;MipLODBias;MaxAnisotropy;ComparisonFunc;BorderColor;MinLOD;MaxLOD;constructor(e,t,r,i,s,a,n,l,h,o){this.Filter=e,this.AddressU=t,this.AddressV=r,this.AddressW=i,this.MipLODBias=s,this.MaxAnisotropy=a,this.ComparisonFunc=n,this.BorderColor=l,this.MinLOD=h,this.MaxLOD=o}Copy(){return new D3D11_SAMPLER_DESC(this.Filter,this.AddressU,this.AddressV,this.AddressW,this.MipLODBias,this.MaxAnisotropy,this.ComparisonFunc,this.BorderColor,this.MinLOD,this.MaxLOD)}}class D3D11_SHADER_RESOURCE_VIEW_DESC{Format;ViewDimension;MostDetailedMip;MipLevels;FirstArraySlice;ArraySize;constructor(e,t,r=0,i=1,s=0,a=1){this.Format=e,this.ViewDimension=t,this.MostDetailedMip=r,this.MipLevels=i,this.FirstArraySlice=s,this.ArraySize=a}Copy(){return new D3D11_SHADER_RESOURCE_VIEW_DESC(this.Format,this.ViewDimension,this.MostDetailedMip,this.MipLevels,this.FirstArraySlice,this.ArraySize)}}class D3D11_TEXTURE1D_DESC{Width;MipLevels;ArraySize;Format;Usage;BindFlags;CPUAccessFlags;MiscFlags;constructor(e,t,r,i,s,a,n,l){this.Width=e,this.MipLevels=t,this.ArraySize=r,this.Format=i,this.Usage=s,this.BindFlags=a,this.CPUAccessFlags=n,this.MiscFlags=l}Copy(){return new D3D11_TEXTURE1D_DESC(this.Width,this.MipLevels,this.ArraySize,this.Format,this.Usage,this.BindFlags,this.CPUAccessFlags,this.MiscFlags)}}class D3D11_TEXTURE2D_DESC{Width;Height;MipLevels;ArraySize;Format;SampleDesc;Usage;BindFlags;CPUAccessFlags;MiscFlags;constructor(e,t,r,i,s,a,n,l,h,o){this.Width=e,this.Height=t,this.MipLevels=r,this.ArraySize=i,this.Format=s,this.SampleDesc=a.Copy(),this.Usage=n,this.BindFlags=l,this.CPUAccessFlags=h,this.MiscFlags=o}Copy(){return new D3D11_TEXTURE2D_DESC(this.Width,this.Height,this.MipLevels,this.ArraySize,this.Format,this.SampleDesc.Copy(),this.Usage,this.BindFlags,this.CPUAccessFlags,this.MiscFlags)}}class D3D11_TEXTURE3D_DESC{Width;Height;Depth;MipLevels;Format;Usage;BindFlags;CPUAccessFlags;MiscFlags;constructor(e,t,r,i,s,a,n,l,h){this.Width=e,this.Height=t,this.Depth=r,this.MipLevels=i,this.Format=s,this.Usage=a,this.BindFlags=n,this.CPUAccessFlags=l,this.MiscFlags=h}Copy(){return new D3D11_TEXTURE3D_DESC(this.Width,this.Height,this.Depth,this.MipLevels,this.Format,this.Usage,this.BindFlags,this.CPUAccessFlags,this.MiscFlags)}}class DXGI_SAMPLE_DESC{Count;Quality;constructor(e=1,t=0){this.Count=e,this.Quality=t}Copy(){return new DXGI_SAMPLE_DESC(this.Count,this.Quality)}}class DXGI_SWAP_CHAIN_DESC{Width;Height;Format;constructor(e,t,r=28){this.Width=e,this.Height=t,this.Format=r}Copy(){return new DXGI_SWAP_CHAIN_DESC(this.Width,this.Height,this.Format)}}class D3D11_VIEWPORT{TopLeftX;TopLeftY;Width;Height;MinDepth;MaxDepth;constructor(e,t,r,i,s,a){this.TopLeftX=e,this.TopLeftY=t,this.Width=r,this.Height=i,this.MinDepth=s,this.MaxDepth=a}}class D3D11_RECT{Left;Top;Right;Bottom;constructor(e,t,r,i){this.Left=e,this.Top=t,this.Right=r,this.Bottom=i}}class D3D11_BOX{Left;Top;Front;Right;Bottom;Back;constructor(e,t,r,i,s=0,a=1){this.Left=e,this.Top=t,this.Right=r,this.Bottom=i,this.Front=s,this.Back=a}IsEmpty(){return this.Right<=this.Left||this.Bottom<=this.Top||this.Back<=this.Front}}class IUnknown{#a;constructor(){if(new.target===IUnknown)throw Error("Cannot instantiate IUnknown objects directly.");this.#a=0,this.AddRef()}GetRef(){return this.#a}AddRef(){return this.#a++,this.#a}Release(){return this.#a--,this.#b(),this.#a}#b(){if(this.#a<0)throw Error("Object has been released and is no longer available")}}class ID3D11DeviceChild extends IUnknown{#c;constructor(e){if(super(),new.target===ID3D11DeviceChild)throw Error("Cannot instantiate ID3D11DeviceChild objects directly.");this.#c=e,this.#c.AddRef()}Release(){return super.Release(),0>=this.GetRef()&&this.#c.Release(),this.GetRef()}GetDevice(){return this.#c.AddRef(),this.#c}}function D3D11CreateDevice(e,t){let r=e.getContext("webgl2",{alpha:(1&t)==1,premultipliedAlpha:(2&t)==2,antialias:!1,depth:!1,preserveDrawingBuffer:!0});if(null===r)throw Error("Unable to create internal WebGL2 rendering context for d3d11.js");return new class extends ID3D11Device{}(r)}function D3D11CreateDeviceAndSwapChain(e,t,r){let i=D3D11CreateDevice(e,t),s=i.GetImmediateContext(),a=DXGICreateSwapChain(i,r);return[i,s,a]}function DXGICreateSwapChain(e,t){return new class extends IDXGISwapChain{}(e,t)}function D3D11CalcSubresource(e,t,r){return e+t*r}class ID3D11Device extends IUnknown{#d;#e;#f;#g;#h;#i;#j;#k;constructor(e){if(super(),new.target===ID3D11Device)throw Error("Cannot instantiate ID3D11Device objects directly.  Use D3D11CreateDevice() or D3D11CreateDeviceAndSwapChain() instead.");this.#d=e,this.#e=null,this.#j=this.#d.createFramebuffer(),this.#k=this.#d.createFramebuffer(),this.#f=this.#d.getExtension("EXT_texture_filter_anisotropic")||this.#d.getExtension("MOZ_EXT_texture_filter_anisotropic")||this.#d.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),this.#g=this.#d.getExtension("EXT_color_buffer_float"),this.#h=this.#d.getExtension("OES_texture_float_linear"),this.#i=this.#d.getExtension("WEBGL_compressed_texture_s3tc"),this.#d.pixelStorei(this.#d.UNPACK_FLIP_Y_WEBGL,!1)}Release(){super.Release(),0>=this.GetRef()&&(this.#e.Release(),this.#d.deleteFramebuffer(this.#j),this.#d.deleteFramebuffer(this.#k))}GetAdapter(){return this.#d}CheckFeatureSupport(e){switch(e){case 0:return this.#f;case 1:return this.#g;case 2:return this.#h;case 3:return this.#i;default:return null}}GetBackBufferFramebuffer(){return this.#k}GetImmediateContext(){return null==this.#e?this.#e=new class extends ID3D11DeviceContext{}(this):this.#e.AddRef(),this.#e}CreateBuffer(e,t){this.#l(e,t),null!=this.#e&&this.#e.DirtyPipeline();let r=this.#d.createBuffer(),i=this.#d.STATIC_DRAW;switch(e.Usage){case 1:i=this.#d.STATIC_DRAW;break;case 2:default:i=this.#d.DYNAMIC_DRAW;break;case 3:i=this.#d.DYNAMIC_READ}let s,a;return 2==e.BindFlags?(s=this.#d.ELEMENT_ARRAY_BUFFER,a=this.#d.getParameter(this.#d.ELEMENT_ARRAY_BUFFER_BINDING)):4==e.BindFlags?(s=this.#d.UNIFORM_BUFFER,a=this.#d.getParameter(this.#d.UNIFORM_BUFFER_BINDING)):(s=this.#d.ARRAY_BUFFER,a=this.#d.getParameter(this.#d.ARRAY_BUFFER_BINDING)),this.#d.bindBuffer(s,r),null==t?this.#d.bufferData(s,e.ByteWidth,i):this.#d.bufferData(s,t,i),this.#d.bindBuffer(s,a),new class extends ID3D11Buffer{}(this,e,s,r)}CreateDepthStencilState(e){if(null==e)throw Error("Depth-Stencil description cannot be null");return this.#m(e),new class extends ID3D11DepthStencilState{}(this,e)}CreateDepthStencilView(e,t){if(null==t){let r=null;if(e instanceof ID3D11Texture1D)r=1;else if(e instanceof ID3D11Texture2D)r=3;else throw Error("Invalid resource type for DSV");let i=e.GetDesc();t=new D3D11_DEPTH_STENCIL_VIEW_DESC(i.Format,r,0,0,0,i.ArraySize)}return this.#n(e,t),new class extends ID3D11DepthStencilView{}(this,e,t)}CreateInputLayout(e){return null!=this.#e&&this.#e.DirtyPipeline(),new class extends ID3D11InputLayout{}(this,e)}CreatePixelShader(e){null!=this.#e&&this.#e.DirtyPipeline();let t=new HLSL(e,ShaderTypePixel),r=this.#o(t.GetGLSL(),this.#d.FRAGMENT_SHADER);return new class extends ID3D11PixelShader{}(this,r,t)}CreateRasterizerState(e){if(null==e)throw Error("Rasterizer description cannot be null");return this.#p(e),new class extends ID3D11RasterizerState{}(this,e)}CreateRenderTargetView(e,t){if(null==t){let r=null;if(e instanceof ID3D11Texture1D)r=2;else if(e instanceof ID3D11Texture2D)r=4;else if(e instanceof ID3D11Texture3D)r=8;else throw Error("Invalid resource type for RTV");let i=e.GetDesc();t=new D3D11_RENDER_TARGET_VIEW_DESC(i.Format,r,0,0,i.ArraySize)}this.#q(e,t);let s=t.Copy();return(4&e.GetDesc().MiscFlags)==4&&(2==s.FirstArraySlice?s.FirstArraySlice=3:3==s.FirstArraySlice&&(s.FirstArraySlice=2)),new class extends ID3D11RenderTargetView{}(this,e,s)}CreateSamplerState(e){if(null==e)throw Error("Sampler description cannot be null");return this.#r(e),new class extends ID3D11SamplerState{}(this,e)}CreateShaderResourceView(e,t){if(null==t){let r=e.GetDesc(),i=null;if(e instanceof ID3D11Texture1D)i=r.ArraySize>1?3:2;else if(e instanceof ID3D11Texture2D)i=!0&r.MiscFlags&&6==r.ArraySize?9:r.ArraySize>1?5:4;else if(e instanceof ID3D11Texture3D)i=8;else throw Error("Invalid resource type for SRV");t=new D3D11_SHADER_RESOURCE_VIEW_DESC(r.Format,i,0,r.MipLevels,0,r.ArraySize)}return this.#s(e,t),new class extends ID3D11ShaderResourceView{}(this,e,t)}CreateTexture1D(e,t){return this.#t(1,e,t)}CreateTexture2D(e,t){return this.#t(2,e,t)}CreateTexture3D(e,t){return this.#t(3,e,t)}#t(e,t,r){null!=this.#e&&this.#e.DirtyPipeline(),this.#u(e,t,r);let i=this.#d.createTexture(),s=this.#v(t.Format),a=s.InternalFormat,n=s.Format,l=s.Type;s.IsDepth,s.HasStencil;let h=s.IsCompressed,o=t.MipLevels>1,u=this.#w(e,t);this.#d.bindTexture(u,i);let c=1,p=1,f=1;switch(e){case 3:f=t.Depth;case 2:p=t.Height;case 1:c=t.Width}switch(u){case this.#d.TEXTURE_2D:case this.#d.TEXTURE_CUBE_MAP:this.#d.texStorage2D(u,t.MipLevels,a,c,p);break;case this.#d.TEXTURE_2D_ARRAY:this.#d.texStorage3D(u,t.MipLevels,a,c,p,t.ArraySize);break;case this.#d.TEXTURE_3D:this.#d.texStorage3D(u,t.MipLevels,a,c,p,f)}if(null!=r&&r.length>0)switch(u){case this.#d.TEXTURE_2D:for(let T=0;T<t.MipLevels&&T<r.length;T++){if(null==r[T])continue;let S=Math.pow(2,T),D=Math.max(1,Math.floor(c/S)),E=Math.max(1,Math.floor(p/S));this.#d.texSubImage2D(u,T,0,0,D,E,n,l,r[T])}break;case this.#d.TEXTURE_CUBE_MAP:let m=[this.#d.TEXTURE_CUBE_MAP_POSITIVE_X,this.#d.TEXTURE_CUBE_MAP_NEGATIVE_X,this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Y,this.#d.TEXTURE_CUBE_MAP_POSITIVE_Y,this.#d.TEXTURE_CUBE_MAP_POSITIVE_Z,this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Z];for(let d=0;d<6;d++)for(let g=0;g<t.MipLevels&&g<r.length/6;g++){if(null==r[g+d*t.MipLevels])continue;let x=Math.pow(2,g),R=Math.max(1,Math.floor(c/x)),_=Math.max(1,Math.floor(p/x));h?this.#d.compressedTexSubImage2D(m[d],g,0,0,R,_,n,r[g+d*t.MipLevels]):this.#d.texSubImage2D(m[d],g,0,0,R,_,n,l,r[g+d*t.MipLevels])}break;case this.#d.TEXTURE_2D_ARRAY:for(let I=0;I<t.ArraySize;I++)for(let A=0;A<t.MipLevels&&A<r.length/t.ArraySize;A++){if(null==r[A+I*t.MipLevels])continue;let C=Math.pow(2,A),P=Math.max(1,Math.floor(c/C)),$=Math.max(1,Math.floor(p/C));h?this.#d.compressedTexSubImage3D(u,A,0,0,I,P,$,1,n,r[A+I*t.MipLevels]):this.#d.texSubImage3D(u,A,0,0,I,P,$,1,n,l,r[A+I*t.MipLevels])}break;case this.#d.TEXTURE_3D:for(let w=0;w<t.MipLevels&&w<r.length;w++){if(null==r[w])continue;let L=Math.pow(2,w),M=Math.max(1,Math.floor(c/L)),F=Math.max(1,Math.floor(p/L)),b=Math.max(1,Math.floor(f/L));h?this.#d.compressedTexSubImage3D(u,w,0,0,0,M,F,b,n,r[w+arraySlice*t.MipLevels]):this.#d.texSubImage3D(u,w,0,0,0,M,F,b,n,l,r[w])}}switch(this.#x(u,o),this.#d.bindTexture(u,null),e){case 1:return new class extends ID3D11Texture1D{}(this,t,u,i);case 2:return new class extends ID3D11Texture2D{}(this,t,u,i);case 3:return new class extends ID3D11Texture3D{}(this,t,u,i);default:throw Error("Invalid texture dimension")}}CreateVertexShader(e){null!=this.#e&&this.#e.DirtyPipeline();let t=new HLSL(e,ShaderTypeVertex),r=this.#o(t.GetGLSL(),this.#d.VERTEX_SHADER);return new class extends ID3D11VertexShader{}(this,r,t)}ReadFromSubresource(e,t,r,i=null){if(!(null!=i&&i.IsEmpty())){if(t instanceof ID3D11Texture2D){let s=t.GetDesc();if(3!=s.Usage)throw Error("Invalid usage on resource - can only read from staging resources");if((131072&s.CPUAccessFlags)==0)throw Error("Invalid CPU Access flag on resource - must be set for reading");let a=D3D11CalcSubresource(s.MipLevels-1,s.ArraySize-1,s.MipLevels);if(r<0||r>a)throw Error("Invalid subresource index for reading");let n=Math.floor(r/s.MipLevels),l=r-n*s.MipLevels,h=Math.pow(2,l),o=Math.max(1,Math.floor(s.Width/h)),u=Math.max(1,Math.floor(s.Height/h)),c=0,p=0,f=o,T=u;null!=i&&(c=i.Left,p=u-i.Bottom,f=i.Right-i.Left,T=i.Bottom-i.Top),this.#e.DirtyPipeline(),this.#d.bindFramebuffer(this.#d.READ_FRAMEBUFFER,this.#j);let S=(4&s.MiscFlags)==4;if(!(s.ArraySize>1)||S){let D=this.#d.TEXTURE_2D;if(S)switch(n){case 0:D=this.#d.TEXTURE_CUBE_MAP_POSITIVE_X;break;case 1:D=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_X;break;case 2:D=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Y;break;case 3:D=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Y;break;case 4:D=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Z;break;case 5:D=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Z;break;default:throw Error("Invalid subresource for cube map reading")}this.#d.framebufferTexture2D(this.#d.READ_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,D,t.GetGLResource(),l)}else this.#d.framebufferTextureLayer(this.#d.READ_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,t.GetGLResource(),l,n);let E=this.#v(s.Format);this.#d.readPixels(c,p,f,T,E.Format,E.Type,e)}else if(t instanceof ID3D11Buffer)throw Error("Reading from a buffer is not yet implemented!");else throw Error("Given source resource is invalid or not yet implemented!")}}#o(y,v){let N=this.#d.createShader(v);this.#d.shaderSource(N,y),this.#d.compileShader(N);if(!this.#d.getShaderParameter(N,this.#d.COMPILE_STATUS))throw Error("Error compiling shader: "+this.#d.getShaderInfoLog(N));return N}#w(B,G){let O=G.ArraySize>1,U=(4&G.MiscFlags)==4;if(3==B)return this.#d.TEXTURE_3D;if(2==B&&U)return this.#d.TEXTURE_CUBE_MAP;if((1==B||2==B)&&!U)return O?this.#d.TEXTURE_2D_ARRAY:this.#d.TEXTURE_2D;throw Error("Description does not match any known WebGL texture types")}#v(V){let k={Type:null,Format:null,InternalFormat:null,IsDepth:!1,HasStencil:!1,IsCompressed:!1};switch(V){case 55:k.Type=this.#d.UNSIGNED_SHORT,k.Format=this.#d.DEPTH_COMPONENT,k.InternalFormat=this.#d.DEPTH_COMPONENT16,k.IsDepth=!0,k.HasStencil=!1;break;case 45:k.Type=this.#d.UNSIGNED_INT_24_8,k.Format=this.#d.DEPTH_STENCIL,k.InternalFormat=this.#d.DEPTH24_STENCIL8,k.IsDepth=!0,k.HasStencil=!0;break;case 40:k.Type=this.#d.FLOAT,k.Format=this.#d.DEPTH_COMPONENT,k.InternalFormat=this.#d.DEPTH_COMPONENT32F,k.IsDepth=!0,k.HasStencil=!1;break;case 28:k.Type=this.#d.UNSIGNED_BYTE,k.Format=this.#d.RGBA,k.InternalFormat=this.#d.RGBA8;break;case 29:k.Type=this.#d.UNSIGNED_BYTE,k.Format=this.#d.RGBA,k.InternalFormat=this.#d.SRGB8_ALPHA8;break;case 34:k.Type=this.#d.HALF_FLOAT,k.Format=this.#d.RG,k.InternalFormat=this.#d.RG16F;break;case 10:k.Type=this.#d.HALF_FLOAT,k.Format=this.#d.RGBA,k.InternalFormat=this.#d.RGBA16F;break;case 2:k.Type=this.#d.FLOAT,k.Format=this.#d.RGBA,k.InternalFormat=this.#d.RGBA32F;break;case 71:if(null==this.#i)throw Error("DXT compressed texture formats not supported by your device");k.Format=this.#i.COMPRESSED_RGBA_S3TC_DXT1_EXT,k.InternalFormat=this.#i.COMPRESSED_RGBA_S3TC_DXT1_EXT,k.IsCompressed=!0;break;case 74:if(null==this.#i)throw Error("DXT compressed texture formats not supported by your device");k.Format=this.#i.COMPRESSED_RGBA_S3TC_DXT3_EXT,k.InternalFormat=this.#i.COMPRESSED_RGBA_S3TC_DXT3_EXT,k.IsCompressed=!0;break;case 77:if(null==this.#i)throw Error("DXT compressed texture formats not supported by your device");k.Format=this.#i.COMPRESSED_RGBA_S3TC_DXT5_EXT,k.InternalFormat=this.#i.COMPRESSED_RGBA_S3TC_DXT5_EXT,k.IsCompressed=!0;break;default:throw Error("Format specified is not implemented yet!")}return k}#x(X,H){this.#d.texParameteri(X,this.#d.TEXTURE_MAG_FILTER,this.#d.LINEAR),this.#d.texParameteri(X,this.#d.TEXTURE_MIN_FILTER,H?this.#d.LINEAR_MIPMAP_LINEAR:this.#d.LINEAR),this.#d.texParameteri(X,this.#d.TEXTURE_WRAP_S,this.#d.CLAMP_TO_EDGE),this.#d.texParameteri(X,this.#d.TEXTURE_WRAP_T,this.#d.CLAMP_TO_EDGE),this.#d.texParameteri(X,this.#d.TEXTURE_WRAP_R,this.#d.CLAMP_TO_EDGE),this.#d.texParameterf(X,this.#d.TEXTURE_MIN_LOD,-3402823466e29),this.#d.texParameterf(X,this.#d.TEXTURE_MAX_LOD,3402823466e29),this.#d.texParameteri(X,this.#d.TEXTURE_COMPARE_MODE,this.#d.NONE),this.#d.texParameteri(X,this.#d.TEXTURE_COMPARE_FUNC,this.#d.NEVER),null!=this.#f&&this.#d.texParameterf(X,this.#f.TEXTURE_MAX_ANISOTROPY_EXT,1)}#l(W,z){let q=(1&W.BindFlags)==1,Y=(2&W.BindFlags)==2,j=(4&W.BindFlags)==4,Z=(8&W.BindFlags)==8,Q=(32&W.BindFlags)==32,K=(64&W.BindFlags)==64;if(W.ByteWidth<=0)throw Error("Invalid byte width for buffer description.  Must be greater than zero.");if(j&&W.ByteWidth%16!=0)throw Error("Invalid byte width for buffer description.  Constant buffer byte width must be a multiple of 16");if(this.#y(W,z),q||Y||j||Z||Q||K){if(j&&4!=W.BindFlags)throw Error("Constant Buffer bind flag cannot be combined with any other flags.");if(Y&&2!=W.BindFlags)throw Error("Index Buffer bind flag cannot be combined with any other flags.")}else throw Error("Invalid bind flag for buffer description.");if(0!=W.CPUAccessFlags&&131072!=W.CPUAccessFlags&&65536!=W.CPUAccessFlags)throw Error("Invalid CPU Access Flags for buffer description.");if(131072==W.CPUAccessFlags&&3!=W.Usage)throw Error("Invalid CPU Access in buffer description.  CPU Access Read can only be used with Staging usage.");if(65536==W.CPUAccessFlags&&(0==W.Usage||1==W.Usage))throw Error("Invalid CPU Access in buffer description.  CPU Access Write can only be used with Dynamic or Staging usage.");if(0!=W.MiscFlags)throw Error("Invalid Misc Flags for buffer description.");if(0!=W.StructureByteStride)throw Error("Invalid Structured Byte Stride for buffer description.")}#m(J){if(1!=J.DepthWriteMask&&0!=J.DepthWriteMask)throw Error("Invalid Depth Write Mask for depth stencil description");if(J.DepthFunc<1||J.DepthFunc>8)throw Error("Invalid Depth Function for depth stencil description");if(J.StencilEnable)throw Error("Stencil support not yet implemented!")}#n(ee,et){if(null==ee)throw Error("Resource cannot be null when creating a DSV");let er=ee.GetDesc();if((64&er.BindFlags)==0)throw Error("Cannot create DSV: resource is not marked for depth/stencil binding");if(0==et.Format)et.Format=er.Format;else if(et.Format!=er.Format)throw Error("Specified DSV Format does not match resource");switch(et.Format){case 55:case 40:case 45:break;default:throw Error("Specified DSV Format is invalid or not yet implemented!")}switch(et.ViewDimension){case 3:if(!(ee instanceof ID3D11Texture2D))throw Error("Specified DSV View Dimension does not match resource");break;case 1:if(!(ee instanceof ID3D11Texture1D))throw Error("Specified DSV View Dimension does not match resource");break;case 2:case 4:throw Error("Specified DSV View Dimension is not yet implemented!");default:throw Error("Specified DSV View Dimension is invalid")}switch(et.Flags){case 0:break;case 1:case 2:throw Error("Specified DSV Flags not yet implemented!");default:throw Error("Specified DSV Flags are invalid")}if(et.MipSlice<0||et.MipSlice>=er.MipLevels)throw Error("Specified DSV Mip Slice is invalid");if(et.FirstArraySlice<0||et.FirstArraySlice>=er.ArraySize)throw Error("Specified DSV First Array Slice is invalid");let ei=et.FirstArraySlice+et.ArraySize-1;if(0==et.ArraySize||ei<0||ei>=er.ArraySize)throw Error("Specified DSV Array Size is invalid")}#p(es){switch(es.FillMode){case 3:break;case 2:throw Error("Wireframe fill mode not yet implemented!");default:throw Error("Invalid Fill Mode for rasterizer description")}if(1!=es.CullMode&&2!=es.CullMode&&3!=es.CullMode)throw Error("Invalid Cull Mode for rasterizer description");if(0!=es.DepthBiasClamp)throw Error("Depth Bias Clamp unsupported in WebGL");if(!es.DepthClipEnable)throw Error("Disabling Depth Clip unsupported in WebGL");if(es.MultisampleEnable)throw Error("Multisampling not yet implemented");if(es.AntiasliasedLineEnable)throw Error("Antialiased Lines not yet implemented")}#r(ea){let en=ea.Filter;if(en<0||en>213||(2&en)==2||(8&en)==8||(32&en)==32)throw Error("Invalid filter mode for sampler state");let el=ea.AddressU,eh=ea.AddressV,eo=ea.AddressW;if(el<1||el>5)throw Error("Invalid address U mode for sampler state");if(eh<1||eh>5)throw Error("Invalid address V mode for sampler state");if(eo<1||eo>5)throw Error("Invalid address W mode for sampler state");if(4==el||4==eh||4==eo)throw Error("Border address mode unsupported in WebGL");if(5==el||5==eh||5==eo)throw Error("MirrorOnce address mode unsupported in WebGL");let eu=(64&en)==64;if(this.#f&&eu){let ec=this.#d.getParameter(this.#f.MAX_TEXTURE_MAX_ANISOTROPY_EXT);if(ea.MaxAnisotropy<1||ea.MaxAnisotropy>ec)throw Error(`Invalid MaxAnisotropy value for sampler state - range is [1, ${ec}]`)}else if(eu)throw Error("Anisotropic filtering not available on this device");let ep=ea.ComparisonFunc;if((128&en)==128&&(ep<1||ep>8))throw Error("Invalid comparison function for sampler state");let ef=ea.BorderColor;if((4==el||4==eh||4==eo)&&ef[0]<0||ef[0]>1||ef[1]<0||ef[1]>1||ef[2]<0||ef[2]>1||ef[3]<0||ef[3]>1)throw Error("Invalid border color for sampler state")}#q(eT,eS){if(null==eT)throw Error("Resource cannot be null when creating an RTV");let eD=eT.GetDesc();if((32&eD.BindFlags)==0)throw Error("Cannot create RTV: resource is not marked for render target binding");if(0==eS.Format)eS.Format=eD.Format;else if(eS.Format!=eD.Format)throw Error("Specified RTV Format does not match resource");switch(eS.Format){case 28:case 29:case 34:case 10:case 2:break;default:throw Error("Specified RTV Format is invalid or not yet implemented!")}switch(eS.ViewDimension){case 4:case 5:if(!(eT instanceof ID3D11Texture2D))throw Error("Specified RTV View Dimension does not match resource");break;case 2:case 3:if(!(eT instanceof ID3D11Texture1D))throw Error("Specified RTV View Dimension does not match resource");break;case 8:if(!(eT instanceof ID3D11Texture3D))throw Error("Specified RTV View Dimension does not match resource");break;default:throw Error("Specified RTV View Dimension is invalid")}if(eS.MipSlice<0||eS.MipSlice>=eD.MipLevels)throw Error("Specified RTV Mip Slice is invalid");if(eS.FirstArraySlice<0||eS.FirstArraySlice>=eD.ArraySize)throw Error("Specified RTV First Array Slice is invalid");let eE=eS.FirstArraySlice+eS.ArraySize-1;if(0==eS.ArraySize||eE<0||eE>=eD.ArraySize)throw Error("Specified RTV Array Size is invalid")}#s(em,ed){if(null==em)throw Error("Resource cannot be null when creating an SRV");let eg=em.GetDesc();if((8&eg.BindFlags)==0)throw Error("Cannot create SRV: resource is not marked for shader resource binding");switch(ed.Format){case 28:case 29:case 34:case 10:case 2:case 71:case 74:case 77:break;default:throw Error("Specified SRV Format is invalid or not yet implemented!")}if(ed.Format!=eg.Format)throw Error("Specified SRV Format does not match resource");switch(ed.ViewDimension){case 4:case 5:case 9:if(!(em instanceof ID3D11Texture2D))throw Error("Specified SRV View Dimension does not match resource");break;case 2:case 3:if(!(em instanceof ID3D11Texture1D))throw Error("Specified SRV View Dimension does not match resource");break;case 8:if(!(em instanceof ID3D11Texture3D))throw Error("Specified SRV View Dimension does not match resource");break;default:throw Error("Specified SRV View Dimension is invalid")}if(ed.MostDetailedMip<0||ed.MostDetailedMip>=eg.MipLevels)throw Error("Specified SRV Most Detailed Mip is invalid");let e8=ed.MostDetailedMip+ed.MipLevels-1;if(0==ed.MipLevels||e8<0||e8>=eg.MipLevels)throw Error("Specified SRV Mip Levels value is invalid");if(ed.FirstArraySlice<0||ed.FirstArraySlice>=eg.ArraySize)throw Error("Specified SRV First Array Slice is invalid");let ex=ed.FirstArraySlice+ed.ArraySize-1;if(0==ed.ArraySize||ex<0||ex>=eg.ArraySize)throw Error("Specified SRV Array Size is invalid")}#u(eR,e_,eI){if(null==e_)throw Error("Description cannot be null when creating a texture");if(eR<1||eR>3)throw Error("Invalid texture dimension");let eA=this.#d.getParameter(this.#d.MAX_TEXTURE_SIZE),eC=this.#d.getParameter(this.#d.MAX_3D_TEXTURE_SIZE),eP=this.#d.getParameter(this.#d.MAX_CUBE_MAP_TEXTURE_SIZE),e$=this.#d.getParameter(this.#d.MAX_ARRAY_TEXTURE_LAYERS),ew=(4&e_.MiscFlags)==4,eL=(1&e_.MiscFlags)==1;if(ew&&2!=eR)throw Error("Only 2D textures may be used as cube maps");if(ew){if(e_.Width<=0||e_.Width>eP||e_.Height<=0||e_.Height>eP)throw Error(`Texture Cube dimensions must be between 1 and ${eP}, inclusive`)}else{let eM=3==eR?eC:eA;switch(eR){case 3:if(e_.Depth<=0||e_.Height>eM)throw Error(`Texture depth must be between 1 and ${eM}, inclusive`);case 2:if(e_.Height<=0||e_.Height>eM)throw Error(`Texture height must be between 1 and ${eM}, inclusive`);case 1:if(e_.Width<=0||e_.Width>eM)throw Error(`Texture width must be between 1 and ${eM}, inclusive`)}}if(3==eR&&Object.hasOwn(e_,"ArraySize"))throw Error("3D textures cannot have an array size");if(ew&&6!=e_.ArraySize)throw Error("Invalid array size for texture cube - must be exactly 6");if(e_.ArraySize<=0||e_.ArraySize>e$)throw Error(`Array size must be greater than zero and less than or equal to ${e$}`);let eF=Math.log2(Math.max(e_.Width,e_.Height))+1;if(0==e_.MipLevels&&(e_.MipLevels=eF),e_.MipLevels<=0||e_.MipLevels>eF)throw Error("Invalid mip levels specified for texture");switch(e_.Format){case 55:case 40:case 45:case 28:case 29:break;case 71:case 74:case 77:if(null==this.#i)throw Error("DXT compressed texture formats not supported by your device");break;case 34:case 10:case 2:if(null==this.#g)throw Error("Floating point texture formats are unsupported on your device");break;default:throw Error("Specified texture format is invalid or not yet implemented!")}switch(this.#y(e_,eI),e_.BindFlags){case 0:case 8:case 32:case 64:case 40:case 72:break;default:throw Error("Invalid bind flags specified")}if(eL&&((8&e_.BindFlags)==0||(32&e_.BindFlags)==0))throw Error("Resource must have SHADER_RESOURCE and RENDER_TARGET bind flags to generate mip maps")}#y(eb,ey){switch(eb.Usage){case 0:break;case 2:if((64&eb.BindFlags)==64||(32&eb.BindFlags)==32)throw Error("Dynamic resources cannot be bound for output");if(0==eb.BindFlags)throw Error("Dynamic resources must have at least one Bind Flag");if(65536!=eb.CPUAccessFlags)throw Error("Dynamic resources must have CPU Access Write");if(!(eb instanceof D3D11_BUFFER_DESC)){if(1!=eb.MipLevels)throw Error("Invalid mip levels - dynamic resources can only have a single subresource");if(1!=eb.ArraySize)throw Error("Invalid array size - dynamic resources can only have a single subresource")}break;case 3:if(0!=eb.BindFlags)throw Error("Staging resources cannot be bound to the pipeline and cannot have any bind flags set");if(0==eb.CPUAccessFlags)throw Error("Staging resources must have a CPU Access of either Read or Write.");break;case 1:if(null==ey||0==ey.length)throw Error("Immutable textures must have initial data");if((64&eb.BindFlags)==64||(32&eb.BindFlags)==32)throw Error("Immutable resources cannot be bound for output");break;default:throw Error("Invalid usage specified")}}}class ID3D11DeviceContext extends ID3D11DeviceChild{#d;#k;#z;#A;#B;#C;#D;#E;#F;#G;#H;#I;#J;#K;#L;#M;#N;#O;#P;#Q;#R;#S;#T;#U;#V;#W;#X;#Y;#Z;#$;#_;#aa;#ab;#ac;#ad;#ae;#af;#ag;#ah;#ai;#aj;#ak;#al;#am;#an;constructor(e){if(super(e),new.target===ID3D11DeviceContext)throw this.Release(),Error("Cannot instantiate ID3D11DeviceContext objects - use device.GetImmediateContext() or D3D11CreateDeviceAndSwapChain() instead");this.#d=e.GetAdapter(),this.#d.enable(this.#d.CULL_FACE),this.#d.frontFace(this.#d.CW),this.#d.enable(this.#d.DEPTH_TEST),this.#k=e.GetBackBufferFramebuffer(),this.#z=this.#d.createFramebuffer(),this.#B=new Map,this.#A=this.#d.getParameter(this.#d.MAX_COMBINED_TEXTURE_IMAGE_UNITS),this.#F=Array(this.#A).fill(!1),this.#C=null,this.#D=null,this.#G=!0,this.#H=!0,this.#I=null,this.#J=0,this.#K=[],this.#L=[],this.#M=[],this.#N=null,this.#O=57,this.#P=null,this.#Q=this.#d.getParameter(this.#d.MAX_VERTEX_TEXTURE_IMAGE_UNITS),this.#R=this.#d.getParameter(this.#d.MAX_VERTEX_UNIFORM_BLOCKS),this.#S=Array(this.#R).fill(null),this.#T=!0,this.#U=null,this.#Z=!0,this.#V=new D3D11_RECT(0,0,0,0),this.#$=!0,this.#W=null,this.#Y=!0,this.#X=new D3D11_RASTERIZER_DESC(3,3),this.#_=null,this.#aa=this.#d.getParameter(this.#d.MAX_TEXTURE_IMAGE_UNITS),this.#ab=this.#d.getParameter(this.#d.MAX_FRAGMENT_UNIFORM_BLOCKS),this.#ac=Array(this.#ab).fill(null),this.#ae=Array(this.#aa).fill(null),this.#ag=Array(this.#aa).fill(null),this.#ad=!0,this.#af=!0,this.#ah=!0,this.#ai=[],this.#aj=null,this.#ak=null,this.#al=0,this.#an=!0,this.#am=new D3D11_DEPTH_STENCIL_DESC}DirtyPipeline(){this.#H=!0,this.#G=!0,this.#T=!0,this.#Y=!0,this.#ad=!0,this.#af=!0,this.#ah=!0,this.#an=!0}ClearRenderTargetView(e,t){if(null==e)throw Error("Invalid RenderTargetView for clear");this.#ao(),this.#ap([e]);let[r,i]=this.#aq();this.#d.scissor(0,0,r,i),this.#d.clearColor(t[0],t[1],t[2],t[3]),this.#d.clear(this.#d.COLOR_BUFFER_BIT),this.#$=!0}ClearDepthStencilView(e,t,r,i){if(null==e)throw Error("Invalid DepthStencilView for clear");let s=!0&t,a=!0&t;if(!s&&!a)return;this.#ao(),this.#ar(e);let[n,l]=this.#aq();this.#d.scissor(0,0,n,l);let h=0;s&&(this.#d.clearDepth(r),h|=this.#d.DEPTH_BUFFER_BIT),a&&(this.#d.clearStencil(i),h|=this.#d.STENCIL_BUFFER_BIT),this.#d.clear(h),this.#$=!0}CopyResource(e,t){if(e==t)throw Error("Cannot copy resource when destination and source are the same resource");if(e instanceof ID3D11Buffer&&t instanceof ID3D11Buffer)throw Error("Buffer resource copying not yet implemented!");if(e instanceof ID3D11Texture2D&&t instanceof ID3D11Texture2D){let r=t.GetDesc(),i=e.GetDesc();if(1==e.Usage)throw Error("Cannot use an immutable resource as a copy destination");if(r.Width!=i.Width||r.Height!=i.Height||r.ArraySize!=i.ArraySize||r.MipLevels!=i.MipLevels)throw Error("Source and destination resources do not match in size or subresource count");if(r.Format!=i.Format)throw Error("Source and destination resources have different formats");for(let s=0;s<r.ArraySize;s++)for(let a=0;a<r.MipLevels;a++){let n=D3D11CalcSubresource(a,s,r.MipLevels);this.CopySubresourceRegion(e,n,0,0,0,t,n,null)}}else throw Error("Resources being copied do not match or are not yet implemented!")}CopySubresourceRegion(e,t,r,i,s,a,n,l=null){if(null!=l&&l.IsEmpty())return;let h=a.GetDesc(),o=e.GetDesc();if(1==o.Usage)throw Error("Cannot copy into an immutable resource");if(this.#as(h,n),this.#as(o,t),a==e&&n==t)throw Error("Cannot use the same subresource as both the source and destination of a copy");if(h.Format!=o.Format)throw Error("Source and destination must have same format when copying");let u=a instanceof ID3D11Buffer,c=e instanceof ID3D11Buffer;if(u&&!c||c&&!u)throw Error("Source and destination must be the same type (buffer or texture) when copying");if(a instanceof ID3D11Texture2D){if(0!=s)throw Error("Invalid destination Z value for 2D textures - must be zero");if(null!=l){let p=Math.floor(n/h.MipLevels),f=n-p*h.MipLevels,T=Math.pow(2,f),S=Math.max(1,Math.floor(o.Width/T)),D=Math.max(1,Math.floor(o.Height/T));if(l.Left<0||l.Right>S||l.Top<0||l.Bottom>D)throw Error("Source box extends outside source resource dimensions for mip level "+f)}}else throw Error("Given source resource is invalid or not yet implemented!");if(e instanceof ID3D11Texture2D){let E=Math.floor(t/o.MipLevels),m=t-E*o.MipLevels,d=o.ArraySize>1,g=(4&o.MiscFlags)==4,x=Math.pow(2,m),R=Math.max(1,Math.floor(o.Width/x)),_=Math.max(1,Math.floor(o.Height/x)),I=0,A=0,C=R,P=_;if(null!=l){I=l.Left,A=_-l.Bottom,C=l.Right-l.Left;let $=i+(P=l.Bottom-l.Top);i=_-$}if(r<0||i<0||r+C>R||i+P>_)throw Error("Destination offset extends outside destination resource dimensions for mip level "+m);if(g&&(E<0||E>=6))throw Error("Invalid subresource for cube map copying");if(this.#at(a,h,n),this.#an=!0,!d||g){let w=this.#d.TEXTURE_2D;if(g){switch(E){case 0:w=this.#d.TEXTURE_CUBE_MAP_POSITIVE_X;break;case 1:w=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_X;break;case 2:w=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Y;break;case 3:w=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Y;break;case 4:w=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Z;break;case 5:w=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Z}this.#d.bindTexture(this.#d.TEXTURE_CUBE_MAP,e.GetGLResource())}else this.#d.bindTexture(this.#d.TEXTURE_2D,e.GetGLResource());this.#d.copyTexSubImage2D(w,m,r,i,I,A,C,P)}else this.#d.bindTexture(this.#d.TEXTURE_2D_ARRAY,e.GetGLResource()),this.#d.copyTexSubImage3D(this.#d.TEXTURE_2D_ARRAY,m,r,i,E,I,A,C,P)}else throw Error("Given destination resource is invalid or not yet implemented!")}#as(e1,ev){let eN=D3D11CalcSubresource(e1.MipLevels-1,e1.ArraySize-1,e1.MipLevels);if(ev<0||ev>eN)throw Error("Invalid subresource index")}#at(eB,eG,eO){this.#d.bindFramebuffer(this.#d.READ_FRAMEBUFFER,this.#z);let eU=Math.floor(eO/eG.MipLevels),e0=eO-eU*eG.MipLevels,eV=(4&eG.MiscFlags)==4;if(!(eG.ArraySize>1)||eV){let ek=this.#d.TEXTURE_2D;if(eV)switch(eU){case 0:ek=this.#d.TEXTURE_CUBE_MAP_POSITIVE_X;break;case 1:ek=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_X;break;case 2:ek=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Y;break;case 3:ek=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Y;break;case 4:ek=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Z;break;case 5:ek=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Z;break;default:throw Error("Invalid subresource for cube map reading")}this.#d.framebufferTexture2D(this.#d.READ_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,ek,eB.GetGLResource(),e0)}else this.#d.framebufferTextureLayer(this.#d.READ_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,eB.GetGLResource(),e0,eU)}GenerateMips(e){let t=e.GetResource();if((1&t.GetDesc().MiscFlags)==0){t.Release();return}let r=t.GetGLTarget();this.#d.bindTexture(r,t.GetGLResource()),this.#d.generateMipmap(r),this.DirtyPipeline(),t.Release()}IASetInputLayout(e){this.#I=e,this.#H=!0}IASetIndexBuffer(e,t){this.#N=e,this.#O=t,null==e?this.#d.bindBuffer(this.#d.ELEMENT_ARRAY_BUFFER,null):this.#d.bindBuffer(this.#d.ELEMENT_ARRAY_BUFFER,this.#N.GetGLResource()),this.#H=!0}IASetPrimitiveTopology(e){this.#J=e}IASetVertexBuffers(e,t,r,i){this.#K=[],this.#L=[],this.#M=[];for(let s=0;s<t.length;s++)this.#K[e+s]=t[s],this.#L[e+s]=r[s],this.#M[e+s]=i[s];this.#H=!0}VSSetShader(e){this.#P=e,this.#G=!0}VSSetConstantBuffers(e,t){if(e+t.length<0||e+t.length>=this.#R)throw Error("Attempting to set VS constant buffers outside valid range");for(let r=0;r<t.length;r++)this.#S[r+e]=t[r];this.#T=!0}RSGetState(){return null==this.#W?null:(this.#W.AddRef(),this.#W)}RSSetState(e){this.#W=e,this.#Y=!0}RSGetScissorRects(){return[structuredClone(this.#V)]}RSSetScissorRects(e){this.#V=structuredClone(e[0]),this.#$=!0,this.#Y=!0}RSGetViewports(){return[structuredClone(this.#U)]}RSSetViewports(e){this.#U=structuredClone(e[0]),this.#Z=!0}PSSetShader(e){this.#_=e,this.#G=!0}PSSetConstantBuffers(e,t){if(e<0||e+t.length>=this.#ab)throw Error("Attempting to set PS constant buffers outside valid range");for(let r=0;r<t.length;r++)this.#ac[r+e]=t[r];this.#ad=!0}PSSetSamplers(e,t){if(e<0||e+t.length>=this.#aa)throw Error("Attempting to set PS samplers outside valid range");for(let r=0;r<t.length;r++)this.#ag[r+e]=t[r];this.#ah=!0}PSSetShaderResources(e,t){if(e<0||e+t.length>=this.#aa)throw Error("Attempting to set PS shader resources outside valid range");for(let r=0;r<t.length;r++)this.#ae[r+e]=t[r];this.#af=!0}OMSetDepthStencilState(e,t){this.#ak=e,this.#al=t,this.#an=!0}OMSetRenderTargets(e,t){if(null==e||0==e.length)throw Error("Unbinding render targets not yet implemented!");if(e.length>1)throw Error("Multiple render targets not yet implemented!");this.#ai=e.slice(),this.#aj=t,this.#an=!0,this.#Z=!0}OMGetRenderTargets(){return[this.#ai.slice(),this.#aj]}#au(){if(!this.#H||null==this.#I)return;let eX=this.#I.GetInputElementDescs(),e2=-1;for(let eH=0;eH<eX.length;eH++){let eW=eX[eH],ez=this.#av(eW.Format),e3=this.#aw(eW.Format),e6=eW.InputSlot;e6>=this.#K.length||(e6!=e2&&(this.#d.bindBuffer(this.#d.ARRAY_BUFFER,this.#K[e6].GetGLResource()),e2=e6),this.#d.enableVertexAttribArray(eH),this.#d.vertexAttribPointer(eH,e3,ez,!1,this.#L[e6],this.#M[e6]+eW.AlignedByteOffset))}this.#H=!1}#ax(){if(!this.#G)return;if(null==this.#P)throw Error("No vertex shader bound!");if(null==this.#_)throw Error("No pixel shader bound!");this.#B.has(this.#P)||this.#B.set(this.#P,new Map);let eq=this.#B.get(this.#P);if(!eq.has(this.#_)){let eY=Array(this.#Q),e4=Array(this.#Q),e7=Array(this.#aa),e5=Array(this.#aa);for(let ej=0;ej<this.#Q;ej++)eY[ej]=[],e4[ej]=[];for(let eZ=0;eZ<this.#aa;eZ++)e7[eZ]=[],e5[eZ]=[];eq.set(this.#_,{GLProgram:null,CBufferMap:Array(this.#R+this.#ab).fill(-1),TextureSamplerMap:{VSTextures:eY,VSSamplers:e4,PSTextures:e7,PSSamplers:e5}})}let eQ=eq.get(this.#_),eK=eQ.GLProgram;if(null==eK){eK=this.#ay(this.#P,this.#_),eQ.GLProgram=eK;let eJ=this.#P.GetCBuffers();for(let e9=0;e9<eJ.length;e9++){let te=eJ[e9];if(te.RegisterIndex<0||te.RegisterIndex>=this.#R)throw Error("Invalid register index for vertex shader constant buffer");let tt=this.#d.getUniformBlockIndex(eK,te.NameGL);eQ.CBufferMap[te.RegisterIndex]=tt}let tr=this.#_.GetCBuffers();for(let ti=0;ti<tr.length;ti++){let ts=tr[ti];if(ts.RegisterIndex<0||ts.RegisterIndex>=this.#ab)throw Error("Invalid register index for pixel shader constant buffer");let ta=this.#d.getUniformBlockIndex(eK,ts.NameGL),tn=ts.RegisterIndex+this.#R;eQ.CBufferMap[tn]=ta}let tl=0,th=this.#P.GetTextureSamplerCombinations();for(let to=0;to<th.length;to++){let tu=th[to];if(tl>=this.#Q)throw Error("Too many vertex shader texture/sampler combinations in use!");let tc=tu.Texture.RegisterIndex,tp=tu.Sampler.RegisterIndex,tf=this.#d.getUniformLocation(eK,tu.CombinedName);eQ.TextureSamplerMap.VSTextures[tc].push({TextureUnit:tl,UniformLocation:tf}),eQ.TextureSamplerMap.VSSamplers[tp].push(tl),tl++}let tT=this.#_.GetTextureSamplerCombinations();for(let tS=0;tS<tT.length;tS++){let tD=tT[tS];if(tl>=this.#aa)throw Error("Too many pixel shader texture/sampler combinations in use!");if(tl>=this.#A)throw Error("Too many total texture/sampler combinations in use!");let tE=tD.Texture.RegisterIndex,tm=tD.Sampler.RegisterIndex,td=this.#d.getUniformLocation(eK,tD.CombinedName);eQ.TextureSamplerMap.PSTextures[tE].push({TextureUnit:tl,UniformLocation:td}),eQ.TextureSamplerMap.PSSamplers[tm].push(tl),tl++}}this.#d.useProgram(eK),this.#C=eK,this.#D=eQ.CBufferMap,this.#E=eQ.TextureSamplerMap,this.#G=!1,this.#T=!0,this.#ad=!0,this.#ah=!0,this.#af=!0}#ay(tg,t8){let tx=this.#d.createProgram();this.#d.attachShader(tx,tg.GetGLShader()),this.#d.attachShader(tx,t8.GetGLShader()),this.#d.linkProgram(tx);if(!this.#d.getProgramParameter(tx,this.#d.LINK_STATUS))throw Error("Error linking shaders: "+this.#d.getProgramInfoLog(tx));this.#d.validateProgram(tx);if(!this.#d.getProgramParameter(tx,this.#d.VALIDATE_STATUS))throw Error("Error validating shaders: "+this.#d.getProgramInfoLog(tx));return tx}#az(){if(this.#T)for(let tR=0;tR<this.#S.length;tR++){let t_=this.#S[tR],tI=this.#D[tR];-1==tI||null==t_?this.#d.bindBufferBase(this.#d.UNIFORM_BUFFER,tR,null):(this.#d.bindBufferBase(this.#d.UNIFORM_BUFFER,tR,t_.GetGLResource()),this.#d.uniformBlockBinding(this.#C,tI,tR))}if(this.#ad)for(let tA=0;tA<this.#ac.length;tA++){let tC=this.#ac[tA],tP=tA+this.#R,t$=this.#D[tP];-1==t$||null==tC?this.#d.bindBufferBase(this.#d.UNIFORM_BUFFER,tP,null):(this.#d.bindBufferBase(this.#d.UNIFORM_BUFFER,tP,tC.GetGLResource()),this.#d.uniformBlockBinding(this.#C,t$,tP))}this.#T=!1,this.#ad=!1}#aA(){if(this.#F.fill(!1),this.#af)for(let tw=0;tw<this.#ae.length;tw++){let tL=this.#ae[tw];if(null==tL)continue;let tM=this.#E.PSTextures[tw];for(let tF=0;tF<tM.length;tF++){let tb=tL.GetResource(),ty=tb.GetGLTarget();this.#F[tM[tF].TextureUnit]=1!=tb.GetDesc().MipLevels,this.#d.activeTexture(this.#aB(tM[tF].TextureUnit)),this.#d.bindTexture(ty,tb.GetGLResource()),this.#d.uniform1i(tM[tF].UniformLocation,tM[tF].TextureUnit);let t1=tL.GetDesc(),tv=t1.MostDetailedMip,tN=t1.MostDetailedMip+t1.MipLevels-1;this.#d.texParameteri(ty,this.#d.TEXTURE_BASE_LEVEL,tv),this.#d.texParameteri(ty,this.#d.TEXTURE_MAX_LEVEL,tN),tb.Release()}}if(this.#ah)for(let tB=0;tB<this.#ag.length;tB++){let tG=this.#ag[tB];if(null==tG)continue;let tO=this.#E.PSSamplers[tB];for(let tU=0;tU<tO.length;tU++){let t0=this.#F[tO[tU]];this.#d.bindSampler(tO[tU],tG.GetGLSampler(t0))}}this.#ah=!1,this.#af=!1}#aB(tV){return this.#d.TEXTURE0+tV}#aq(){let tk=0,tX=0;if(null!=this.#ai){for(let t2=0;t2<this.#ai.length;t2++)if(null!=this.#ai[t2]){let tH=this.#ai[t2].GetResource();tk=tH.GetDesc().Width,tX=tH.GetDesc().Height,tH.Release();let tW=Math.pow(2,this.#ai[t2].GetDesc().MipSlice);tk=Math.max(1,Math.floor(tk/tW)),tX=Math.max(1,Math.floor(tX/tW));break}}if(0==tX&&null!=this.#aj){let tz=this.#aj.GetResource();tk=tz.GetDesc().Width,tX=tz.GetDesc().Height,tz.Release();let t3=Math.pow(2,this.#aj.GetDesc().MipSlice);tk=Math.max(1,Math.floor(tk/t3)),tX=Math.max(1,Math.floor(tX/t3))}return[tk,tX]}#aC(){let t6=0,tq=0;if((this.#Z||this.#$)&&([t6,tq]=this.#aq()),this.#Z&&null!=this.#U&&tq>0&&t6>0){let tY=tq-this.#U.Height;this.#d.viewport(this.#U.TopLeftX,tY-this.#U.TopLeftY,this.#U.Width,this.#U.Height),this.#d.depthRange(this.#U.MinDepth,this.#U.MaxDepth),this.#Z=!1}if(this.#$&&tq>0&&t6>0){let t4=this.#V.Right-this.#V.Left,t7=this.#V.Bottom-this.#V.Top,t5=tq-t7;this.#d.scissor(this.#V.Left,t5-this.#V.Top,t4,t7),this.#$=!1}if(!this.#Y)return;let tj;switch((tj=null==this.#W?this.#X:this.#W.GetDesc()).CullMode){case 3:this.#d.enable(this.#d.CULL_FACE),this.#d.cullFace(this.#d.BACK);break;case 2:this.#d.enable(this.#d.CULL_FACE),this.#d.cullFace(this.#d.FRONT);break;default:this.#d.disable(this.#d.CULL_FACE)}this.#d.frontFace(tj.FrontCounterClockwise?this.#d.CCW:this.#d.CW),0==tj.DepthBias&&0==tj.SlopeScaleDepthBias?this.#d.disable(this.#d.POLYGON_OFFSET_FILL):(this.#d.enable(this.#d.POLYGON_OFFSET_FILL),this.#d.polygonOffset(tj.SlopeScaleDepthBias,tj.DepthBias)),tj.ScissorEnable?this.#d.enable(this.#d.SCISSOR_TEST):this.#d.disable(this.#d.SCISSOR_TEST),this.#Y=!1}#aD(){if(this.#an){{let tZ;(tZ=null==this.#ak?this.#am:this.#ak.GetDesc()).DepthEnable?this.#d.enable(this.#d.DEPTH_TEST):this.#d.disable(this.#d.DEPTH_TEST),0==tZ.DepthWriteMask?this.#d.depthMask(!1):1==tZ.DepthWriteMask&&this.#d.depthMask(!0),this.#d.depthFunc(this.#aE(tZ.DepthFunc))}this.#ao(),this.#ap(this.#ai),this.#ar(this.#aj),this.#an=!1}}#ao(){this.#d.bindFramebuffer(this.#d.READ_FRAMEBUFFER,null),this.#d.bindFramebuffer(this.#d.DRAW_FRAMEBUFFER,this.#k)}#ap(tQ){if(tQ.length>0){let tK=tQ[0].GetResource(),tJ=tK.GetDesc(),t9=tQ[0].GetDesc();if(!(tK instanceof ID3D11Texture2D))throw Error("RTV texture type OM binding not yet implemented");if((4&tJ.MiscFlags)==4){let re;switch(t9.FirstArraySlice){case 0:re=this.#d.TEXTURE_CUBE_MAP_POSITIVE_X;break;case 1:re=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_X;break;case 2:re=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Y;break;case 3:re=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Y;break;case 4:re=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Z;break;case 5:re=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Z;break;default:throw Error("Only array slices 0-5 are valid for texture cube RTVs")}this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,re,tK.GetGLResource(),t9.MipSlice)}else tJ.ArraySize>1?this.#d.framebufferTextureLayer(this.#d.DRAW_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,tK.GetGLResource(),t9.MipSlice,t9.FirstArraySlice):this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,this.#d.TEXTURE_2D,tK.GetGLResource(),t9.MipSlice);tK.Release()}}#ar(rt){if(null==rt)this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.DEPTH_STENCIL_ATTACHMENT,this.#d.TEXTURE_2D,null,0),this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.DEPTH_ATTACHMENT,this.#d.TEXTURE_2D,null,0);else{let rr=rt.GetResource(),ri=rt.GetDesc(),rs=45==ri.Format,ra=rs?this.#d.DEPTH_STENCIL_ATTACHMENT:this.#d.DEPTH_ATTACHMENT;rs||this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.DEPTH_STENCIL_ATTACHMENT,this.#d.TEXTURE_2D,null,0),this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,ra,this.#d.TEXTURE_2D,rr.GetGLResource(),ri.MipSlice),rr.Release()}}Draw(e,t){this.#au(),this.#ax(),this.#az(),this.#aA(),this.#aD(),this.#aC(),this.#d.drawArrays(this.#aF(this.#J),t,e)}DrawIndexed(e,t){this.#au(),this.#ax(),this.#az(),this.#aA(),this.#aD(),this.#aC();let r=this.#d.UNSIGNED_SHORT;switch(this.#O){case 57:r=this.#d.UNSIGNED_SHORT;break;case 42:r=this.#d.UNSIGNED_INT}this.#d.drawElements(this.#aF(this.#J),e,r,t)}Flush(){this.#d.finish()}UpdateSubresource(e,t,r,i,s,a){if(e instanceof ID3D11Buffer){if(1==e.GetDesc().Usage)throw Error("Cannot update immutable resource");if(0!=t)throw Error("Invalid subresource ("+t+") used for buffer update");if(null!=r)throw Error("Cannot update a box within a buffer resource");this.#d.bindBuffer(this.#d.UNIFORM_BUFFER,e.GetGLResource()),this.#d.bufferSubData(this.#d.UNIFORM_BUFFER,0,i)}else throw Error("Updating non-buffer resource not yet implemented!")}#av(rn){return this.#d.FLOAT}#aw(rl){switch(rl){case 41:return 1;case 16:return 2;case 6:return 3;case 2:return 4;default:return 0}}#aE(rh){switch(rh){case 1:return this.#d.NEVER;case 2:return this.#d.LESS;case 3:return this.#d.EQUAL;case 4:return this.#d.LEQUAL;case 5:return this.#d.GREATER;case 6:return this.#d.NOTEQUAL;case 7:return this.#d.GEQUAL;case 8:return this.#d.ALWAYS;default:throw Error("Invalid comparison function")}}#aF(ro){switch(ro){case 1:return this.#d.POINTS;case 2:return this.#d.LINES;case 3:return this.#d.LINE_STRIP;case 4:case 0:default:return this.#d.TRIANGLES;case 5:return this.#d.TRIANGLE_STRIP}}}class IDXGISwapChain extends IUnknown{#aG;#c;#d;#aH;#k;constructor(e,t){if(super(),new.target===IDXGISwapChain)throw Error("Cannot instantiate IDXGISwapChain objects directly.  Use DXGICreateSwapChain() or D3D11CreateDeviceAndSwapChain() instead.");if(this.#aG=t.Copy(),this.#c=e,this.#d=e.GetAdapter(),this.#aG.Width<=0)throw Error("Swap Chain width must be greater than zero");if(this.#aG.Height<=0)throw Error("Swap Chain height must be greater than zero");if(28!=this.#aG.Format&&29!=this.#aG.Format)throw Error("Invalid Swap Chain format");this.#d.canvas.width=this.#d.canvas.clientWidth,this.#d.canvas.height=this.#d.canvas.clientHeight,this.#aI(),this.#k=e.GetBackBufferFramebuffer()}GetDesc(){return structuredClone(this.#aG)}GetBuffer(){return this.#aH.AddRef(),this.#aH}Present(){this.#d.bindFramebuffer(this.#d.FRAMEBUFFER,null),this.#d.bindFramebuffer(this.#d.READ_FRAMEBUFFER,this.#k),this.#d.framebufferTexture2D(this.#d.READ_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,this.#d.TEXTURE_2D,this.#aH.GetGLResource(),0);let e=this.#aG.Width,t=this.#aG.Height;this.#d.blitFramebuffer(0,0,e,t,0,0,e,t,this.#d.COLOR_BUFFER_BIT,this.#d.NEAREST),this.#d.flush()}Release(){super.Release(),0>=this.GetRef()&&this.#aH.Release()}ResizeBuffers(e,t,r=0){if(0==r&&(r=this.#aG.Format),this.#aG.Width!=e||this.#aG.Height!=t||this.#aG.Format!=r){if(e<=0)throw Error("Swap Chain width must be greater than zero");if(t<=0)throw Error("Swap Chain height must be greater than zero");if(28!=r&&29!=r)throw Error("Invalid Swap Chain format");if(this.#d.canvas.width=this.#d.canvas.clientWidth,this.#d.canvas.height=this.#d.canvas.clientHeight,this.#aG.Width=e,this.#aG.Height=t,this.#aG.Format=r,this.#aH.Release(),0!=this.#aH.GetRef())throw Error("One or more outstanding back buffer references exist; cannot resize");this.#aJ(),this.#aI()}}#aI(){let ru=new D3D11_TEXTURE2D_DESC(this.#aG.Width,this.#aG.Height,1,1,this.#aG.Format,new DXGI_SAMPLE_DESC(1,0),0,32,0,0);this.#aH=this.#c.CreateTexture2D(ru,null)}#aJ(){this.#d.bindFramebuffer(this.#d.DRAW_FRAMEBUFFER,this.#k),this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,this.#d.TEXTURE_2D,null,0),this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.DEPTH_ATTACHMENT,this.#d.TEXTURE_2D,null,0),this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.DEPTH_STENCIL_ATTACHMENT,this.#d.TEXTURE_2D,null,0)}#aK(){let rc=["Color","Depth","DepthStencil"],rp=[this.#d.COLOR_ATTACHMENT0,this.#d.DEPTH_ATTACHMENT,this.#d.DEPTH_STENCIL_ATTACHMENT],rf=["Read","Draw"],rT=[this.#d.READ_FRAMEBUFFER,this.#d.DRAW_FRAMEBUFFER],rS=[this.#d.READ_FRAMEBUFFER_BINDING,this.#d.DRAW_FRAMEBUFFER_BINDING];for(let rD=0;rD<rT.length;rD++){let rE=this.#d.getParameter(rS[rD]);for(let rm=0;rm<rp.length;rm++){let rd="NULL";null!=rE&&(rd=this.#d.getFramebufferAttachmentParameter(rT[rD],rp[rm],this.#d.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME)),console.log("Target: "+rf[rD]+" | Attachment: "+rc[rm]),console.log(rd),console.log(" ")}}console.log("---")}}class ID3D11DepthStencilState extends ID3D11DeviceChild{#aG;constructor(e,t){if(super(e),new.target===ID3D11DepthStencilState)throw e.Release(),Error("Cannot instantiate ID3D11DepthStencilState objects - use device.CreateDepthStencilState() instead");this.#aG=t.Copy()}GetDesc(){return this.#aG.Copy()}}class ID3D11InputLayout extends ID3D11DeviceChild{#aL;constructor(e,t){if(super(e),new.target===ID3D11InputLayout)throw e.Release(),Error("Cannot instantiate ID3D11InputLayout objects - use device.CreateInputLayout() instead");this.#aL=this.#aM(t)}#aM(rg){let r8=[];for(let rx=0;rx<rg.length;rx++)r8[rx]=rg[rx].Copy();return r8}GetInputElementDescs(){return this.#aM(this.#aL)}}class ID3D11PixelShader extends ID3D11DeviceChild{#aN;#aO;constructor(e,t,r){if(super(e),new.target===ID3D11PixelShader)throw e.Release(),Error("Cannot instantiate ID3D11PixelShader objects - use device.CreatePixelShader() instead");this.#aN=t,this.#aO=r}GetGLShader(){return this.#aN}GetCBuffers(){return this.#aO.GetCBuffers()}GetTextureSamplerCombinations(){return this.#aO.GetTextureSamplerCombinations()}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteShader(this.#aN),e.Release()}}}class ID3D11RasterizerState extends ID3D11DeviceChild{#aG;constructor(e,t){if(super(e),new.target===ID3D11RasterizerState)throw e.Release(),Error("Cannot instantiate ID3D11RasterizerState objects - use device.CreateRasterizerState() instead");this.#aG=t.Copy()}GetDesc(){return this.#aG.Copy()}}class ID3D11SamplerState extends ID3D11DeviceChild{#aG;#aP;#aQ;constructor(e,t){if(super(e),new.target===ID3D11SamplerState)throw e.Release(),Error("Cannot instantiate ID3D11SamplerState objects - use device.CreateSamplerState() instead");this.#aG=t.Copy();let r=e.GetAdapter();this.#aP=r.createSampler(),this.#aQ=r.createSampler(),this.#aR(e,this.#aP,t,!1),this.#aR(e,this.#aQ,t,!0)}GetDesc(){return this.#aG.Copy()}GetGLSampler(e){return e?this.#aQ:this.#aP}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteSampler(this.#aP),e.GetAdapter().deleteSampler(this.#aQ),e.Release()}}#aR(rR,r_,rI,rA){let rC=rR.GetAdapter();rC.samplerParameteri(r_,rC.TEXTURE_MAG_FILTER,this.#aS(rC,rI.Filter)),rC.samplerParameteri(r_,rC.TEXTURE_MIN_FILTER,this.#aT(rC,rI.Filter,rA)),rC.samplerParameteri(r_,rC.TEXTURE_WRAP_S,this.#aU(rC,rI.AddressU)),rC.samplerParameteri(r_,rC.TEXTURE_WRAP_T,this.#aU(rC,rI.AddressV)),rC.samplerParameteri(r_,rC.TEXTURE_WRAP_R,this.#aU(rC,rI.AddressW)),rC.samplerParameterf(r_,rC.TEXTURE_MIN_LOD,rI.MinLOD),rC.samplerParameterf(r_,rC.TEXTURE_MAX_LOD,rI.MaxLOD),this.#aV(rI.Filter)&&(rC.samplerParameteri(r_,rC.TEXTURE_COMPARE_MODE,rC.COMPARE_REF_TO_TEXTURE),rC.samplerParameteri(r_,rC.TEXTURE_COMPARE_FUNC,this.#aE(rC,rI.ComparisonFunc)));let rP=rR.CheckFeatureSupport(0);this.#aW(rI.Filter)&&null!=rP&&rC.samplerParameteri(r_,rP.TEXTURE_MAX_ANISOTROPY_EXT,rI.MaxAnisotropy)}#aS(r$,rw){return(4&rw)==4?r$.LINEAR:r$.NEAREST}#aT(rL,rM,rF){let rb=(16&rM)==16?rL.LINEAR:rL.NEAREST,ry=(1&rM)==1?rL.LINEAR:rL.NEAREST;if(!rF)return rb;if(rb==rL.LINEAR&&ry==rL.LINEAR)return rL.LINEAR_MIPMAP_LINEAR;if(rb==rL.LINEAR&&ry==rL.NEAREST)return rL.LINEAR_MIPMAP_NEAREST;if(rb==rL.NEAREST&&ry==rL.LINEAR)return rL.NEAREST_MIPMAP_LINEAR;if(rb==rL.NEAREST&&ry==rL.NEAREST)return rL.NEAREST_MIPMAP_NEAREST;throw Error("Invalid filter")}#aW(r1){return(64&r1)==64}#aV(rv){return(128&rv)==128}#aU(rN,rB){switch(rB){case 1:return rN.REPEAT;case 2:return rN.MIRRORED_REPEAT;case 3:return rN.CLAMP_TO_EDGE;default:throw Error("Invalid address mode")}}#aE(rG,rO){switch(rO){case 1:return rG.NEVER;case 2:return rG.LESS;case 3:return rG.EQUAL;case 4:return rG.LEQUAL;case 5:return rG.GREATER;case 6:return rG.NOTEQUAL;case 7:return rG.GEQUAL;case 8:return rG.ALWAYS;default:throw Error("Invalid comparison function")}}}class ID3D11VertexShader extends ID3D11DeviceChild{#aN;#aO;constructor(e,t,r){if(super(e),new.target===ID3D11VertexShader)throw e.Release(),Error("Cannot instantiate ID3D11VertexShader objects - use device.CreateVertexShader() instead");this.#aN=t,this.#aO=r}GetGLShader(){return this.#aN}GetCBuffers(){return this.#aO.GetCBuffers()}GetTextureSamplerCombinations(){return this.#aO.GetTextureSamplerCombinations()}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteShader(this.#aN),e.Release()}}}class ID3D11Resource extends ID3D11DeviceChild{#aG;#aX;#aY;constructor(e,t,r,i){if(super(e),new.target===ID3D11Buffer)throw this.Release(),Error("Cannot instantiate ID3D11Resource objects - use corresponding Create() functions of an ID3D11Device object instead");this.#aG=t.Copy(),this.#aX=r,this.#aY=i}GetDesc(){return this.#aG.Copy()}GetGLTarget(){return this.#aX}GetGLResource(){return this.#aY}}class ID3D11Buffer extends ID3D11Resource{constructor(e,t,r,i){if(super(e,t,r,i),new.target===ID3D11Buffer)throw this.Release(),Error("Cannot instantiate ID3D11Buffer objects - use device.CreateBuffer() instead")}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteBuffer(this.GetGLResource()),e.Release()}}}class ID3D11Texture1D extends ID3D11Resource{constructor(e,t,r,i){if(super(e,t,r,i),new.target===ID3D11Texture1D)throw this.Release(),Error("Cannot instantiate ID3D11Texture1D objects - use device.CreateTexture1D() instead")}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteTexture(this.GetGLResource()),e.Release()}}}class ID3D11Texture2D extends ID3D11Resource{constructor(e,t,r,i){if(super(e,t,r,i),new.target===ID3D11Texture2D)throw this.Release(),Error("Cannot instantiate ID3D11Texture2D objects - use device.CreateTexture2D() instead")}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteTexture(this.GetGLResource()),e.Release()}}}class ID3D11Texture3D extends ID3D11Resource{constructor(e,t,r,i){if(super(e,t,r,i),new.target===ID3D11Texture3D)throw this.Release(),Error("Cannot instantiate ID3D11Texture3D objects - use device.CreateTexture3D() instead")}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteTexture(this.GetGLResource()),e.Release()}}}class ID3D11View extends ID3D11DeviceChild{#aZ;#aG;constructor(e,t,r){if(super(e),new.target===ID3D11View)throw e.Release(),Error("Cannot instantiate ID3D11View objects - use corresponding Create___View() functions of an ID3D11Device object instead");this.#aZ=t,this.#aG=r.Copy(),this.#aZ.AddRef()}GetDesc(){return this.#aG.Copy()}GetResource(){return this.#aZ.AddRef(),this.#aZ}Release(){super.Release(),0>=this.GetRef()&&this.#aZ.Release()}}class ID3D11DepthStencilView extends ID3D11View{constructor(e,t,r){if(super(e,t,r),new.target===ID3D11DepthStencilView)throw e.Release(),Error("Cannot instantiate ID3D11DepthStencilView objects - use device.CreateDepthStencilView() instead")}}class ID3D11RenderTargetView extends ID3D11View{constructor(e,t,r){if(super(e,t,r),new.target===ID3D11RenderTargetView)throw e.Release(),Error("Cannot instantiate ID3D11RenderTargetView objects - use device.CreateRenderTargetView() instead")}}class ID3D11ShaderResourceView extends ID3D11View{constructor(e,t,r){if(super(e,t,r),new.target===ID3D11ShaderResourceView)throw e.Release(),Error("Cannot instantiate ID3D11ShaderResourceView objects - use device.CreateShaderResourceView() instead")}}const TokenUnknown=0,TokenWhiteSpace=1,TokenCommentMultiline=2,TokenCommentSingle=3,TokenOperator=4,TokenIdentifier=5,TokenNumericLiteral=6,TokenPeriod=7,TokenComma=8,TokenColon=9,TokenSemicolon=10,TokenScopeLeft=11,TokenScopeRight=12,TokenParenLeft=13,TokenParenRight=14,TokenBracketLeft=15,TokenBracketRight=16,ShaderTypeVertex=0,ShaderTypePixel=1,PrefixAttribute="_attrib_",PrefixVarying="_vary_",PrefixVSInput="_vs_input_",PrefixVSOutput="_vs_output_",PrefixPSInput="_ps_input_",PrefixPSOutput="_ps_output_",PrefixVSCBuffer="_vs_",PrefixPSCBuffer="_ps_",PSOutputVariable="_sv_target_",ShaderLanguageHLSL=0,ShaderLanguageGLSL=1,HLSLDataTypeConversion={void:"void",bool:"bool",bool1:"bool",bool2:"bvec2",bool3:"bvec3",bool4:"bvec4",int:"int",int1:"int",int2:"ivec2",int3:"ivec3",int4:"ivec4",uint:"uint",uint1:"uint",uint2:"uvec2",uint3:"uvec3",uint4:"uvec4",dword:"uint",dword1:"uint",dword2:"uvec2",dword3:"uvec3",dword4:"uvec4",half:"float",half1:"float",half2:"vec2",half3:"vec3",half4:"vec4",float:"float",float1:"float",float2:"vec2",float3:"vec3",float4:"vec4",double:"float",double1:"float",double2:"vec2",double3:"vec3",double4:"vec4",float2x2:"mat2x2",float2x3:"mat2x3",float2x4:"mat2x4",float3x2:"mat3x2",float3x3:"mat3x3",float3x4:"mat3x4",float4x2:"mat4x2",float4x3:"mat4x3",float4x4:"mat4x4",matrix:"mat4x4"},HLSLMatrixElementConversion={_m00:"[0][0]",_m01:"[1][0]",_m02:"[2][0]",_m03:"[3][0]",_m10:"[0][1]",_m11:"[1][1]",_m12:"[2][1]",_m13:"[3][1]",_m20:"[0][2]",_m21:"[1][2]",_m22:"[2][2]",_m23:"[3][2]",_m30:"[0][3]",_m31:"[1][3]",_m32:"[2][3]",_m33:"[3][3]",_11:"[0][0]",_12:"[1][0]",_13:"[2][0]",_14:"[3][0]",_21:"[0][1]",_22:"[1][1]",_23:"[2][1]",_24:"[3][1]",_31:"[0][2]",_32:"[1][2]",_33:"[2][2]",_34:"[3][2]",_41:"[0][3]",_42:"[1][3]",_43:"[2][3]",_44:"[3][3]"},HLSLMatrixConstructorConversion={float2x2:"float2x2_tr",float3x3:"float3x3_tr",float4x4:"float4x4_tr",matrix:"float4x4_tr"},HLSLReservedWordConversion={$Global:"_global_cbuffer",input:"_input",output:"_output",pow:"pow_hlsl",frac:"fract"},HLSLTextureSampleConversion={Sample:"texture",SampleLevel:"textureLod"};class TokenIterator{#a$;#a_;constructor(e){this.#a$=e,this.#a_=-1}MoveNext(){return this.#a_++,this.#a_<this.#a$.length}Current(){return this.#a_>=this.#a$.length?null:this.#a$[this.#a_]}More(){return this.#a_<this.#a$.length-1}Position(){return this.#a_}GetRange(e,t){if(e<0||t>=this.#a$.length+1||t<=e)throw Error("Invalid range for token iterator");return this.#a$.slice(e,t)}PeekPrev(){return this.#a0(-1)}PeekNext(){return this.#a0(1)}PeekNextNext(){return this.#a0(2)}#a0(rU){let r0=this.#a_+rU;return r0<0||r0>=this.#a$.length?null:this.#a$[r0]}}class HLSL{#aO;#a1;#a$;#a2;#a3;#a4;#a5;#a6;#a7;#a8;#a9;Rules=[{Type:1,Pattern:/^\s+/},{Type:2,Pattern:/^\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\//},{Type:3,Pattern:/^\/\/.*/},{Type:4,Pattern:/^((<<=)|(>>=))/},{Type:4,Pattern:/^((\+=)|(-=)|(\*=)|(\/=)|(%=)|(<<)|(>>)|(&=)|(\|=)|(\^=)|(&&)|(\|\|)|(==)|(!=)|(<=)|(>=)|(\+\+)|(--))/},{Type:4,Pattern:/^[\+\-\*\/\%\=\~\&\|\^\?\<\>\!]/},{Type:5,Pattern:/^[_A-Za-z][_A-Za-z0-9]*/},{Type:6,Pattern:/^[+-]?(([0][x][a-fA-F0-9]+([uU][lL])?([lL][uU])?[uU]?[lL]?)|(([0-9]*[.][0-9]+([eE][+-]?[0-9]+)?[fFlLhH]?)|([0-9]+[.]([eE][+-]?[0-9]+)?[fFlLhH])|([0-9]+[.])|([0-9]+([uU][lL])?([lL][uU])?[uU]?[lL]?)))/},{Type:11,Pattern:/^[{]/},{Type:12,Pattern:/^[}]/},{Type:13,Pattern:/^[(]/},{Type:14,Pattern:/^[)]/},{Type:15,Pattern:/^[\[]/},{Type:16,Pattern:/^[\]]/},{Type:10,Pattern:/^[;]/},{Type:9,Pattern:/^[:]/},{Type:8,Pattern:/^[,]/},{Type:7,Pattern:/^[\.]/},{Type:0,Pattern:/^./}];static TranslateToGLSL(e){return HLSLDataTypeConversion.hasOwnProperty(e)?HLSLDataTypeConversion[e]:HLSLReservedWordConversion.hasOwnProperty(e)?HLSLReservedWordConversion[e]:e}static async LoadTextFromURL(e,t=!0){let r=await fetch(e),i=await r.text();if(!t)return i;let s={},a="#include";for(;;){let n=i.indexOf(a);if(-1==n)break;let l=-1,h=-1;if(-1==(l=i.indexOf('"',n+a.length)))throw Error("Error with #include; expected start quote");if(-1==(h=i.indexOf('"',l+1)))throw Error("Error with #include; expected end quote");let o=i.substring(l+1,h),u="";s.hasOwnProperty(o)||(s[o]=!0,u=await (r=await fetch(o)).text()),i=i.substring(0,n)+u+i.substring(h+1)}return i}constructor(e,t){if(t!=ShaderTypeVertex&&t!=ShaderTypePixel)throw Error("Invalid shader type specified");this.#aO=e.repeat(1),this.#a1=t,this.#ba(),this.#bb()}GetCBuffers(){return this.#a3.slice()}GetTextureSamplerCombinations(){return this.#a6.slice()}#ba(){this.#a$=[];let rV=1,rk=this.#aO.repeat(1);for(;rk.length>0;){let rX=!1;for(let r2=0;r2<this.Rules.length;r2++){let rH=RegExp(this.Rules[r2].Pattern,"g"),rW=rH.exec(rk);if(null!=rW){if(rX=!0,rV+=(rW[0].match(/\n/g)||[]).length,2!=this.Rules[r2].Type&&3!=this.Rules[r2].Type&&1!=this.Rules[r2].Type){let rz={Type:this.Rules[r2].Type,Text:rW[0],Line:rV};this.#a$.push(rz)}rk=rk.substring(rH.lastIndex);break}}if(!1==rX){alert("problem");break}}}#bb(){this.#a2=[],this.#a3=[],this.#a4=[],this.#a5=[],this.#a6=[],this.#a7=[],this.#a8=[],this.#a9=null;let r3=new TokenIterator(this.#a$),r6="";switch(this.#a1){case ShaderTypePixel:r6=PrefixPSCBuffer;break;case ShaderTypeVertex:r6=PrefixVSCBuffer}let rq=new ShaderElementCBuffer("$Global",r6+"global_cbuffer",-1);for(r3.MoveNext();r3.More();){let rY=r3.Current();switch(rY.Text){case"const":this.#a8.push(this.#bc(r3));break;case";":r3.MoveNext();break;case"struct":this.#a2.push(this.#bd(r3));break;case"cbuffer":this.#a3.push(this.#be(r3));break;case"SamplerState":case"SamplerComparisonState":this.#a5.push(this.#bf(r3));break;case"Texture1D":case"Texture1DArray":case"Texture2D":case"Texture2DArray":case"TextureCube":case"TextureCubeArray":case"Texture3D":this.#a4.push(this.#bg(r3));break;case"Texture2DMS":case"Texture2DMSArray":throw new ParseError(r3.Line,"Not currently handling multisampled textures");default:if(!this.#bh(rY.Text)||5!=r3.PeekNext().Type)throw new ParseError(rY,"Invalid token");if(!this.#bi(r3,rq))throw Error("Error parsing global variable or function")}}if(null==this.#a9)throw new ParseError(null,"'main': entry point not found");rq.Members.length>0&&this.#a3.push(rq),this.#bj(this.#a3,999),this.#bj(this.#a5,999),this.#bj(this.#a4,999)}#bk(r4,...r7){for(let r5 of r7)if(r4.Current().Type==r5)return r4.MoveNext(),!0;return!1}#bl(rj,...rZ){for(let rQ of rZ)if(5==rj.Current().Type&&rj.Current().Text==rQ)return rj.MoveNext(),!0;return!1}#bm(rK,...rJ){for(let r9 of rJ)if(4==rK.Current().Type&&rK.Current().Text==r9)return rK.MoveNext(),!0;return!1}#bn(ie){let it=ie.Current();return!!this.#bh(it.Text)&&(ie.MoveNext(),!0)}#bo(ir,ii){if(this.#bk(ir,ii))return!0;throw Error("Error parsing HLSL on line "+ir.Current().Line)}#bp(is,ia){if(this.#bm(is,ia))return!0;throw Error("Error parsing HLSL on line "+is.Current().Line)}#bq(il,ih){if(this.#bl(il,ih))return!0;throw Error("Error parsing HLSL on line "+il.Current().Line)}#br(io){let iu=io.Current();if(this.#bh(iu.Text))return io.MoveNext(),!0;throw Error("Error parsing HLSL on line "+io.Current().Line)}#bs(ic){for(let ip=0;ip<this.#a2.length;ip++)if(this.#a2[ip].Name==ic)return!0;return!1}#bt(iT){for(let iS=0;iS<this.#a4.length;iS++)if(this.#a4[iS].Name==iT)return!0;return!1}#bu(iD){for(let iE=0;iE<this.#a4.length;iE++)if(this.#a4[iE].Name==iD)return this.#a4[iE];return null}#bv(im){for(let id=0;id<this.#a5.length;id++)if(this.#a5[id].Name==im)return!0;return!1}#bw(ig){for(let i8=0;i8<this.#a5.length;i8++)if(this.#a5[i8].Name==ig)return this.#a5[i8];return null}#bh(ix){let iR=this.#bs(ix),i_=HLSLDataTypeConversion.hasOwnProperty(ix);return iR||i_}#bx(iI){return HLSLReservedWordConversion.hasOwnProperty(iI)}#bd(iA){let iC=null,iP=[];this.#bq(iA,"struct"),this.#bo(iA,5),iC=iA.PeekPrev().Text,this.#bo(iA,11);do{if(12==iA.Current().Type)break;iP.push(this.#by(iA,!1,!0,!0,!1))}while(this.#bk(iA,10));return this.#bo(iA,12),this.#bo(iA,10),new ShaderElementStruct(iC,iP)}#bz(i$,iw){if(!this.#bk(i$,9))return -1;this.#bq(i$,"register"),this.#bo(i$,13),this.#bo(i$,5);let iL=i$.PeekPrev().Text;if(!iL.startsWith(iw))throw new ParseError(i$.PeekPrev(),"Invalid register type");let iM=parseInt(iL.substring(1));if(isNaN(iM))throw new ParseError(i$.PeekPrev(),"Invalid register index");return this.#bo(i$,14),iM}#be(iF){let ib=null,iy=-1,i1=[];this.#bq(iF,"cbuffer"),this.#bo(iF,5),ib=iF.PeekPrev().Text,iy=this.#bz(iF,"b"),this.#bo(iF,11);do{if(12==iF.Current().Type)break;i1.push(this.#by(iF,!1,!1,!1,!1))}while(this.#bk(iF,10));this.#bo(iF,12);let iv="";switch(this.#a1){case ShaderTypePixel:iv=PrefixPSCBuffer;break;case ShaderTypeVertex:iv=PrefixVSCBuffer}let iN=HLSL.TranslateToGLSL(iv+ib);return new ShaderElementCBuffer(ib,iN,iy,i1)}#by(iB,iG,iO,iU,i0){let iV=[],ik=[],iX=null,i2=null,iH=null,iW=null,iz=null,i3=!1;do i3=!1,this.#bl(iB,"in")&&(ik.push("in"),i3=!0),this.#bl(iB,"inout")&&(ik.push("inout"),i3=!0),this.#bl(iB,"out")&&(ik.push("out"),i3=!0),this.#bl(iB,"uniform")&&(ik.push("uniform"),i3=!0),this.#bl(iB,"linear")&&(iV.push("linear"),i3=!0),this.#bl(iB,"centroid")&&(iV.push("centroid"),i3=!0),this.#bl(iB,"nointerpolation")&&(iV.push("nointerpolation"),i3=!0),this.#bl(iB,"noperspective")&&(iV.push("noperspective"),i3=!0),this.#bl(iB,"sample")&&(iV.push("sample"),i3=!0);while(i3);if(!iG&&ik.length>0)throw new ParseError(iB.PeekPrev(),"Input modifier not allowed here");if(ik.length>1)throw new ParseError(iB.PeekPrev(),"Multiple input modifiers found.");if(!iO&&iV.length>0)throw new ParseError(iB.PeekPrev(),"Interpolation modifier not allowed here");if(this.#br(iB),iX=iB.PeekPrev().Text,this.#bo(iB,5),i2=iB.PeekPrev().Text,this.#bk(iB,15)&&(iW=this.#bA(iB),this.#bo(iB,16)),this.#bk(iB,9)){if(!iU)throw new ParseError(iB.PeekPrev(),"Semantic not allowed here.");this.#bo(iB,5),iH=iB.PeekPrev().Text}if(this.#bm(iB,"=")){if(!i0)throw new ParseError(iB.PeekPrev(),"Initialization not allowed here.");iz=this.#bA(iB)}return new ShaderElementMemberVar(iX,i2,1==ik.length?ik[0]:null,iV,iW,iH,iz)}#bg(i6){let iq=null,iY=null,i4=-1;if(this.#bo(i6,5),iq=i6.PeekPrev().Text,this.#bo(i6,5),iY=i6.PeekPrev().Text,(i4=this.#bz(i6,"t"))>=0){for(let i7=0;i7<this.#a4.length;i7++)if(this.#a4[i7].RegisterIndex==i4)throw new ParseError(i6.PeekPrev(),"Duplicate texture register: t"+i4)}return this.#bo(i6,10),new ShaderElementTexture(iq,iY,i4)}#bf(i5){let ij=null,iZ=null,iQ=-1;if(this.#bo(i5,5),ij=i5.PeekPrev().Text,this.#bo(i5,5),iZ=i5.PeekPrev().Text,(iQ=this.#bz(i5,"s"))>=0){for(let iK=0;iK<this.#a5.length;iK++)if(this.#a5[iK].RegisterIndex==iQ)throw new ParseError(i5.PeekPrev(),"Duplicate sampler register: s"+iQ)}return this.#bo(i5,10),new ShaderElementSampler(ij,iZ,iQ)}#bi(iJ,i9){this.#bo(iJ,5);let se=iJ.PeekPrev().Text;this.#bo(iJ,5);let st=iJ.PeekPrev().Text;if(this.#bk(iJ,13)){let sr=[];do{if(14==iJ.Current().Type)break;sr.push(this.#by(iJ,!0,!0,!0,!0))}while(this.#bk(iJ,8));this.#bo(iJ,14);let si=null;this.#bk(iJ,9)&&(this.#bo(iJ,5),si=iJ.PeekPrev().Text),this.#bo(iJ,11);let ss=this.#bB(iJ);this.#bo(iJ,12);let sa=new ShaderElementFunction(se,st,si,sr,ss,null);if("main"==st){if(null!=this.#a9)throw new ParseError(iJ.PeekPrev(),"Multiple main functions detected");this.#a9=sa}else this.#a7.push(sa);return!0}return!!this.#bk(iJ,10)&&(i9.Members.push(new ShaderElementMemberVar(se,st)),!0)}#bB(sn){let sl=[];for(;12!=sn.Current().Type;)sl.push(this.#bC(sn));return sl}#bC(sh){if(this.#bk(sh,11))return this.#bD(sh);if(this.#bl(sh,"do"))return this.#bE(sh);if(this.#bl(sh,"for"))return this.#bF(sh);if(this.#bl(sh,"if"))return this.#bG(sh);if(this.#bl(sh,"return"))return this.#bH(sh);if(this.#bl(sh,"switch"))return this.#bI(sh);if(this.#bh(sh.Current().Text)||"const"==sh.Current().Text)return this.#bc(sh);if(this.#bl(sh,"while"))return this.#bJ(sh);if(this.#bl(sh,"break")||this.#bl(sh,"continue")||this.#bl(sh,"discard")){let so=sh.PeekPrev();return this.#bo(sh,10),new StatementJump(so)}return this.#bK(sh)}#bD(su){let sc=[];for(;12!=su.Current().Type;)sc.push(this.#bC(su));return this.#bo(su,12),new StatementBlock(sc)}#bE(sp){let sf=this.#bC(sp);this.#bq(sp,"while"),this.#bo(sp,13);let sT=this.#bA(sp);return this.#bo(sp,14),this.#bo(sp,10),new StatementDoWhile(sf,sT)}#bF(sS){let sD=null,sE=null,sm=null,sd=null;return this.#bo(sS,13),this.#bh(sS.Current().Text)?sD=this.#bc(sS):(sD=this.#bK(sS),this.#bo(sS,10)),10!=sS.Current().Type&&(sE=this.#bA(sS)),this.#bo(sS,10),14!=sS.Current().Type&&(sm=this.#bA(sS)),this.#bo(sS,14),sd=this.#bC(sS),new StatementFor(sD,sE,sm,sd)}#bG(sg){this.#bo(sg,13);let s8=this.#bA(sg);this.#bo(sg,14);let sx=this.#bC(sg),sR=null;return this.#bl(sg,"else")&&(sR=this.#bC(sg)),new StatementIf(s8,sx,sR)}#bH(s_){if(this.#bk(s_,10))return new StatementReturn(null);let sI=this.#bA(s_);return this.#bo(s_,10),new StatementReturn(sI)}#bI(sA){let sC=null,sP=[];this.#bo(sA,13),sC=this.#bA(sA),this.#bo(sA,14),this.#bo(sA,11);let s$=!1;for(;12!=sA.Current().Type;){let sw=null;if(this.#bl(sA,"case"))sw=this.#bA(sA);else if(this.#bl(sA,"default")){if(s$)throw new ParseError(sA.PeekPrev(),"More than one 'default' found in switch statement");s$=!0}else throw new ParseError(sA.Current(),"Invalid token in switch statement: "+sA.Current().Text);this.#bo(sA,9);let sL=[];for(;"case"!=sA.Current().Text&&"default"!=sA.Current().Text&&12!=sA.Current().Type;)sL.push(this.#bC(sA));null==sw?sP.push(new StatementDefault(sL)):sP.push(new StatementCase(sw,sL))}return this.#bo(sA,12),new StatementSwitch(sC,sP)}#bc(sM){let sF=this.#bl(sM,"const");this.#bo(sM,5);let sb=sM.PeekPrev(),sy=[];do{this.#bo(sM,5);let s1=sM.PeekPrev(),sv=null;this.#bk(sM,15)&&(sv=this.#bA(sM),this.#bo(sM,16));let sN=null;this.#bm(sM,"=")&&(sN=this.#bA(sM)),sy.push(new VarDec(sF,sb,s1,sv,sN))}while(this.#bk(sM,8));if(0==sy.length)throw new ParseError(sM.PeekPrev(),"Variable name expected");return this.#bo(sM,10),new StatementVar(sF,sb,sy)}#bJ(sB){this.#bo(sB,13);let sG=this.#bA(sB);this.#bo(sB,14);let sO=this.#bC(sB);return new StatementWhile(sG,sO)}#bK(sU){let s0=this.#bA(sU);return this.#bo(sU,10),new StatementExpression(s0)}#bA(sV){return this.#bL(sV)}#bL(sk){let sX=this.#bM(sk);if(this.#bm(sk,"=","+=","-=","*=","/=","%=","<<=",">>=","&=","^=","|=")){let s2=sk.PeekPrev().Text,sH=sX instanceof ExpVariable;if(!sH&&sX instanceof ExpMember&&(sH=sX.RightmostChildIsVariable()),!sH)throw new ParseError(sk.PeekPrev(),"Expected variable for assignment.");return new ExpAssignment(sX,s2,this.#bL(sk))}return sX}#bM(sW){let sz=this.#bN(sW);if(this.#bm(sW,"?")){let s3=this.#bA(sW);if(this.#bo(sW,9)){let s6=this.#bA(sW);return new ExpTernary(sz,s3,s6)}throw new ParseError(sW.PeekPrev(),"Expected ':' ternary operator")}return sz}#bN(sq){let sY=this.#bO(sq);for(;this.#bm(sq,"||");)sY=new ExpLogical(sY,sq.PeekPrev(),this.#bO(sq));return sY}#bO(s4){let s7=this.#bP(s4);for(;this.#bm(s4,"&&");)s7=new ExpLogical(s7,s4.PeekPrev(),this.#bP(s4));return s7}#bP(s5){let sj=this.#bQ(s5);for(;this.#bm(s5,"|");)sj=new ExpBitwise(sj,s5.PeekPrev(),this.#bQ(s5));return sj}#bQ(sZ){let sQ=this.#bR(sZ);for(;this.#bm(sZ,"^");)sQ=new ExpBitwise(sQ,sZ.PeekPrev(),this.#bR(sZ));return sQ}#bR(sK){let sJ=this.#bS(sK);for(;this.#bm(sK,"&");)sJ=new ExpBitwise(sJ,sK.PeekPrev(),this.#bS(sK));return sJ}#bS(s9){let ae=this.#bT(s9);for(;this.#bm(s9,"==","!=");)ae=new ExpBinary(ae,s9.PeekPrev(),this.#bT(s9));return ae}#bT(at){let ar=this.#bU(at);for(;this.#bm(at,"<","<=",">",">=");)ar=new ExpBinary(ar,at.PeekPrev(),this.#bU(at));return ar}#bU(ai){let as=this.#bV(ai);for(;this.#bm(ai,"<<",">>");)as=new ExpBinary(as,ai.PeekPrev(),this.#bV(ai));return as}#bV(aa){let an=this.#bW(aa);for(;this.#bm(aa,"+","-");)an=new ExpBinary(an,aa.PeekPrev(),this.#bW(aa));return an}#bW(al){let ah=this.#bX(al);for(;this.#bm(al,"*","/","%");)ah=new ExpBinary(ah,al.PeekPrev(),this.#bX(al));return ah}#bX(ao){if(this.#bm(ao,"+","-","!","~","++","--"))return new ExpUnary(ao.PeekPrev(),this.#bX(ao));if(13==ao.Current().Type&&this.#bh(ao.PeekNext().Text)&&14==ao.PeekNextNext().Type){this.#bo(ao,13),this.#br(ao);let au=ao.PeekPrev();return this.#bo(ao,14),new ExpCast(au,this.#bX(ao))}return this.#bY(ao)}#bY(ac){let ap=this.#bZ(ac);for(;;){if(!(ap instanceof ExpFunctionCall)&&this.#bm(ac,"++","--"))return new ExpPostfix(ap,ac.PeekPrev());if(!(ap instanceof ExpFunctionCall)&&this.#bk(ac,13)){let af=[];if(14!=ac.Current().Type)do af.push(this.#bA(ac));while(this.#bk(ac,8));this.#bo(ac,14),ap=new ExpFunctionCall(ap,af),this.#b$(ap)}else if(this.#bk(ac,15))ap=new ExpArray(ap,this.#bA(ac)),this.#bo(ac,16);else if(this.#bk(ac,7))this.#bo(ac,5),ap=new ExpMember(ap,new ExpVariable(ac.PeekPrev()));else break}return ap}#b$(aT){if(!(aT instanceof ExpFunctionCall)||!(aT.FuncExp instanceof ExpMember)||!(aT.FuncExp.ExpLeft instanceof ExpVariable)||!(aT.FuncExp.ExpRight instanceof ExpVariable))return;let aS=aT.FuncExp.ExpLeft.VarToken.Text;if(!this.#bt(aS))return;let aD=aT.FuncExp.ExpRight.VarToken.Text;switch(aD){case"Sample":if(this.#a1!=ShaderTypePixel)throw Error("Sample() only available in pixel shaders");break;case"SampleLevel":break;default:throw Error("Invalid (or not implemented) texture member function found.")}if(aT.Parameters.length<=1)throw Error("Invalid number of parameters for texture sampling function");if(!(aT.Parameters[0]instanceof ExpVariable))throw Error("Sampler expected");let aE=aT.Parameters[0].VarToken.Text;if(!this.#bv(aE))throw Error("Sampler expected");let am=null;for(let ad=0;ad<this.#a6.length;ad++)if(this.#a6[ad].TextureName==aS&&this.#a6[ad].SamplerName==aE){am=this.#a6[ad];break}null==am&&(am=new ShaderElementCombinedTextureAndSampler(aS,aE,this.#bu(aS),this.#bw(aE)),this.#a6.push(am)),aT.IsTextureSample=!0,aT.CombinedTextureAndSampler=am}#bZ(ag){if(ag.Current(),this.#bl(ag,"true","false")||this.#bk(ag,6))return new ExpLiteral(ag.PeekPrev());if(this.#bk(ag,5))return new ExpVariable(ag.PeekPrev());if(this.#bk(ag,13)){let a8=this.#bA(ag);return this.#bo(ag,14),new ExpGroup(a8)}throw new ParseError(ag.Current(),"Unexpected token '"+ag.Current().Text+"'")}#b_(ax,aR){for(let a_=0;a_<ax.length;a_++)if(ax[a_].RegisterIndex==aR)return!0;return!1}#bj(aI,aA){let aC=0;for(let aP=0;aP<aI.length;aP++)if(-1==aI[aP].RegisterIndex){for(;this.#b_(aI,aC);)aC++;if(aC>=aA)throw Error("Too many registers in use for shader");aI[aP].RegisterIndex=aC,aC++}}GetGLSL(){let e="";switch(this.#a1){case ShaderTypeVertex:e=this.#b0();break;case ShaderTypePixel:e=this.#b1();break;default:throw Error("Invalid shader type")}return e}#b2(a$){for(let aw=0;aw<this.#a2.length;aw++)if(this.#a2[aw].Name==a$)return this.#a2[aw];return null}#b3(){let aL="";return aL+="mat4 mul(mat4 m1, mat4 m2){ return m1 * m2; }\n",aL+="vec4 mul(vec4 v, mat4 m){ return v * m; }\n",aL+="vec4 mul(mat4 m, vec4 v){ return m * v; }\n\n",aL+="mat3 mul(mat3 m1, mat3 m2){ return m1 * m2; }\n",aL+="vec3 mul(vec3 v, mat3 m){ return v * m; }\n",aL+="vec3 mul(mat3 m, vec3 v){ return m * v; }\n\n",aL+="mat2 mul(mat2 m1, mat2 m2){ return m1 * m2; }\n",aL+="vec2 mul(vec2 v, mat2 m){ return v * m; }\n",aL+="vec2 mul(mat2 m, vec2 v){ return m * v; }\n\n",aL+="float saturate(float x) { return clamp(x, 0.0, 1.0); }\n",aL+="vec2 saturate(vec2 x) { return clamp(x, 0.0, 1.0); }\n",aL+="vec3 saturate(vec3 x) { return clamp(x, 0.0, 1.0); }\n",aL+="int saturate(int x) { return clamp(x, 0, 1); }\n\n",aL+="float lerp(float a, float b, float t) { return mix(a, b, t); }\n",aL+="vec2 lerp(vec2 a, vec2 b, float t) { return mix(a, b, t); }\n",aL+="vec2 lerp(vec2 a, vec2 b, vec2 t) { return mix(a, b, t); }\n",aL+="vec3 lerp(vec3 a, vec3 b, float t) { return mix(a, b, t); }\n",aL+="vec3 lerp(vec3 a, vec3 b, vec3 t) { return mix(a, b, t); }\n\n",aL+="void sincos(float a, out float s, out float c) { s = sin(a); c = cos(a); }\n\n",aL+="float atan2(float a, float b) { return atan(b, a); }\n\n",aL+="float pow_hlsl(float a, float b) { return pow(a, b); }\n",aL+="vec2 pow_hlsl(vec2 v, float f) { return pow(v, vec2(f)); }\n",aL+="vec3 pow_hlsl(vec3 v, float f) { return pow(v, vec3(f)); }\n",aL+="vec4 pow_hlsl(vec4 v, float f) { return pow(v, vec4(f)); }\n",aL+="\n"}#b4(){let aM="";return aM+="mat2 float2x2_tr(mat2 m) { return mat2(m); }\n",aM+="mat2 float2x2_tr(mat3 m) { return mat2(m); }\n",aM+="mat2 float2x2_tr(mat4 m) { return mat2(m); }\n",aM+="mat3 float3x3_tr(mat2 m) { return mat3(m); }\n",aM+="mat3 float3x3_tr(mat3 m) { return mat3(m); }\n",aM+="mat3 float3x3_tr(mat4 m) { return mat3(m); }\n",aM+="mat4 float4x4_tr(mat2 m) { return mat4(m); }\n",aM+="mat4 float4x4_tr(mat3 m) { return mat4(m); }\n",aM+="mat4 float4x4_tr(mat4 m) { return mat4(m); }\n",aM+="mat2 float2x2_tr(vec2 a, vec2 b) { return transpose(mat2(a,b)); }\n",aM+="mat3 float3x3_tr(vec3 a, vec3 b, vec3 c) { return transpose(mat3(a,b,c)); }\n",aM+="mat4 float4x4_tr(vec4 a, vec4 b, vec4 c, vec4 d) { return transpose(mat4(a,b,c,d)); }\n\n",aM+="\n"}#b0(){let aF="#version 300 es\n\n",ab=this.#b5();return aF+=this.#b6(ab),aF+=this.#b7(),aF+=this.#b8(),aF+=this.#b9(),aF+=this.#ca(),aF+=this.#b3(),aF+=this.#b4(),aF+=this.#cb(),aF+=this.#cc(),aF+=this.#cd(ab)}#b5(){if(null==this.#a9)throw Error("Missing main() function in shader");let ay=[];for(let a1=0;a1<this.#a9.Parameters.length;a1++){let av=this.#a9.Parameters[a1];if(this.#bs(av.DataType)){let aN=this.#b2(av.DataType);if(null==aN)throw Error("Invalid data type in vertex shader input");for(let aB=0;aB<aN.Members.length;aB++)ay.push(aN.Members[aB])}else ay.push(av)}return ay}#b6(aG){let aO="";for(let aU=0;aU<aG.length;aU++)aO+="in "+HLSL.TranslateToGLSL(aG[aU].DataType)+" "+PrefixAttribute+aG[aU].Name+";\n";return aO+"\n"}#b7(){if(!this.#bs(this.#a9.ReturnType))return"";let a0=this.#b2(this.#a9.ReturnType),aV="";for(let ak=0;ak<a0.Members.length;ak++){let aX=a0.Members[ak];(null==aX.Semantic||"SV_POSITION"!=aX.Semantic.toUpperCase())&&(aV+="out "+HLSL.TranslateToGLSL(aX.DataType),aV+=" "+PrefixVarying+aX.Semantic+";\n")}return aV+"\n"}#b9(){let a2="";for(let aH=0;aH<this.#a2.length;aH++){let aW=this.#a2[aH];a2+="struct "+HLSL.TranslateToGLSL(aW.Name)+"\n",a2+="{\n";for(let az=0;az<aW.Members.length;az++){let a3=aW.Members[az];a2+="	"+HLSL.TranslateToGLSL(a3.DataType),a2+=" "+HLSL.TranslateToGLSL(a3.Name),null!=a3.ArraySize&&(a2+="["+a3.ArraySize+"]"),a2+=";\n"}a2+="};\n\n"}return a2}#ca(){let a6="",aq="";switch(this.#a1){case ShaderTypePixel:aq=PrefixPSCBuffer;break;case ShaderTypeVertex:aq=PrefixVSCBuffer}for(let aY=0;aY<this.#a3.length;aY++){let a4=this.#a3[aY];a6+="layout(std140) uniform "+HLSL.TranslateToGLSL(aq+a4.Name)+"\n",a6+="{\n";for(let a7=0;a7<a4.Members.length;a7++){let a5=a4.Members[a7];a6+="	"+HLSL.TranslateToGLSL(a5.DataType),a6+=" "+HLSL.TranslateToGLSL(a5.Name),null!=a5.ArrayExpression&&(a6+="["+a5.ArrayExpression.ToString(1,"")+"]"),a6+=";\n"}a6+="};\n\n"}return a6}#cb(){if(0==this.#a6.length)return"";let aj="";for(let aZ=0;aZ<this.#a6.length;aZ++){let aQ=this.#a6[aZ],aK;switch(aQ.Texture.Type){case"Texture1D":case"Texture2D":aK="sampler2D";break;case"Texture3D":aK="sampler3D";break;case"TextureCube":aK="samplerCube";break;default:throw Error("Texture type '"+aQ.Texture.Type+"' not implemented yet!")}aj+="uniform "+aK+" "+aQ.CombinedName+";\n"}return aj+"\n"}#b8(){let aJ="";for(let a9=0;a9<this.#a8.length;a9++)aJ+=this.#a8[a9].ToString(1,"")+"\n";return aJ+"\n"}#cc(){let ne="";for(let nt=0;nt<this.#a7.length;nt++)ne+=this.#a7[nt].ToString(1)+"\n\n";return ne+(this.#a9.ToString(1,"hlsl_")+"\n\n")}#cd(nr){let ni="void main()\n";ni+="{\n";for(let ns=0;ns<nr.length;ns++)null!=nr[ns].Semantic&&"SV_VERTEXID"==nr[ns].Semantic.toUpperCase()?(ni+="	uint "+nr[ns].Name+" = ",ni+="uint(gl_VertexID);\n"):(ni+="	"+HLSL.TranslateToGLSL(nr[ns].DataType)+" "+nr[ns].Name+" = ",ni+=PrefixAttribute+nr[ns].Name+";\n");for(let na=0;na<this.#a9.Parameters.length;na++){let nn=this.#a9.Parameters[na];if(this.#bs(nn.DataType)){let nl=HLSL.TranslateToGLSL(nn.Name);ni+="\n	"+nn.DataType,ni+=" "+nl+";\n";let nh=this.#b2(nn.DataType);for(let no=0;no<nh.Members.length;no++){let nu=nh.Members[no];ni+="	"+nl+"."+HLSL.TranslateToGLSL(nu.Name)+" = ",ni+=HLSL.TranslateToGLSL(nu.Name)+";\n"}}}ni+="\n	"+HLSL.TranslateToGLSL(this.#a9.ReturnType)+" "+PrefixVSOutput+" = hlsl_main(";for(let nc=0;nc<this.#a9.Parameters.length;nc++)ni+=HLSL.TranslateToGLSL(this.#a9.Parameters[nc].Name),nc<this.#a9.Parameters.length-1&&(ni+=", ");if(ni+=");\n\n",null!=this.#a9.Semantic&&"SV_POSITION"==this.#a9.Semantic.toUpperCase())ni+="	gl_Position = "+PrefixVSOutput+";\n";else{let np=null,nf=this.#b2(this.#a9.ReturnType);for(let nT=0;nT<nf.Members.length;nT++){let nS=nf.Members[nT];null!=nS.Semantic&&"SV_POSITION"==nS.Semantic.toUpperCase()?np=nS.Name:ni+="	"+PrefixVarying+nS.Semantic+" = "+PrefixVSOutput+"."+nS.Name+";\n"}ni+="	gl_Position = "+PrefixVSOutput+"."+np+";\n"}return ni+="	gl_PointSize = 1.0;\n",ni+="}\n"}#ce(){if(null==this.#a9)throw Error("Missing main() function in shader");let nD=[];for(let nE=0;nE<this.#a9.Parameters.length;nE++){let nm=this.#a9.Parameters[nE];if(this.#bs(nm.DataType)){let nd=this.#b2(nm.DataType);if(null==nd)throw Error("Invalid data type in pixel shader input");for(let ng=0;ng<nd.Members.length;ng++)nD.push(nd.Members[ng])}else nD.push(nm)}return nD}#cf(n8){if(0==n8.length)return"";let nx="",nR=!1;for(let n_=0;n_<this.#a9.Parameters.length;n_++){let nI=this.#a9.Parameters[n_];if(this.#bs(nI.DataType)){let nA=this.#b2(nI.DataType);for(let nC=0;nC<nA.Members.length;nC++){let nP=nA.Members[nC];if(null!=nP.Semantic&&"SV_POSITION"==nP.Semantic.toUpperCase()){nR=!0;continue}nx+="in "+HLSL.TranslateToGLSL(nP.DataType),nx+=" "+PrefixVarying+nP.Semantic+";\n"}}else null!=nI.Semantic&&"SV_POSITION"==nI.Semantic.toUpperCase()?nR=!0:(nx+="in "+HLSL.TranslateToGLSL(nI.DataType),nx+=" "+PrefixVarying+nI.Semantic+";\n")}return nx+"\n"}#cg(n$){let nw="void main()\n";nw+="{\n";for(let nL=0;nL<n$.length;nL++)nw+="	"+HLSL.TranslateToGLSL(n$[nL].DataType)+" "+n$[nL].Name+" = ","SV_POSITION"==n$[nL].Semantic.toUpperCase()?nw+="gl_FragCoord;\n":nw+=PrefixVarying+n$[nL].Semantic+";\n";for(let nM=0;nM<this.#a9.Parameters.length;nM++){let nF=this.#a9.Parameters[nM];if(this.#bs(nF.DataType)){let nb=HLSL.TranslateToGLSL(nF.Name);nw+="\n	"+nF.DataType,nw+=" "+nb+";\n";let ny=this.#b2(nF.DataType);for(let n1=0;n1<ny.Members.length;n1++){let nv=ny.Members[n1];nw+="	"+nb+"."+HLSL.TranslateToGLSL(nv.Name)+" = ",nw+=HLSL.TranslateToGLSL(nv.Name)+";\n"}}}nw+="\n	"+HLSL.TranslateToGLSL(this.#a9.ReturnType)+" "+PrefixPSOutput+" = hlsl_main(";for(let nN=0;nN<this.#a9.Parameters.length;nN++)nw+=HLSL.TranslateToGLSL(this.#a9.Parameters[nN].Name),nN<this.#a9.Parameters.length-1&&(nw+=", ");if(nw+=");\n\n",null!=this.#a9.Semantic&&("SV_TARGET"==this.#a9.Semantic.toUpperCase()||"SV_TARGET0"==this.#a9.Semantic.toUpperCase()))nw+="	"+PSOutputVariable+" = "+PrefixPSOutput+";\n";else{let nB=null,nG=this.#b2(this.#a9.ReturnType);for(let nO=0;nO<nG.Members.length;nO++){let nU=nG.Members[nO];if(null!=nU.Semantic&&("SV_TARGET"==nU.toUpperCase()||"SV_TARGET0"==nU.toUpperCase()))nB=nU.Name;else throw Error("Error converting pixel shader: Only 1 render target currently supported")}nw+="	"+PSOutputVariable+" = "+PrefixPSOutput+"."+nB+";\n"}return nw+"}\n"}#b1(){let n0="#version 300 es\n\n",nV=this.#ce();return n0+="precision mediump float;\n\n",n0+="precision mediump sampler3D;\n\n",n0+="out vec4 "+PSOutputVariable+";\n\n",n0+=this.#cf(nV),n0+=this.#b8(),n0+=this.#b9(),n0+=this.#ca(),n0+=this.#b3(),n0+=this.#b4(),n0+=this.#cb(),n0+=this.#cc(),n0+=this.#cg(nV)}}class ShaderElement{}class ShaderElementCBuffer extends ShaderElement{Name;NameGL;RegisterIndex;Members;constructor(e,t,r,i=[]){super(),this.Name=e,this.NameGL=t,this.RegisterIndex=r,this.Members=i}}class ShaderElementFunction extends ShaderElement{ReturnType;Name;Semantic;Parameters;Statements;constructor(e,t,r,i,s){super(),this.ReturnType=e,this.Name=t,this.Semantic=r,this.Parameters=i,this.Statements=s}ToString(e,t=""){let r="";switch(e){default:case 0:throw Error("IMPLEMENT ME");case 1:r+=HLSL.TranslateToGLSL(this.ReturnType)+" "+HLSL.TranslateToGLSL(t+this.Name)+"(";for(let i=0;i<this.Parameters.length;i++)r+=this.Parameters[i].ToString(e),i<this.Parameters.length-1&&(r+=", ");r+=")\n",r+="{\n";for(let s=0;s<this.Statements.length;s++)r+=this.Statements[s].ToString(e,"	")+"\n";r+="}"}return r}}class ShaderElementSampler extends ShaderElement{Type;Name;RegisterIndex;constructor(e,t,r){super(),this.Type=e,this.Name=t,this.RegisterIndex=r}}class ShaderElementStruct extends ShaderElement{Name;Members;constructor(e,t){super(),this.Name=e,this.Members=t}ToString(e){let t="struct "+this.Name+"\n";t+="{\n";for(let r=0;r<this.Members.length;r++)t+=this.Members[r].ToString(e,"	");return t+"}\n"}}class ShaderElementTexture extends ShaderElement{Type;Name;RegisterIndex;constructor(e,t,r){super(),this.Type=e,this.Name=t,this.RegisterIndex=r}}class ShaderElementCombinedTextureAndSampler extends ShaderElement{TextureName;SamplerName;CombinedName;Texture;Sampler;constructor(e,t,r,i){super(),this.TextureName=e,this.SamplerName=t,this.CombinedName="combined_"+e+"_"+t,this.Texture=r,this.Sampler=i}}class ShaderElementMemberVar{DataType;Name;InputModifier;InterpModifiers;ArrayExpression;Semantic;InitializerExp;constructor(e,t,r=null,i=[],s=null,a=null,n=null){this.DataType=e,this.Name=t,this.InputModifier=r,this.InterpModifiers=i,this.ArrayExpression=s,this.Semantic=a,this.InitializerExp=n}ToString(e,t=""){let r=t;switch(e){default:case 0:for(let i=0;i<this.InterpModifiers.length;i++)r+=this.InterpModifiers[i]+" ";null!=this.InputModifier&&(r+=this.InputModifier+" "),r+=this.DataType+" ",r+=this.Name,null!=this.ArrayExpression&&(r+=" ["+this.ArrayExpression.ToString(e)+"]"),null!=this.Semantic&&(r+=" : "+this.Semantic),null!=this.InitializerExp&&(r+=" "+this.InitializerExp.ToString(e));break;case 1:null!=this.InputModifier&&(r+=this.InputModifier+" "),r+=HLSL.TranslateToGLSL(this.DataType)+" ",r+=HLSL.TranslateToGLSL(this.Name),null!=this.ArrayExpression&&(r+=" ["+this.ArrayExpression.ToString(e)+"]"),null!=this.InitializerExp&&(r+=" "+this.InitializerExp.ToString(e))}return r}}class Statement{}class StatementBlock extends Statement{Statements;constructor(e){super(),this.Statements=e}ToString(e,t=""){let r=t+"{\n";for(let i=0;i<this.Statements.length;i++)r+=this.Statements[i].ToString(e,t+"	")+"\n";return r+(t+"}")}}class StatementCase extends Statement{CaseValueExpression;Statements;constructor(e,t){super(),this.CaseValueExpression=e,this.Statements=t}ToString(e,t=""){let r=t+"case "+this.CaseValueExpression.ToString(e)+":\n";for(let i=0;i<this.Statements.length;i++)r+=this.Statements[i].ToString(e,t+"	")+"\n";return r}}class StatementDefault extends Statement{Statements;constructor(e){super(),this.Statements=e}ToString(e,t=""){let r=t+"default:\n";for(let i=0;i<this.Statements.length;i++)r+=this.Statements[i].ToString(e,t+"	")+"\n";return r}}class StatementDoWhile extends Statement{Body;Condition;constructor(e,t){super(),this.Body=e,this.Condition=t}ToString(e,t=""){let r=t+"do\n";return r+=this.Body.ToString(e,t+"	"),r+=t+"while("+this.Condition.ToString(e)+");\n"}}class StatementExpression extends Statement{Exp;constructor(e){super(),this.Exp=e}ToString(e,t=""){return t+this.Exp.ToString(e)+";"}}class StatementFor extends Statement{InitStatement;ConditionExpression;IterateExpression;BodyStatement;constructor(e,t,r,i){super(),this.InitStatement=e,this.ConditionExpression=t,this.IterateExpression=r,this.BodyStatement=i}ToString(e,t=""){let r=t+"for(";return r+=this.InitStatement.ToString(e,"")+" ",r+=this.ConditionExpression.ToString(e)+"; ",r+=this.IterateExpression.ToString(e)+")\n",r+=this.BodyStatement.ToString(e,t+"	")}}class StatementIf extends Statement{Condition;If;Else;constructor(e,t,r){super(),this.Condition=e,this.If=t,this.Else=r}ToString(e,t=""){let r=t+"if("+this.Condition.ToString(e)+")\n";return r+=this.If.ToString(e,t+"	")+"\n",null!=this.Else&&(r+=t+"else\n",r+=this.Else.ToString(e,t+"	")+"\n"),r}}class StatementJump extends Statement{JumpToken;constructor(e){super(),this.JumpToken=e}ToString(e,t=""){return t+this.JumpToken.Text+";"}}class StatementReturn extends Statement{Expression;constructor(e){super(),this.Expression=e}ToString(e,t=""){return t+"return "+this.Expression.ToString(e)+";"}}class StatementSwitch extends Statement{SelectorExpression;Cases;constructor(e,t){super(),this.SelectorExpression=e,this.Cases=t}ToString(e,t=""){let r=t+"switch("+this.SelectorExpression.ToString(e)+")\n";r+=t+"{\n";for(let i=0;i<this.Cases.length;i++)r+=this.Cases[i].ToString(e,t+"	");return r+(t+"}")}}class StatementWhile extends Statement{Condition;Body;constructor(e,t){super(),this.Condition=e,this.Body=t}ToString(e,t=""){let r=t+"while("+this.Condition.ToString(e)+")\n";return r+this.Body.ToString(e,t+"	")}}class StatementVar extends Statement{IsConst;DataTypeToken;VarDecs;constructor(e,t,r){super(),this.IsConst=e,this.DataTypeToken=t,this.VarDecs=r}ToString(e,t=""){let r=t;switch(this.IsConst&&(r+="const "),e){default:case 0:r+=this.DataTypeToken.Text+" ";break;case 1:r+=HLSL.TranslateToGLSL(this.DataTypeToken.Text)+" "}for(let i=0;i<this.VarDecs.length;i++)i>0&&(r+=", "),r+=this.VarDecs[i].ToString(e);return r+";"}}class VarDec extends Statement{IsConst;DataTypeToken;NameToken;ArrayExpression;DefinitionExpression;constructor(e,t,r,i,s){super(),this.IsConst=e,this.DataTypeToken=t,this.NameToken=r,this.ArrayExpression=i,this.DefinitionExpression=s}ToString(e){let t="";switch(e){default:case 0:t+=this.NameToken.Text;break;case 1:t+=HLSL.TranslateToGLSL(this.NameToken.Text)}return null!=this.ArrayExpression&&(t+="["+this.ArrayExpression.ToString(e)+"]"),null!=this.DefinitionExpression&&(t+=" = "+this.DefinitionExpression.ToString(e)),t}}class Expression{}class ExpArray extends Expression{ExpArray;ExpIndex;constructor(e,t){super(),this.ExpArray=e,this.ExpIndex=t}ToString(e){return this.ExpArray.ToString(e)+"["+this.ExpIndex.ToString(e)+"]"}}class ExpAssignment extends Expression{VarExp;AssignOperator;AssignExp;constructor(e,t,r){super(),this.VarExp=e,this.AssignOperator=t,this.AssignExp=r}ToString(e){return this.VarExp.ToString(e)+" "+this.AssignOperator+" "+this.AssignExp.ToString(e)}}class ExpBinary extends Expression{ExpLeft;OperatorToken;ExpRight;constructor(e,t,r){super(),this.ExpLeft=e,this.OperatorToken=t,this.ExpRight=r}ToString(e){return this.ExpLeft.ToString(e)+" "+this.OperatorToken.Text+" "+this.ExpRight.ToString(e)}}class ExpBitwise extends Expression{ExpLeft;OperatorToken;ExpRight;constructor(e,t,r){super(),this.ExpLeft=e,this.OperatorToken=t,this.ExpRight=r}ToString(e){return this.ExpLeft.ToString(e)+" "+this.OperatorToken.Text+" "+this.ExpRight.ToString(e)}}class ExpCast extends Expression{TypeToken;Exp;constructor(e,t){super(),this.TypeToken=e,this.Exp=t}ToString(e){switch(e){default:case 0:return"("+this.TypeToken.Text+")"+this.Exp.ToString(e);case 1:return HLSL.TranslateToGLSL(this.TypeToken.Text)+"("+this.Exp.ToString(e)+")"}}}class ExpFunctionCall extends Expression{FuncExp;Parameters;IsTextureSample;CombinedTextureAndSampler;constructor(e,t){super(),this.FuncExp=e,this.Parameters=t,this.IsTextureSample=!1,this.CombinedTextureAndSampler=null}ToString(e){if(1==e&&this.IsTextureSample){let t=this.FuncExp.ExpRight.VarToken.Text;if(!HLSLTextureSampleConversion.hasOwnProperty(t))throw Error("Sample function type not yet implemented!");let r=HLSLTextureSampleConversion[t]+"("+this.CombinedTextureAndSampler.CombinedName+", ",i=this.Parameters[1].ToString(e);switch(this.CombinedTextureAndSampler.Texture.Type){case"Texture1D":i="vec2("+i+", 0.5)";break;case"Texture2D":i="vec2(0.0, 1.0) + vec2(1.0, -1.0) * ("+i+")";break;case"Texture3D":i="vec3(0.0, 1.0, 0.0) + vec3(1.0, -1.0, 1.0) * ("+i+")";break;case"TextureCube":i="vec3(1.0, -1.0, 1.0) * ("+i+")";break;default:throw Error("Invalid texture type or not yet implemented")}r+=i;for(let s=2;s<this.Parameters.length;s++)r+=", "+this.Parameters[s].ToString(e);return r+")"}{let a=this.FuncExp.ToString(e);if(1==e&&this.FuncExp instanceof ExpVariable){let n=this.FuncExp.VarToken.Text;HLSLMatrixConstructorConversion.hasOwnProperty(n)&&(a=HLSLMatrixConstructorConversion[n])}a+="(";for(let l=0;l<this.Parameters.length;l++)l>0&&(a+=", "),a+=this.Parameters[l].ToString(e);return a+")"}}}class ExpGroup extends Expression{Exp;constructor(e){super(),this.Exp=e}ToString(e){return"("+this.Exp.ToString(e)+")"}}class ExpLiteral extends Expression{LiteralToken;constructor(e){super(),this.LiteralToken=e}ToString(e){return this.LiteralToken.Text}}class ExpLogical extends Expression{ExpLeft;OperatorToken;ExpRight;constructor(e,t,r){super(),this.ExpLeft=e,this.OperatorToken=t,this.ExpRight=r}ToString(e){return this.ExpLeft.ToString(e)+" "+this.OperatorToken.Text+" "+this.ExpRight.ToString(e)}}class ExpMember extends Expression{ExpLeft;ExpRight;constructor(e,t){super(),this.ExpLeft=e,this.ExpRight=t}RightmostChildIsVariable(){let e=this.ExpRight;for(;e instanceof ExpMember;)e=e.ExpRight;return e instanceof ExpVariable}ToString(e){switch(e){default:case 0:return this.ExpLeft.ToString(e)+"."+this.ExpRight.ToString(e);case 1:let t=this.ExpLeft.ToString(e),r=this.ExpRight.ToString(e);if(HLSLMatrixElementConversion.hasOwnProperty(r))return t+HLSLMatrixElementConversion[r];return t+"."+r}}}class ExpPostfix extends Expression{ExpLeft;OperatorToken;constructor(e,t){super(),this.ExpLeft=e,this.OperatorToken=t}ToString(e){return this.ExpLeft.ToString(e)+this.OperatorToken.Text}}class ExpTernary extends Expression{ExpCondition;ExpIf;ExpElse;constructor(e,t,r){super(),this.ExpCondition=e,this.ExpIf=t,this.ExpElse=r}ToString(e){return this.ExpCondition.ToString(e)+" ? "+this.ExpIf.ToString(e)+" : "+this.ExpElse.ToString(e)}}class ExpUnary extends Expression{OperatorToken;ExpRight;constructor(e,t){super(),this.OperatorToken=e,this.ExpRight=t}ToString(e){return this.OperatorToken.Text+this.ExpRight.ToString(e)}}class ExpVariable extends Expression{VarToken;constructor(e){super(),this.VarToken=e}ToString(e){switch(e){default:case 0:return this.VarToken.Text;case 1:return HLSL.TranslateToGLSL(this.VarToken.Text)}}}class ParseError extends Error{line;text;constructor(e,...t){super(...t),this.line=null==e?-1:e.Line,this.text=null==e?"":e.Text}}