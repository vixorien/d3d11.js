const D3D11_APPEND_ALIGNED_ELEMENT=4294967295,D3D11_BIND_VERTEX_BUFFER=1,D3D11_BIND_INDEX_BUFFER=2,D3D11_BIND_CONSTANT_BUFFER=4,D3D11_BIND_SHADER_RESOURCE=8,D3D11_BIND_RENDER_TARGET=32,D3D11_BIND_DEPTH_STENCIL=64,D3D11_COMPARISON_NEVER=1,D3D11_COMPARISON_LESS=2,D3D11_COMPARISON_EQUAL=3,D3D11_COMPARISON_LESS_EQUAL=4,D3D11_COMPARISON_GREATER=5,D3D11_COMPARISON_NOT_EQUAL=6,D3D11_COMPARISON_GREATER_EQUAL=7,D3D11_COMPARISON_ALWAYS=8,D3D11_CPU_ACCESS_WRITE=65536,D3D11_CPU_ACCESS_READ=131072,D3D11_JS_CREATE_DEVICE_ALPHA_CANVAS=1,D3D11_JS_CREATE_DEVICE_PREMULTIPLIED_ALPHA=2,D3D11_CULL_NONE=1,D3D11_CULL_FRONT=2,D3D11_CULL_BACK=3,D3D11_DEFAULT_STENCIL_READ_MASK=255,D3D11_DEFAULT_STENCIL_WRITE_MASK=255,D3D11_DEPTH_WRITE_MASK_ZERO=0,D3D11_DEPTH_WRITE_MASK_ALL=1,D3D11_DSV_DIMENSION_TEXTURE1D=1,D3D11_DSV_DIMENSION_TEXTURE1DARRAY=2,D3D11_DSV_DIMENSION_TEXTURE2D=3,D3D11_DSV_DIMENSION_TEXTURE2DARRAY=4,D3D11_DSV_READ_ONLY_DEPTH=1,D3D11_DSV_READ_ONLY_STENCIL=2,D3D11_JS_FEATURE_ANISOTROPIC_FILTER_SUPPORT=0,D3D11_JS_FEATURE_FLOAT_TEXTURE_SUPPORT=1,D3D11_JS_FEATURE_FLOAT_TEXTURE_FILTER_SUPPORT=2,D3D11_JS_FEATURE_COMPRESSED_TEXTURE_S3TC_SUPPORT=3,D3D11_FILL_WIREFRAME=2,D3D11_FILL_SOLID=3,D3D11_FILTER_MIN_MAG_MIP_POINT=0,D3D11_FILTER_MIN_MAG_POINT_MIP_LINEAR=1,D3D11_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT=4,D3D11_FILTER_MIN_POINT_MAG_MIP_LINEAR=5,D3D11_FILTER_MIN_LINEAR_MAG_MIP_POINT=16,D3D11_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR=17,D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT=20,D3D11_FILTER_MIN_MAG_MIP_LINEAR=21,D3D11_FILTER_ANISOTROPIC=85,D3D11_FILTER_COMPARISON_MIN_MAG_MIP_POINT=128,D3D11_FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR=129,D3D11_FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT=132,D3D11_FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR=133,D3D11_FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT=144,D3D11_FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR=145,D3D11_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT=148,D3D11_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR=149,D3D11_FILTER_COMPARISON_ANISOTROPIC=213,D3D11_FLOAT32_MAX=3402823466e29,D3D11_CLEAR_DEPTH=1,D3D11_CLEAR_STENCIL=2,D3D11_INPUT_PER_VERTEX_DATA=0,D3D11_INPUT_PER_INSTANCE_DATA=1,D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED=0,D3D11_PRIMITIVE_TOPOLOGY_POINTLIST=1,D3D11_PRIMITIVE_TOPOLOGY_LINELIST=2,D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP=3,D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST=4,D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP=5,D3D11_RESOURCE_DIMENSION_UNKNOWN=0,D3D11_RESOURCE_DIMENSION_BUFFER=1,D3D11_RESOURCE_DIMENSION_TEXTURE1D=2,D3D11_RESOURCE_DIMENSION_TEXTURE2D=3,D3D11_RESOURCE_DIMENSION_TEXTURE3D=4,D3D11_RESOURCE_MISC_GENERATE_MIPS=1,D3D11_RESOURCE_MISC_TEXTURECUBE=4,D3D11_SRV_DIMENSION_TEXTURE1D=2,D3D11_SRV_DIMENSION_TEXTURE1DARRAY=3,D3D11_SRV_DIMENSION_TEXTURE2D=4,D3D11_SRV_DIMENSION_TEXTURE2DARRAY=5,D3D11_SRV_DIMENSION_TEXTURE3D=8,D3D11_SRV_DIMENSION_TEXTURECUBE=9,D3D11_STENCIL_OP_KEEP=1,D3D11_STENCIL_OP_ZERO=2,D3D11_STENCIL_OP_REPLACE=3,D3D11_STENCIL_OP_INCR_SAT=4,D3D11_STENCIL_OP_DECR_SAT=5,D3D11_STENCIL_OP_INVERT=6,D3D11_STENCIL_OP_INCR=7,D3D11_STENCIL_OP_DECR=8,D3D11_RTV_DIMENSION_TEXTURE1D=2,D3D11_RTV_DIMENSION_TEXTURE1DARRAY=3,D3D11_RTV_DIMENSION_TEXTURE2D=4,D3D11_RTV_DIMENSION_TEXTURE2DARRAY=5,D3D11_RTV_DIMENSION_TEXTURE3D=8,D3D11_TEXTURE_ADDRESS_WRAP=1,D3D11_TEXTURE_ADDRESS_MIRROR=2,D3D11_TEXTURE_ADDRESS_CLAMP=3,D3D11_TEXTURE_ADDRESS_BORDER=4,D3D11_TEXTURE_ADDRESS_MIRROR_ONCE=5,D3D11_USAGE_DEFAULT=0,D3D11_USAGE_IMMUTABLE=1,D3D11_USAGE_DYNAMIC=2,D3D11_USAGE_STAGING=3,DXGI_FORMAT_UNKNOWN=0,DXGI_FORMAT_R32G32B32A32_FLOAT=2,DXGI_FORMAT_R32G32B32_FLOAT=6,DXGI_FORMAT_R16G16B16A16_FLOAT=10,DXGI_FORMAT_R32G32_FLOAT=16,DXGI_FORMAT_R8G8B8A8_UNORM=28,DXGI_FORMAT_R8G8B8A8_UNORM_SRGB=29,DXGI_FORMAT_R16G16_FLOAT=34,DXGI_FORMAT_D32_FLOAT=40,DXGI_FORMAT_R32_FLOAT=41,DXGI_FORMAT_R32_UINT=42,DXGI_FORMAT_D24_UNORM_S8_UINT=45,DXGI_FORMAT_D16_UNORM=55,DXGI_FORMAT_R16_UINT=57,DXGI_FORMAT_BC1_UNORM=71,DXGI_FORMAT_BC2_UNORM=74,DXGI_FORMAT_BC3_UNORM=77,DXGI_FORMAT_B8G8R8A8_UNORM=87,DXGI_FORMAT_B8G8R8X8_UNORM=88;class D3D11_BUFFER_DESC{ByteWidth;Usage;BindFlags;CPUAccessFlags;MiscFlags;StructureByteStride;constructor(e,t,r,i=0,s=0,a=0){this.ByteWidth=e,this.Usage=t,this.BindFlags=r,this.CPUAccessFlags=i,this.MiscFlags=s,this.StructureByteStride=a}Copy(){return new D3D11_BUFFER_DESC(this.ByteWidth,this.Usage,this.BindFlags,this.CPUAccessFlags,this.MiscFlags,this.StructureByteStride)}}class D3D11_DEPTH_STENCIL_DESC{DepthEnable;DepthWriteMask;DepthFunc;StencilEnable;StencilReadMask;StencilWriteMask;FrontFace;BackFace;constructor(e=!0,t=1,r=2,i=!1,s=255,a=255,n=new D3D11_DEPTH_STENCILOP_DESC,l=new D3D11_DEPTH_STENCILOP_DESC){this.DepthEnable=e,this.DepthWriteMask=t,this.DepthFunc=r,this.StencilEnable=i,this.StencilReadMask=s,this.StencilWriteMask=a,this.FrontFace=n.Copy(),this.BackFace=l.Copy()}Copy(){return new D3D11_DEPTH_STENCIL_DESC(this.DepthEnable,this.DepthWriteMask,this.DepthFunc,this.StencilEnable,this.StencilReadMask,this.StencilWriteMask,this.FrontFace.Copy(),this.BackFace.Copy())}}class D3D11_DEPTH_STENCILOP_DESC{StencilFailOp;StencilDepthFailOp;StencilPassOp;StencilFunc;constructor(e=1,t=1,r=1,i=8){this.StencilFailOp=e,this.StencilDepthFailOp=t,this.StencilPassOp=r,this.StencilFunc=i}Copy(){return new D3D11_DEPTH_STENCILOP_DESC(this.StencilFailOp,this.StencilDepthFailOp,this.StencilPassOp,this.StencilFunc)}}class D3D11_DEPTH_STENCIL_VIEW_DESC{Format;ViewDimension;Flags;MipSlice;FirstArraySlice;ArraySize;constructor(e,t,r=0,i=0,s=0,a=1){this.Format=e,this.ViewDimension=t,this.Flags=r,this.MipSlice=i,this.FirstArraySlice=s,this.ArraySize=a}Copy(){return new D3D11_DEPTH_STENCIL_VIEW_DESC(this.Format,this.ViewDimension,this.Flags,this.MipSlice,this.FirstArraySlice,this.ArraySize)}}class D3D11_INPUT_ELEMENT_DESC{SemanticName;SemanticIndex;Format;InputSlot;AlignedByteOffset;InputSlotClass;InstanceDataStepRate;constructor(e,t,r,i,s,a,n){this.SemanticName=e,this.SemanticIndex=t,this.Format=r,this.InputSlot=i,this.AlignedByteOffset=s,this.InputSlotClass=a,this.InstanceDataStepRate=n}Copy(){return new D3D11_INPUT_ELEMENT_DESC(this.SemanticName,this.SemanticIndex,this.Format,this.InputSlot,this.AlignedByteOffset,this.InputSlotClass,this.InstanceDataStepRate)}}class D3D11_RASTERIZER_DESC{FillMode;CullMode;FrontCounterClockwise;DepthBias;DepthBiasClamp;SlopeScaledDepthBias;DepthClipEnable;ScissorEnable;MultisampleEnable;AntiasliasedLineEnable;constructor(e,t,r=!1,i=0,s=0,a=0,n=!0,l=!1,o=!1,h=!1){this.FillMode=e,this.CullMode=t,this.FrontCounterClockwise=r,this.DepthBias=i,this.DepthBiasClamp=s,this.SlopeScaledDepthBias=a,this.DepthClipEnable=n,this.ScissorEnable=l,this.MultisampleEnable=o,this.AntiasliasedLineEnable=h}Copy(){return new D3D11_RASTERIZER_DESC(this.FillMode,this.CullMode,this.FrontCounterClockwise,this.DepthBias,this.DepthBiasClamp,this.SlopeScaledDepthBias,this.DepthClipEnable,this.ScissorEnable,this.MultisampleEnable,this.AntiasliasedLineEnable)}}class D3D11_RENDER_TARGET_VIEW_DESC{Format;ViewDimension;MipSlice;FirstArraySlice;ArraySize;constructor(e,t,r=0,i=0,s=1){this.Format=e,this.ViewDimension=t,this.MipSlice=r,this.FirstArraySlice=i,this.ArraySize=s}Copy(){return new D3D11_RENDER_TARGET_VIEW_DESC(this.Format,this.ViewDimension,this.MipSlice,this.FirstArraySlice,this.ArraySize)}}class D3D11_SAMPLER_DESC{Filter;AddressU;AddressV;AddressW;MipLODBias;MaxAnisotropy;ComparisonFunc;BorderColor;MinLOD;MaxLOD;constructor(e,t,r,i,s,a,n,l,o,h){this.Filter=e,this.AddressU=t,this.AddressV=r,this.AddressW=i,this.MipLODBias=s,this.MaxAnisotropy=a,this.ComparisonFunc=n,this.BorderColor=l,this.MinLOD=o,this.MaxLOD=h}Copy(){return new D3D11_SAMPLER_DESC(this.Filter,this.AddressU,this.AddressV,this.AddressW,this.MipLODBias,this.MaxAnisotropy,this.ComparisonFunc,this.BorderColor,this.MinLOD,this.MaxLOD)}}class D3D11_SHADER_RESOURCE_VIEW_DESC{Format;ViewDimension;MostDetailedMip;MipLevels;FirstArraySlice;ArraySize;constructor(e,t,r=0,i=1,s=0,a=1){this.Format=e,this.ViewDimension=t,this.MostDetailedMip=r,this.MipLevels=i,this.FirstArraySlice=s,this.ArraySize=a}Copy(){return new D3D11_SHADER_RESOURCE_VIEW_DESC(this.Format,this.ViewDimension,this.MostDetailedMip,this.MipLevels,this.FirstArraySlice,this.ArraySize)}}class D3D11_TEXTURE1D_DESC{Width;MipLevels;ArraySize;Format;Usage;BindFlags;CPUAccessFlags;MiscFlags;constructor(e,t,r,i,s,a,n,l){this.Width=e,this.MipLevels=t,this.ArraySize=r,this.Format=i,this.Usage=s,this.BindFlags=a,this.CPUAccessFlags=n,this.MiscFlags=l}Copy(){return new D3D11_TEXTURE1D_DESC(this.Width,this.MipLevels,this.ArraySize,this.Format,this.Usage,this.BindFlags,this.CPUAccessFlags,this.MiscFlags)}}class D3D11_TEXTURE2D_DESC{Width;Height;MipLevels;ArraySize;Format;SampleDesc;Usage;BindFlags;CPUAccessFlags;MiscFlags;constructor(e,t,r,i,s,a,n,l,o,h){this.Width=e,this.Height=t,this.MipLevels=r,this.ArraySize=i,this.Format=s,this.SampleDesc=a.Copy(),this.Usage=n,this.BindFlags=l,this.CPUAccessFlags=o,this.MiscFlags=h}Copy(){return new D3D11_TEXTURE2D_DESC(this.Width,this.Height,this.MipLevels,this.ArraySize,this.Format,this.SampleDesc.Copy(),this.Usage,this.BindFlags,this.CPUAccessFlags,this.MiscFlags)}}class D3D11_TEXTURE3D_DESC{Width;Height;Depth;MipLevels;Format;Usage;BindFlags;CPUAccessFlags;MiscFlags;constructor(e,t,r,i,s,a,n,l,o){this.Width=e,this.Height=t,this.Depth=r,this.MipLevels=i,this.Format=s,this.Usage=a,this.BindFlags=n,this.CPUAccessFlags=l,this.MiscFlags=o}Copy(){return new D3D11_TEXTURE3D_DESC(this.Width,this.Height,this.Depth,this.MipLevels,this.Format,this.Usage,this.BindFlags,this.CPUAccessFlags,this.MiscFlags)}}class DXGI_SAMPLE_DESC{Count;Quality;constructor(e=1,t=0){this.Count=e,this.Quality=t}Copy(){return new DXGI_SAMPLE_DESC(this.Count,this.Quality)}}class DXGI_SWAP_CHAIN_DESC{Width;Height;Format;constructor(e,t,r=28){this.Width=e,this.Height=t,this.Format=r}Copy(){return new DXGI_SWAP_CHAIN_DESC(this.Width,this.Height,this.Format)}}class D3D11_VIEWPORT{TopLeftX;TopLeftY;Width;Height;MinDepth;MaxDepth;constructor(e,t,r,i,s,a){this.TopLeftX=e,this.TopLeftY=t,this.Width=r,this.Height=i,this.MinDepth=s,this.MaxDepth=a}}class D3D11_RECT{Left;Top;Right;Bottom;constructor(e,t,r,i){this.Left=e,this.Top=t,this.Right=r,this.Bottom=i}}class D3D11_BOX{Left;Top;Front;Right;Bottom;Back;constructor(e,t,r,i,s=0,a=1){this.Left=e,this.Top=t,this.Right=r,this.Bottom=i,this.Front=s,this.Back=a}IsEmpty(){return this.Right<=this.Left||this.Bottom<=this.Top||this.Back<=this.Front}}class IUnknown{#a;constructor(){if(new.target===IUnknown)throw Error("Cannot instantiate IUnknown objects directly.");this.#a=0,this.AddRef()}GetRef(){return this.#a}AddRef(){return this.#a++,this.#a}Release(){return this.#a--,this.#b(),this.#a}#b(){if(this.#a<0)throw Error("Object has been released and is no longer available")}}class ID3D11DeviceChild extends IUnknown{#c;constructor(e){if(super(),new.target===ID3D11DeviceChild)throw Error("Cannot instantiate ID3D11DeviceChild objects directly.");this.#c=e,this.#c.AddRef()}Release(){return super.Release(),0>=this.GetRef()&&this.#c.Release(),this.GetRef()}GetDevice(){return this.#c.AddRef(),this.#c}}function D3D11CreateDevice(e,t){let r=e.getContext("webgl2",{alpha:(1&t)==1,premultipliedAlpha:(2&t)==2,antialias:!1,depth:!1,preserveDrawingBuffer:!0});if(null===r)throw Error("Unable to create internal WebGL2 rendering context for d3d11.js");return new class extends ID3D11Device{}(r)}function D3D11CreateDeviceAndSwapChain(e,t,r){let i=D3D11CreateDevice(e,t),s=i.GetImmediateContext(),a=DXGICreateSwapChain(i,r);return[i,s,a]}function DXGICreateSwapChain(e,t){return new class extends IDXGISwapChain{}(e,t)}function D3D11CalcSubresource(e,t,r){return e+t*r}class ID3D11Device extends IUnknown{#d;#e;#f;#g;#h;#i;#j;#k;constructor(e){if(super(),new.target===ID3D11Device)throw Error("Cannot instantiate ID3D11Device objects directly.  Use D3D11CreateDevice() or D3D11CreateDeviceAndSwapChain() instead.");this.#d=e,this.#e=null,this.#j=this.#d.createFramebuffer(),this.#k=this.#d.createFramebuffer(),this.#f=this.#d.getExtension("EXT_texture_filter_anisotropic")||this.#d.getExtension("MOZ_EXT_texture_filter_anisotropic")||this.#d.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),this.#g=this.#d.getExtension("EXT_color_buffer_float"),this.#h=this.#d.getExtension("OES_texture_float_linear"),this.#i=this.#d.getExtension("WEBGL_compressed_texture_s3tc"),this.#d.pixelStorei(this.#d.UNPACK_FLIP_Y_WEBGL,!1)}Release(){super.Release(),0>=this.GetRef()&&(this.#e.Release(),this.#d.deleteFramebuffer(this.#j),this.#d.deleteFramebuffer(this.#k))}GetAdapter(){return this.#d}CheckFeatureSupport(e){switch(e){case 0:return this.#f;case 1:return this.#g;case 2:return this.#h;case 3:return this.#i;default:return null}}GetBackBufferFramebuffer(){return this.#k}GetImmediateContext(){return null==this.#e?this.#e=new class extends ID3D11DeviceContext{}(this):this.#e.AddRef(),this.#e}CreateBuffer(e,t){this.#l(e,t),null!=this.#e&&this.#e.DirtyPipeline();let r=this.#d.createBuffer(),i=this.#d.STATIC_DRAW;switch(e.Usage){case 1:i=this.#d.STATIC_DRAW;break;case 2:default:i=this.#d.DYNAMIC_DRAW;break;case 3:i=this.#d.DYNAMIC_READ}let s,a;return 2==e.BindFlags?(s=this.#d.ELEMENT_ARRAY_BUFFER,a=this.#d.getParameter(this.#d.ELEMENT_ARRAY_BUFFER_BINDING)):4==e.BindFlags?(s=this.#d.UNIFORM_BUFFER,a=this.#d.getParameter(this.#d.UNIFORM_BUFFER_BINDING)):(s=this.#d.ARRAY_BUFFER,a=this.#d.getParameter(this.#d.ARRAY_BUFFER_BINDING)),this.#d.bindBuffer(s,r),null==t?this.#d.bufferData(s,e.ByteWidth,i):this.#d.bufferData(s,t,i),this.#d.bindBuffer(s,a),new class extends ID3D11Buffer{}(this,e,s,r)}CreateDepthStencilState(e){if(null==e)throw Error("Depth-Stencil description cannot be null");return this.#m(e),new class extends ID3D11DepthStencilState{}(this,e)}CreateDepthStencilView(e,t){if(null==t){let r=null;if(e instanceof ID3D11Texture1D)r=1;else if(e instanceof ID3D11Texture2D)r=3;else throw Error("Invalid resource type for DSV");let i=e.GetDesc();t=new D3D11_DEPTH_STENCIL_VIEW_DESC(i.Format,r,0,0,0,i.ArraySize)}return this.#n(e,t),new class extends ID3D11DepthStencilView{}(this,e,t)}CreateInputLayout(e){return null!=this.#e&&this.#e.DirtyPipeline(),new class extends ID3D11InputLayout{}(this,e)}CreatePixelShader(e){null!=this.#e&&this.#e.DirtyPipeline();let t=new HLSL(e,ShaderTypePixel),r=this.#o(t.GetGLSL(),this.#d.FRAGMENT_SHADER);return new class extends ID3D11PixelShader{}(this,r,t)}CreateRasterizerState(e){if(null==e)throw Error("Rasterizer description cannot be null");return this.#p(e),new class extends ID3D11RasterizerState{}(this,e)}CreateRenderTargetView(e,t){if(null==t){let r=null;if(e instanceof ID3D11Texture1D)r=2;else if(e instanceof ID3D11Texture2D)r=4;else if(e instanceof ID3D11Texture3D)r=8;else throw Error("Invalid resource type for RTV");let i=e.GetDesc();t=new D3D11_RENDER_TARGET_VIEW_DESC(i.Format,r,0,0,i.ArraySize)}this.#q(e,t);let s=t.Copy();return(4&e.GetDesc().MiscFlags)==4&&(2==s.FirstArraySlice?s.FirstArraySlice=3:3==s.FirstArraySlice&&(s.FirstArraySlice=2)),new class extends ID3D11RenderTargetView{}(this,e,s)}CreateSamplerState(e){if(null==e)throw Error("Sampler description cannot be null");return this.#r(e),new class extends ID3D11SamplerState{}(this,e)}CreateShaderResourceView(e,t){if(null==t){let r=e.GetDesc(),i=null;if(e instanceof ID3D11Texture1D)i=r.ArraySize>1?3:2;else if(e instanceof ID3D11Texture2D)i=!0&r.MiscFlags&&6==r.ArraySize?9:r.ArraySize>1?5:4;else if(e instanceof ID3D11Texture3D)i=8;else throw Error("Invalid resource type for SRV");t=new D3D11_SHADER_RESOURCE_VIEW_DESC(r.Format,i,0,r.MipLevels,0,r.ArraySize)}return this.#s(e,t),new class extends ID3D11ShaderResourceView{}(this,e,t)}CreateTexture1D(e,t){return this.#t(1,e,t)}CreateTexture2D(e,t){return this.#t(2,e,t)}CreateTexture3D(e,t){return this.#t(3,e,t)}#t(e,t,r){null!=this.#e&&this.#e.DirtyPipeline(),this.#u(e,t,r);let i=this.#d.createTexture(),s=this.#v(t.Format),a=s.InternalFormat,n=s.Format,l=s.Type;s.IsDepth,s.HasStencil;let o=s.IsCompressed,h=t.MipLevels>1,u=this.#w(e,t);this.#d.bindTexture(u,i);let c=1,p=1,f=1;switch(e){case 3:f=t.Depth;case 2:p=t.Height;case 1:c=t.Width}switch(u){case this.#d.TEXTURE_2D:case this.#d.TEXTURE_CUBE_MAP:this.#d.texStorage2D(u,t.MipLevels,a,c,p);break;case this.#d.TEXTURE_2D_ARRAY:this.#d.texStorage3D(u,t.MipLevels,a,c,p,t.ArraySize);break;case this.#d.TEXTURE_3D:this.#d.texStorage3D(u,t.MipLevels,a,c,p,f)}if(null!=r&&r.length>0)switch(u){case this.#d.TEXTURE_2D:for(let T=0;T<t.MipLevels&&T<r.length;T++){if(null==r[T])continue;let S=Math.pow(2,T),D=Math.max(1,Math.floor(c/S)),d=Math.max(1,Math.floor(p/S));this.#d.texSubImage2D(u,T,0,0,D,d,n,l,r[T])}break;case this.#d.TEXTURE_CUBE_MAP:let m=[this.#d.TEXTURE_CUBE_MAP_POSITIVE_X,this.#d.TEXTURE_CUBE_MAP_NEGATIVE_X,this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Y,this.#d.TEXTURE_CUBE_MAP_POSITIVE_Y,this.#d.TEXTURE_CUBE_MAP_POSITIVE_Z,this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Z];for(let E=0;E<6;E++)for(let g=0;g<t.MipLevels&&g<r.length/6;g++){if(null==r[g+E*t.MipLevels])continue;let x=Math.pow(2,g),R=Math.max(1,Math.floor(c/x)),_=Math.max(1,Math.floor(p/x));o?this.#d.compressedTexSubImage2D(m[E],g,0,0,R,_,n,r[g+E*t.MipLevels]):this.#d.texSubImage2D(m[E],g,0,0,R,_,n,l,r[g+E*t.MipLevels])}break;case this.#d.TEXTURE_2D_ARRAY:for(let I=0;I<t.ArraySize;I++)for(let A=0;A<t.MipLevels&&A<r.length/t.ArraySize;A++){if(null==r[A+I*t.MipLevels])continue;let C=Math.pow(2,A),P=Math.max(1,Math.floor(c/C)),$=Math.max(1,Math.floor(p/C));o?this.#d.compressedTexSubImage3D(u,A,0,0,I,P,$,1,n,r[A+I*t.MipLevels]):this.#d.texSubImage3D(u,A,0,0,I,P,$,1,n,l,r[A+I*t.MipLevels])}break;case this.#d.TEXTURE_3D:for(let w=0;w<t.MipLevels&&w<r.length;w++){if(null==r[w])continue;let L=Math.pow(2,w),M=Math.max(1,Math.floor(c/L)),F=Math.max(1,Math.floor(p/L)),b=Math.max(1,Math.floor(f/L));o?this.#d.compressedTexSubImage3D(u,w,0,0,0,M,F,b,n,r[w+arraySlice*t.MipLevels]):this.#d.texSubImage3D(u,w,0,0,0,M,F,b,n,l,r[w])}}switch(this.#x(u,h),this.#d.bindTexture(u,null),e){case 1:return new class extends ID3D11Texture1D{}(this,t,u,i);case 2:return new class extends ID3D11Texture2D{}(this,t,u,i);case 3:return new class extends ID3D11Texture3D{}(this,t,u,i);default:throw Error("Invalid texture dimension")}}CreateVertexShader(e){null!=this.#e&&this.#e.DirtyPipeline();let t=new HLSL(e,ShaderTypeVertex),r=this.#o(t.GetGLSL(),this.#d.VERTEX_SHADER);return new class extends ID3D11VertexShader{}(this,r,t)}ReadFromSubresource(e,t,r,i=null){if(!(null!=i&&i.IsEmpty())){if(t instanceof ID3D11Texture2D){let s=t.GetDesc();if(3!=s.Usage)throw Error("Invalid usage on resource - can only read from staging resources");if((131072&s.CPUAccessFlags)==0)throw Error("Invalid CPU Access flag on resource - must be set for reading");let a=D3D11CalcSubresource(s.MipLevels-1,s.ArraySize-1,s.MipLevels);if(r<0||r>a)throw Error("Invalid subresource index for reading");let n=Math.floor(r/s.MipLevels),l=r-n*s.MipLevels,o=Math.pow(2,l),h=Math.max(1,Math.floor(s.Width/o)),u=Math.max(1,Math.floor(s.Height/o)),c=0,p=0,f=h,T=u;null!=i&&(c=i.Left,p=u-i.Bottom,f=i.Right-i.Left,T=i.Bottom-i.Top),this.#e.DirtyPipeline(),this.#d.bindFramebuffer(this.#d.READ_FRAMEBUFFER,this.#j);let S=(4&s.MiscFlags)==4;if(!(s.ArraySize>1)||S){let D=this.#d.TEXTURE_2D;if(S)switch(n){case 0:D=this.#d.TEXTURE_CUBE_MAP_POSITIVE_X;break;case 1:D=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_X;break;case 2:D=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Y;break;case 3:D=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Y;break;case 4:D=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Z;break;case 5:D=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Z;break;default:throw Error("Invalid subresource for cube map reading")}this.#d.framebufferTexture2D(this.#d.READ_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,D,t.GetGLResource(),l)}else this.#d.framebufferTextureLayer(this.#d.READ_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,t.GetGLResource(),l,n);let d=this.#v(s.Format);this.#d.readPixels(c,p,f,T,d.Format,d.Type,e)}else if(t instanceof ID3D11Buffer)throw Error("Reading from a buffer is not yet implemented!");else throw Error("Given source resource is invalid or not yet implemented!")}}#o(y,v){let N=this.#d.createShader(v);this.#d.shaderSource(N,y),this.#d.compileShader(N);if(!this.#d.getShaderParameter(N,this.#d.COMPILE_STATUS))throw Error("Error compiling shader: "+this.#d.getShaderInfoLog(N));return N}#w(B,G){let O=G.ArraySize>1,U=(4&G.MiscFlags)==4;if(3==B)return this.#d.TEXTURE_3D;if(2==B&&U)return this.#d.TEXTURE_CUBE_MAP;if((1==B||2==B)&&!U)return O?this.#d.TEXTURE_2D_ARRAY:this.#d.TEXTURE_2D;throw Error("Description does not match any known WebGL texture types")}#v(k){let V={Type:null,Format:null,InternalFormat:null,IsDepth:!1,HasStencil:!1,IsCompressed:!1};switch(k){case 55:V.Type=this.#d.UNSIGNED_SHORT,V.Format=this.#d.DEPTH_COMPONENT,V.InternalFormat=this.#d.DEPTH_COMPONENT16,V.IsDepth=!0,V.HasStencil=!1;break;case 45:V.Type=this.#d.UNSIGNED_INT_24_8,V.Format=this.#d.DEPTH_STENCIL,V.InternalFormat=this.#d.DEPTH24_STENCIL8,V.IsDepth=!0,V.HasStencil=!0;break;case 40:V.Type=this.#d.FLOAT,V.Format=this.#d.DEPTH_COMPONENT,V.InternalFormat=this.#d.DEPTH_COMPONENT32F,V.IsDepth=!0,V.HasStencil=!1;break;case 28:V.Type=this.#d.UNSIGNED_BYTE,V.Format=this.#d.RGBA,V.InternalFormat=this.#d.RGBA8;break;case 29:V.Type=this.#d.UNSIGNED_BYTE,V.Format=this.#d.RGBA,V.InternalFormat=this.#d.SRGB8_ALPHA8;break;case 34:V.Type=this.#d.HALF_FLOAT,V.Format=this.#d.RG,V.InternalFormat=this.#d.RG16F;break;case 10:V.Type=this.#d.HALF_FLOAT,V.Format=this.#d.RGBA,V.InternalFormat=this.#d.RGBA16F;break;case 2:V.Type=this.#d.FLOAT,V.Format=this.#d.RGBA,V.InternalFormat=this.#d.RGBA32F;break;case 71:if(null==this.#i)throw Error("DXT compressed texture formats not supported by your device");V.Format=this.#i.COMPRESSED_RGBA_S3TC_DXT1_EXT,V.InternalFormat=this.#i.COMPRESSED_RGBA_S3TC_DXT1_EXT,V.IsCompressed=!0;break;case 74:if(null==this.#i)throw Error("DXT compressed texture formats not supported by your device");V.Format=this.#i.COMPRESSED_RGBA_S3TC_DXT3_EXT,V.InternalFormat=this.#i.COMPRESSED_RGBA_S3TC_DXT3_EXT,V.IsCompressed=!0;break;case 77:if(null==this.#i)throw Error("DXT compressed texture formats not supported by your device");V.Format=this.#i.COMPRESSED_RGBA_S3TC_DXT5_EXT,V.InternalFormat=this.#i.COMPRESSED_RGBA_S3TC_DXT5_EXT,V.IsCompressed=!0;break;default:throw Error("Format specified is not implemented yet!")}return V}#x(X,H){this.#d.texParameteri(X,this.#d.TEXTURE_MAG_FILTER,this.#d.LINEAR),this.#d.texParameteri(X,this.#d.TEXTURE_MIN_FILTER,H?this.#d.LINEAR_MIPMAP_LINEAR:this.#d.LINEAR),this.#d.texParameteri(X,this.#d.TEXTURE_WRAP_S,this.#d.CLAMP_TO_EDGE),this.#d.texParameteri(X,this.#d.TEXTURE_WRAP_T,this.#d.CLAMP_TO_EDGE),this.#d.texParameteri(X,this.#d.TEXTURE_WRAP_R,this.#d.CLAMP_TO_EDGE),this.#d.texParameterf(X,this.#d.TEXTURE_MIN_LOD,-3402823466e29),this.#d.texParameterf(X,this.#d.TEXTURE_MAX_LOD,3402823466e29),this.#d.texParameteri(X,this.#d.TEXTURE_COMPARE_MODE,this.#d.NONE),this.#d.texParameteri(X,this.#d.TEXTURE_COMPARE_FUNC,this.#d.NEVER),null!=this.#f&&this.#d.texParameterf(X,this.#f.TEXTURE_MAX_ANISOTROPY_EXT,1)}#l(W,z){let q=(1&W.BindFlags)==1,Y=(2&W.BindFlags)==2,j=(4&W.BindFlags)==4,Z=(8&W.BindFlags)==8,Q=(32&W.BindFlags)==32,K=(64&W.BindFlags)==64;if(W.ByteWidth<=0)throw Error("Invalid byte width for buffer description.  Must be greater than zero.");if(j&&W.ByteWidth%16!=0)throw Error("Invalid byte width for buffer description.  Constant buffer byte width must be a multiple of 16");if(this.#y(W,z),q||Y||j||Z||Q||K){if(j&&4!=W.BindFlags)throw Error("Constant Buffer bind flag cannot be combined with any other flags.");if(Y&&2!=W.BindFlags)throw Error("Index Buffer bind flag cannot be combined with any other flags.")}else throw Error("Invalid bind flag for buffer description.");if(0!=W.CPUAccessFlags&&131072!=W.CPUAccessFlags&&65536!=W.CPUAccessFlags)throw Error("Invalid CPU Access Flags for buffer description.");if(131072==W.CPUAccessFlags&&3!=W.Usage)throw Error("Invalid CPU Access in buffer description.  CPU Access Read can only be used with Staging usage.");if(65536==W.CPUAccessFlags&&(0==W.Usage||1==W.Usage))throw Error("Invalid CPU Access in buffer description.  CPU Access Write can only be used with Dynamic or Staging usage.");if(0!=W.MiscFlags)throw Error("Invalid Misc Flags for buffer description.");if(0!=W.StructureByteStride)throw Error("Invalid Structured Byte Stride for buffer description.")}#m(J){if(1!=J.DepthWriteMask&&0!=J.DepthWriteMask)throw Error("Invalid Depth Write Mask for depth stencil description");if(J.DepthFunc<1||J.DepthFunc>8)throw Error("Invalid Depth Function for depth stencil description");if(J.StencilEnable)throw Error("Stencil support not yet implemented!")}#n(ee,et){if(null==ee)throw Error("Resource cannot be null when creating a DSV");let er=ee.GetDesc();if((64&er.BindFlags)==0)throw Error("Cannot create DSV: resource is not marked for depth/stencil binding");if(0==et.Format)et.Format=er.Format;else if(et.Format!=er.Format)throw Error("Specified DSV Format does not match resource");switch(et.Format){case 55:case 40:case 45:break;default:throw Error("Specified DSV Format is invalid or not yet implemented!")}switch(et.ViewDimension){case 3:if(!(ee instanceof ID3D11Texture2D))throw Error("Specified DSV View Dimension does not match resource");break;case 1:if(!(ee instanceof ID3D11Texture1D))throw Error("Specified DSV View Dimension does not match resource");break;case 2:case 4:throw Error("Specified DSV View Dimension is not yet implemented!");default:throw Error("Specified DSV View Dimension is invalid")}switch(et.Flags){case 0:break;case 1:case 2:throw Error("Specified DSV Flags not yet implemented!");default:throw Error("Specified DSV Flags are invalid")}if(et.MipSlice<0||et.MipSlice>=er.MipLevels)throw Error("Specified DSV Mip Slice is invalid");if(et.FirstArraySlice<0||et.FirstArraySlice>=er.ArraySize)throw Error("Specified DSV First Array Slice is invalid");let ei=et.FirstArraySlice+et.ArraySize-1;if(0==et.ArraySize||ei<0||ei>=er.ArraySize)throw Error("Specified DSV Array Size is invalid")}#p(es){switch(es.FillMode){case 3:break;case 2:throw Error("Wireframe fill mode not yet implemented!");default:throw Error("Invalid Fill Mode for rasterizer description")}if(1!=es.CullMode&&2!=es.CullMode&&3!=es.CullMode)throw Error("Invalid Cull Mode for rasterizer description");if(0!=es.DepthBiasClamp)throw Error("Depth Bias Clamp unsupported in WebGL");if(!es.DepthClipEnable)throw Error("Disabling Depth Clip unsupported in WebGL");if(es.MultisampleEnable)throw Error("Multisampling not yet implemented");if(es.AntiasliasedLineEnable)throw Error("Antialiased Lines not yet implemented")}#r(ea){let en=ea.Filter;if(en<0||en>213||(2&en)==2||(8&en)==8||(32&en)==32)throw Error("Invalid filter mode for sampler state");let el=ea.AddressU,eo=ea.AddressV,eh=ea.AddressW;if(el<1||el>5)throw Error("Invalid address U mode for sampler state");if(eo<1||eo>5)throw Error("Invalid address V mode for sampler state");if(eh<1||eh>5)throw Error("Invalid address W mode for sampler state");if(4==el||4==eo||4==eh)throw Error("Border address mode unsupported in WebGL");if(5==el||5==eo||5==eh)throw Error("MirrorOnce address mode unsupported in WebGL");let eu=(64&en)==64;if(this.#f&&eu){let ec=this.#d.getParameter(this.#f.MAX_TEXTURE_MAX_ANISOTROPY_EXT);if(ea.MaxAnisotropy<1||ea.MaxAnisotropy>ec)throw Error(`Invalid MaxAnisotropy value for sampler state - range is [1, ${ec}]`)}else if(eu)throw Error("Anisotropic filtering not available on this device");let ep=ea.ComparisonFunc;if((128&en)==128&&(ep<1||ep>8))throw Error("Invalid comparison function for sampler state");let ef=ea.BorderColor;if((4==el||4==eo||4==eh)&&ef[0]<0||ef[0]>1||ef[1]<0||ef[1]>1||ef[2]<0||ef[2]>1||ef[3]<0||ef[3]>1)throw Error("Invalid border color for sampler state")}#q(eT,eS){if(null==eT)throw Error("Resource cannot be null when creating an RTV");let eD=eT.GetDesc();if((32&eD.BindFlags)==0)throw Error("Cannot create RTV: resource is not marked for render target binding");if(0==eS.Format)eS.Format=eD.Format;else if(eS.Format!=eD.Format)throw Error("Specified RTV Format does not match resource");switch(eS.Format){case 28:case 29:case 34:case 10:case 2:break;default:throw Error("Specified RTV Format is invalid or not yet implemented!")}switch(eS.ViewDimension){case 4:case 5:if(!(eT instanceof ID3D11Texture2D))throw Error("Specified RTV View Dimension does not match resource");break;case 2:case 3:if(!(eT instanceof ID3D11Texture1D))throw Error("Specified RTV View Dimension does not match resource");break;case 8:if(!(eT instanceof ID3D11Texture3D))throw Error("Specified RTV View Dimension does not match resource");break;default:throw Error("Specified RTV View Dimension is invalid")}if(eS.MipSlice<0||eS.MipSlice>=eD.MipLevels)throw Error("Specified RTV Mip Slice is invalid");if(eS.FirstArraySlice<0||eS.FirstArraySlice>=eD.ArraySize)throw Error("Specified RTV First Array Slice is invalid");let ed=eS.FirstArraySlice+eS.ArraySize-1;if(0==eS.ArraySize||ed<0||ed>=eD.ArraySize)throw Error("Specified RTV Array Size is invalid")}#s(em,eE){if(null==em)throw Error("Resource cannot be null when creating an SRV");let eg=em.GetDesc();if((8&eg.BindFlags)==0)throw Error("Cannot create SRV: resource is not marked for shader resource binding");switch(eE.Format){case 28:case 29:case 34:case 10:case 2:case 71:case 74:case 77:break;default:throw Error("Specified SRV Format is invalid or not yet implemented!")}if(eE.Format!=eg.Format)throw Error("Specified SRV Format does not match resource");switch(eE.ViewDimension){case 4:case 5:case 9:if(!(em instanceof ID3D11Texture2D))throw Error("Specified SRV View Dimension does not match resource");break;case 2:case 3:if(!(em instanceof ID3D11Texture1D))throw Error("Specified SRV View Dimension does not match resource");break;case 8:if(!(em instanceof ID3D11Texture3D))throw Error("Specified SRV View Dimension does not match resource");break;default:throw Error("Specified SRV View Dimension is invalid")}if(eE.MostDetailedMip<0||eE.MostDetailedMip>=eg.MipLevels)throw Error("Specified SRV Most Detailed Mip is invalid");let ex=eE.MostDetailedMip+eE.MipLevels-1;if(0==eE.MipLevels||ex<0||ex>=eg.MipLevels)throw Error("Specified SRV Mip Levels value is invalid");if(eE.FirstArraySlice<0||eE.FirstArraySlice>=eg.ArraySize)throw Error("Specified SRV First Array Slice is invalid");let e8=eE.FirstArraySlice+eE.ArraySize-1;if(0==eE.ArraySize||e8<0||e8>=eg.ArraySize)throw Error("Specified SRV Array Size is invalid")}#u(eR,e_,eI){if(null==e_)throw Error("Description cannot be null when creating a texture");if(eR<1||eR>3)throw Error("Invalid texture dimension");let eA=this.#d.getParameter(this.#d.MAX_TEXTURE_SIZE),eC=this.#d.getParameter(this.#d.MAX_3D_TEXTURE_SIZE),eP=this.#d.getParameter(this.#d.MAX_CUBE_MAP_TEXTURE_SIZE),e$=this.#d.getParameter(this.#d.MAX_ARRAY_TEXTURE_LAYERS),ew=(4&e_.MiscFlags)==4,eL=(1&e_.MiscFlags)==1;if(ew&&2!=eR)throw Error("Only 2D textures may be used as cube maps");if(ew){if(e_.Width<=0||e_.Width>eP||e_.Height<=0||e_.Height>eP)throw Error(`Texture Cube dimensions must be between 1 and ${eP}, inclusive`)}else{let eM=3==eR?eC:eA;switch(eR){case 3:if(e_.Depth<=0||e_.Height>eM)throw Error(`Texture depth must be between 1 and ${eM}, inclusive`);case 2:if(e_.Height<=0||e_.Height>eM)throw Error(`Texture height must be between 1 and ${eM}, inclusive`);case 1:if(e_.Width<=0||e_.Width>eM)throw Error(`Texture width must be between 1 and ${eM}, inclusive`)}}if(3==eR&&Object.hasOwn(e_,"ArraySize"))throw Error("3D textures cannot have an array size");if(ew&&6!=e_.ArraySize)throw Error("Invalid array size for texture cube - must be exactly 6");if(e_.ArraySize<=0||e_.ArraySize>e$)throw Error(`Array size must be greater than zero and less than or equal to ${e$}`);let eF=Math.log2(Math.max(e_.Width,e_.Height))+1;if(0==e_.MipLevels&&(e_.MipLevels=eF),e_.MipLevels<=0||e_.MipLevels>eF)throw Error("Invalid mip levels specified for texture");switch(e_.Format){case 55:case 40:case 45:case 28:case 29:break;case 71:case 74:case 77:if(null==this.#i)throw Error("DXT compressed texture formats not supported by your device");break;case 34:case 10:case 2:if(null==this.#g)throw Error("Floating point texture formats are unsupported on your device");break;default:throw Error("Specified texture format is invalid or not yet implemented!")}switch(this.#y(e_,eI),e_.BindFlags){case 0:case 8:case 32:case 64:case 40:case 72:break;default:throw Error("Invalid bind flags specified")}if(eL&&((8&e_.BindFlags)==0||(32&e_.BindFlags)==0))throw Error("Resource must have SHADER_RESOURCE and RENDER_TARGET bind flags to generate mip maps")}#y(eb,ey){switch(eb.Usage){case 0:break;case 2:if((64&eb.BindFlags)==64||(32&eb.BindFlags)==32)throw Error("Dynamic resources cannot be bound for output");if(0==eb.BindFlags)throw Error("Dynamic resources must have at least one Bind Flag");if(65536!=eb.CPUAccessFlags)throw Error("Dynamic resources must have CPU Access Write");if(!(eb instanceof D3D11_BUFFER_DESC)){if(1!=eb.MipLevels)throw Error("Invalid mip levels - dynamic resources can only have a single subresource");if(1!=eb.ArraySize)throw Error("Invalid array size - dynamic resources can only have a single subresource")}break;case 3:if(0!=eb.BindFlags)throw Error("Staging resources cannot be bound to the pipeline and cannot have any bind flags set");if(0==eb.CPUAccessFlags)throw Error("Staging resources must have a CPU Access of either Read or Write.");break;case 1:if(null==ey||0==ey.length)throw Error("Immutable textures must have initial data");if((64&eb.BindFlags)==64||(32&eb.BindFlags)==32)throw Error("Immutable resources cannot be bound for output");break;default:throw Error("Invalid usage specified")}}}class ID3D11DeviceContext extends ID3D11DeviceChild{#d;#k;#z;#A;#B;#C;#D;#E;#F;#G;#H;#I;#J;#K;#L;#M;#N;#O;#P;#Q;#R;#S;#T;#U;#V;#W;#X;#Y;#Z;#$;#_;#aa;#ab;#ac;#ad;#ae;#af;#ag;#ah;#ai;#aj;#ak;#al;#am;#an;constructor(e){if(super(e),new.target===ID3D11DeviceContext)throw this.Release(),Error("Cannot instantiate ID3D11DeviceContext objects - use device.GetImmediateContext() or D3D11CreateDeviceAndSwapChain() instead");this.#d=e.GetAdapter(),this.#d.enable(this.#d.CULL_FACE),this.#d.frontFace(this.#d.CW),this.#d.enable(this.#d.DEPTH_TEST),this.#k=e.GetBackBufferFramebuffer(),this.#z=this.#d.createFramebuffer(),this.#B=new Map,this.#A=this.#d.getParameter(this.#d.MAX_COMBINED_TEXTURE_IMAGE_UNITS),this.#F=Array(this.#A).fill(!1),this.#C=null,this.#D=null,this.#G=!0,this.#H=!0,this.#I=null,this.#J=0,this.#K=[],this.#L=[],this.#M=[],this.#N=null,this.#O=57,this.#P=null,this.#Q=this.#d.getParameter(this.#d.MAX_VERTEX_TEXTURE_IMAGE_UNITS),this.#R=this.#d.getParameter(this.#d.MAX_VERTEX_UNIFORM_BLOCKS),this.#S=Array(this.#R).fill(null),this.#T=!0,this.#U=null,this.#Z=!0,this.#V=new D3D11_RECT(0,0,0,0),this.#$=!0,this.#W=null,this.#Y=!0,this.#X=new D3D11_RASTERIZER_DESC(3,3),this.#_=null,this.#aa=this.#d.getParameter(this.#d.MAX_TEXTURE_IMAGE_UNITS),this.#ab=this.#d.getParameter(this.#d.MAX_FRAGMENT_UNIFORM_BLOCKS),this.#ac=Array(this.#ab).fill(null),this.#ae=Array(this.#aa).fill(null),this.#ag=Array(this.#aa).fill(null),this.#ad=!0,this.#af=!0,this.#ah=!0,this.#ai=[],this.#aj=null,this.#ak=null,this.#al=0,this.#an=!0,this.#am=new D3D11_DEPTH_STENCIL_DESC}DirtyPipeline(){this.#H=!0,this.#G=!0,this.#T=!0,this.#Y=!0,this.#ad=!0,this.#af=!0,this.#ah=!0,this.#an=!0}ClearRenderTargetView(e,t){if(null==e)throw Error("Invalid RenderTargetView for clear");this.#ao(),this.#ap([e]);let[r,i]=this.#aq();this.#d.scissor(0,0,r,i),this.#d.clearColor(t[0],t[1],t[2],t[3]),this.#d.clear(this.#d.COLOR_BUFFER_BIT),this.#$=!0}ClearDepthStencilView(e,t,r,i){if(null==e)throw Error("Invalid DepthStencilView for clear");let s=!0&t,a=!0&t;if(!s&&!a)return;this.#ao(),this.#ar(e);let[n,l]=this.#aq();this.#d.scissor(0,0,n,l);let o=0;s&&(this.#d.clearDepth(r),o|=this.#d.DEPTH_BUFFER_BIT),a&&(this.#d.clearStencil(i),o|=this.#d.STENCIL_BUFFER_BIT),this.#d.clear(o),this.#$=!0}CopyResource(e,t){if(e==t)throw Error("Cannot copy resource when destination and source are the same resource");if(e instanceof ID3D11Buffer&&t instanceof ID3D11Buffer)throw Error("Buffer resource copying not yet implemented!");if(e instanceof ID3D11Texture2D&&t instanceof ID3D11Texture2D){let r=t.GetDesc(),i=e.GetDesc();if(1==e.Usage)throw Error("Cannot use an immutable resource as a copy destination");if(r.Width!=i.Width||r.Height!=i.Height||r.ArraySize!=i.ArraySize||r.MipLevels!=i.MipLevels)throw Error("Source and destination resources do not match in size or subresource count");if(r.Format!=i.Format)throw Error("Source and destination resources have different formats");for(let s=0;s<r.ArraySize;s++)for(let a=0;a<r.MipLevels;a++){let n=D3D11CalcSubresource(a,s,r.MipLevels);this.CopySubresourceRegion(e,n,0,0,0,t,n,null)}}else throw Error("Resources being copied do not match or are not yet implemented!")}CopySubresourceRegion(e,t,r,i,s,a,n,l=null){if(null!=l&&l.IsEmpty())return;let o=a.GetDesc(),h=e.GetDesc();if(1==h.Usage)throw Error("Cannot copy into an immutable resource");if(this.#as(o,n),this.#as(h,t),a==e&&n==t)throw Error("Cannot use the same subresource as both the source and destination of a copy");if(o.Format!=h.Format)throw Error("Source and destination must have same format when copying");let u=a instanceof ID3D11Buffer,c=e instanceof ID3D11Buffer;if(u&&!c||c&&!u)throw Error("Source and destination must be the same type (buffer or texture) when copying");if(a instanceof ID3D11Texture2D){if(0!=s)throw Error("Invalid destination Z value for 2D textures - must be zero");if(null!=l){let p=Math.floor(n/o.MipLevels),f=n-p*o.MipLevels,T=Math.pow(2,f),S=Math.max(1,Math.floor(h.Width/T)),D=Math.max(1,Math.floor(h.Height/T));if(l.Left<0||l.Right>S||l.Top<0||l.Bottom>D)throw Error("Source box extends outside source resource dimensions for mip level "+f)}}else throw Error("Given source resource is invalid or not yet implemented!");if(e instanceof ID3D11Texture2D){let d=Math.floor(t/h.MipLevels),m=t-d*h.MipLevels,E=h.ArraySize>1,g=(4&h.MiscFlags)==4,x=Math.pow(2,m),R=Math.max(1,Math.floor(h.Width/x)),_=Math.max(1,Math.floor(h.Height/x)),I=0,A=0,C=R,P=_;if(null!=l){I=l.Left,A=_-l.Bottom,C=l.Right-l.Left;let $=i+(P=l.Bottom-l.Top);i=_-$}if(r<0||i<0||r+C>R||i+P>_)throw Error("Destination offset extends outside destination resource dimensions for mip level "+m);if(g&&(d<0||d>=6))throw Error("Invalid subresource for cube map copying");if(this.#at(a,o,n),this.#an=!0,!E||g){let w=this.#d.TEXTURE_2D;if(g){switch(d){case 0:w=this.#d.TEXTURE_CUBE_MAP_POSITIVE_X;break;case 1:w=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_X;break;case 2:w=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Y;break;case 3:w=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Y;break;case 4:w=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Z;break;case 5:w=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Z}this.#d.bindTexture(this.#d.TEXTURE_CUBE_MAP,e.GetGLResource())}else this.#d.bindTexture(this.#d.TEXTURE_2D,e.GetGLResource());this.#d.copyTexSubImage2D(w,m,r,i,I,A,C,P)}else this.#d.bindTexture(this.#d.TEXTURE_2D_ARRAY,e.GetGLResource()),this.#d.copyTexSubImage3D(this.#d.TEXTURE_2D_ARRAY,m,r,i,d,I,A,C,P)}else throw Error("Given destination resource is invalid or not yet implemented!")}#as(ev,e1){let eN=D3D11CalcSubresource(ev.MipLevels-1,ev.ArraySize-1,ev.MipLevels);if(e1<0||e1>eN)throw Error("Invalid subresource index")}#at(eB,eG,eO){this.#d.bindFramebuffer(this.#d.READ_FRAMEBUFFER,this.#z);let eU=Math.floor(eO/eG.MipLevels),ek=eO-eU*eG.MipLevels,e0=(4&eG.MiscFlags)==4;if(!(eG.ArraySize>1)||e0){let eV=this.#d.TEXTURE_2D;if(e0)switch(eU){case 0:eV=this.#d.TEXTURE_CUBE_MAP_POSITIVE_X;break;case 1:eV=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_X;break;case 2:eV=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Y;break;case 3:eV=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Y;break;case 4:eV=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Z;break;case 5:eV=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Z;break;default:throw Error("Invalid subresource for cube map reading")}this.#d.framebufferTexture2D(this.#d.READ_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,eV,eB.GetGLResource(),ek)}else this.#d.framebufferTextureLayer(this.#d.READ_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,eB.GetGLResource(),ek,eU)}GenerateMips(e){let t=e.GetResource();if((1&t.GetDesc().MiscFlags)==0){t.Release();return}let r=t.GetGLTarget();this.#d.bindTexture(r,t.GetGLResource()),this.#d.generateMipmap(r),this.DirtyPipeline(),t.Release()}IASetInputLayout(e){this.#I=e,this.#H=!0}IASetIndexBuffer(e,t){this.#N=e,this.#O=t,null==e?this.#d.bindBuffer(this.#d.ELEMENT_ARRAY_BUFFER,null):this.#d.bindBuffer(this.#d.ELEMENT_ARRAY_BUFFER,this.#N.GetGLResource()),this.#H=!0}IASetPrimitiveTopology(e){this.#J=e}IASetVertexBuffers(e,t,r,i){this.#K=[],this.#L=[],this.#M=[];for(let s=0;s<t.length;s++)this.#K[e+s]=t[s],this.#L[e+s]=r[s],this.#M[e+s]=i[s];this.#H=!0}VSSetShader(e){this.#P=e,this.#G=!0}VSSetConstantBuffers(e,t){if(e+t.length<0||e+t.length>=this.#R)throw Error("Attempting to set VS constant buffers outside valid range");for(let r=0;r<t.length;r++)this.#S[r+e]=t[r];this.#T=!0}RSGetState(){return null==this.#W?null:(this.#W.AddRef(),this.#W)}RSSetState(e){this.#W=e,this.#Y=!0}RSGetScissorRects(){return[structuredClone(this.#V)]}RSSetScissorRects(e){this.#V=structuredClone(e[0]),this.#$=!0,this.#Y=!0}RSGetViewports(){return[structuredClone(this.#U)]}RSSetViewports(e){this.#U=structuredClone(e[0]),this.#Z=!0}PSSetShader(e){this.#_=e,this.#G=!0}PSSetConstantBuffers(e,t){if(e<0||e+t.length>=this.#ab)throw Error("Attempting to set PS constant buffers outside valid range");for(let r=0;r<t.length;r++)this.#ac[r+e]=t[r];this.#ad=!0}PSSetSamplers(e,t){if(e<0||e+t.length>=this.#aa)throw Error("Attempting to set PS samplers outside valid range");for(let r=0;r<t.length;r++)this.#ag[r+e]=t[r];this.#ah=!0}PSSetShaderResources(e,t){if(e<0||e+t.length>=this.#aa)throw Error("Attempting to set PS shader resources outside valid range");for(let r=0;r<t.length;r++)this.#ae[r+e]=t[r];this.#af=!0}OMSetDepthStencilState(e,t){this.#ak=e,this.#al=t,this.#an=!0}OMSetRenderTargets(e,t){if(null==e||0==e.length)throw Error("Unbinding render targets not yet implemented!");if(e.length>1)throw Error("Multiple render targets not yet implemented!");this.#ai=e.slice(),this.#aj=t,this.#an=!0,this.#Z=!0}OMGetRenderTargets(){return[this.#ai.slice(),this.#aj]}#au(){if(!this.#H||null==this.#I)return;let eX=this.#I.GetInputElementDescs(),e2=-1;for(let eH=0;eH<eX.length;eH++){let eW=eX[eH],ez=this.#av(eW.Format),e3=this.#aw(eW.Format),e6=eW.InputSlot;e6>=this.#K.length||(e6!=e2&&(this.#d.bindBuffer(this.#d.ARRAY_BUFFER,this.#K[e6].GetGLResource()),e2=e6),this.#d.enableVertexAttribArray(eH),this.#d.vertexAttribPointer(eH,e3,ez,!1,this.#L[e6],this.#M[e6]+eW.AlignedByteOffset))}this.#H=!1}#ax(){if(!this.#G)return;if(null==this.#P)throw Error("No vertex shader bound!");if(null==this.#_)throw Error("No pixel shader bound!");this.#B.has(this.#P)||this.#B.set(this.#P,new Map);let eq=this.#B.get(this.#P);if(!eq.has(this.#_)){let eY=Array(this.#Q),e4=Array(this.#Q),e7=Array(this.#aa),e5=Array(this.#aa);for(let ej=0;ej<this.#Q;ej++)eY[ej]=[],e4[ej]=[];for(let eZ=0;eZ<this.#aa;eZ++)e7[eZ]=[],e5[eZ]=[];eq.set(this.#_,{GLProgram:null,CBufferMap:Array(this.#R+this.#ab).fill(-1),TextureSamplerMap:{VSTextures:eY,VSSamplers:e4,PSTextures:e7,PSSamplers:e5}})}let eQ=eq.get(this.#_),eK=eQ.GLProgram;if(null==eK){eK=this.#ay(this.#P,this.#_),eQ.GLProgram=eK;let eJ=this.#P.GetCBuffers();for(let e9=0;e9<eJ.length;e9++){let te=eJ[e9];if(te.RegisterIndex<0||te.RegisterIndex>=this.#R)throw Error("Invalid register index for vertex shader constant buffer");let tt=this.#d.getUniformBlockIndex(eK,te.NameGL);eQ.CBufferMap[te.RegisterIndex]=tt}let tr=this.#_.GetCBuffers();for(let ti=0;ti<tr.length;ti++){let ts=tr[ti];if(ts.RegisterIndex<0||ts.RegisterIndex>=this.#ab)throw Error("Invalid register index for pixel shader constant buffer");let ta=this.#d.getUniformBlockIndex(eK,ts.NameGL),tn=ts.RegisterIndex+this.#R;eQ.CBufferMap[tn]=ta}let tl=0,to=this.#P.GetTextureSamplerCombinations();for(let th=0;th<to.length;th++){let tu=to[th];if(tl>=this.#Q)throw Error("Too many vertex shader texture/sampler combinations in use!");let tc=tu.Texture.RegisterIndex,tp=tu.Sampler.RegisterIndex,tf=this.#d.getUniformLocation(eK,tu.CombinedName);eQ.TextureSamplerMap.VSTextures[tc].push({TextureUnit:tl,UniformLocation:tf}),eQ.TextureSamplerMap.VSSamplers[tp].push(tl),tl++}let tT=this.#_.GetTextureSamplerCombinations();for(let tS=0;tS<tT.length;tS++){let tD=tT[tS];if(tl>=this.#aa)throw Error("Too many pixel shader texture/sampler combinations in use!");if(tl>=this.#A)throw Error("Too many total texture/sampler combinations in use!");let td=tD.Texture.RegisterIndex,tm=tD.Sampler.RegisterIndex,tE=this.#d.getUniformLocation(eK,tD.CombinedName);eQ.TextureSamplerMap.PSTextures[td].push({TextureUnit:tl,UniformLocation:tE}),eQ.TextureSamplerMap.PSSamplers[tm].push(tl),tl++}}this.#d.useProgram(eK),this.#C=eK,this.#D=eQ.CBufferMap,this.#E=eQ.TextureSamplerMap,this.#G=!1,this.#T=!0,this.#ad=!0,this.#ah=!0,this.#af=!0}#ay(tg,tx){let t8=this.#d.createProgram();this.#d.attachShader(t8,tg.GetGLShader()),this.#d.attachShader(t8,tx.GetGLShader()),this.#d.linkProgram(t8);if(!this.#d.getProgramParameter(t8,this.#d.LINK_STATUS))throw Error("Error linking shaders: "+this.#d.getProgramInfoLog(t8));this.#d.validateProgram(t8);if(!this.#d.getProgramParameter(t8,this.#d.VALIDATE_STATUS))throw Error("Error validating shaders: "+this.#d.getProgramInfoLog(t8));return t8}#az(){if(this.#T)for(let tR=0;tR<this.#S.length;tR++){let t_=this.#S[tR],tI=this.#D[tR];-1==tI||null==t_?this.#d.bindBufferBase(this.#d.UNIFORM_BUFFER,tR,null):(this.#d.bindBufferBase(this.#d.UNIFORM_BUFFER,tR,t_.GetGLResource()),this.#d.uniformBlockBinding(this.#C,tI,tR))}if(this.#ad)for(let tA=0;tA<this.#ac.length;tA++){let tC=this.#ac[tA],tP=tA+this.#R,t$=this.#D[tP];-1==t$||null==tC?this.#d.bindBufferBase(this.#d.UNIFORM_BUFFER,tP,null):(this.#d.bindBufferBase(this.#d.UNIFORM_BUFFER,tP,tC.GetGLResource()),this.#d.uniformBlockBinding(this.#C,t$,tP))}this.#T=!1,this.#ad=!1}#aA(){if(this.#F.fill(!1),this.#af)for(let tw=0;tw<this.#ae.length;tw++){let tL=this.#ae[tw];if(null==tL)continue;let tM=this.#E.PSTextures[tw];for(let tF=0;tF<tM.length;tF++){let tb=tL.GetResource(),ty=tb.GetGLTarget();this.#F[tM[tF].TextureUnit]=1!=tb.GetDesc().MipLevels,this.#d.activeTexture(this.#aB(tM[tF].TextureUnit)),this.#d.bindTexture(ty,tb.GetGLResource()),this.#d.uniform1i(tM[tF].UniformLocation,tM[tF].TextureUnit);let tv=tL.GetDesc(),t1=tv.MostDetailedMip,tN=tv.MostDetailedMip+tv.MipLevels-1;this.#d.texParameteri(ty,this.#d.TEXTURE_BASE_LEVEL,t1),this.#d.texParameteri(ty,this.#d.TEXTURE_MAX_LEVEL,tN),tb.Release()}}if(this.#ah)for(let tB=0;tB<this.#ag.length;tB++){let tG=this.#ag[tB];if(null==tG)continue;let tO=this.#E.PSSamplers[tB];for(let tU=0;tU<tO.length;tU++){let tk=this.#F[tO[tU]];this.#d.bindSampler(tO[tU],tG.GetGLSampler(tk))}}this.#ah=!1,this.#af=!1}#aB(t0){return this.#d.TEXTURE0+t0}#aq(){let tV=0,tX=0;if(null!=this.#ai){for(let t2=0;t2<this.#ai.length;t2++)if(null!=this.#ai[t2]){let tH=this.#ai[t2].GetResource();tV=tH.GetDesc().Width,tX=tH.GetDesc().Height,tH.Release();let tW=Math.pow(2,this.#ai[t2].GetDesc().MipSlice);tV=Math.max(1,Math.floor(tV/tW)),tX=Math.max(1,Math.floor(tX/tW));break}}if(0==tX&&null!=this.#aj){let tz=this.#aj.GetResource();tV=tz.GetDesc().Width,tX=tz.GetDesc().Height,tz.Release();let t3=Math.pow(2,this.#aj.GetDesc().MipSlice);tV=Math.max(1,Math.floor(tV/t3)),tX=Math.max(1,Math.floor(tX/t3))}return[tV,tX]}#aC(){let t6=0,tq=0;if((this.#Z||this.#$)&&([t6,tq]=this.#aq()),this.#Z&&null!=this.#U&&tq>0&&t6>0){let tY=tq-this.#U.Height;this.#d.viewport(this.#U.TopLeftX,tY-this.#U.TopLeftY,this.#U.Width,this.#U.Height),this.#d.depthRange(this.#U.MinDepth,this.#U.MaxDepth),this.#Z=!1}if(this.#$&&tq>0&&t6>0){let t4=this.#V.Right-this.#V.Left,t7=this.#V.Bottom-this.#V.Top,t5=tq-t7;this.#d.scissor(this.#V.Left,t5-this.#V.Top,t4,t7),this.#$=!1}if(!this.#Y)return;let tj;switch((tj=null==this.#W?this.#X:this.#W.GetDesc()).CullMode){case 3:this.#d.enable(this.#d.CULL_FACE),this.#d.cullFace(this.#d.BACK);break;case 2:this.#d.enable(this.#d.CULL_FACE),this.#d.cullFace(this.#d.FRONT);break;default:this.#d.disable(this.#d.CULL_FACE)}this.#d.frontFace(tj.FrontCounterClockwise?this.#d.CCW:this.#d.CW),0==tj.DepthBias&&0==tj.SlopeScaleDepthBias?this.#d.disable(this.#d.POLYGON_OFFSET_FILL):(this.#d.enable(this.#d.POLYGON_OFFSET_FILL),this.#d.polygonOffset(tj.SlopeScaleDepthBias,tj.DepthBias)),tj.ScissorEnable?this.#d.enable(this.#d.SCISSOR_TEST):this.#d.disable(this.#d.SCISSOR_TEST),this.#Y=!1}#aD(){if(this.#an){{let tZ;(tZ=null==this.#ak?this.#am:this.#ak.GetDesc()).DepthEnable?this.#d.enable(this.#d.DEPTH_TEST):this.#d.disable(this.#d.DEPTH_TEST),0==tZ.DepthWriteMask?this.#d.depthMask(!1):1==tZ.DepthWriteMask&&this.#d.depthMask(!0),this.#d.depthFunc(this.#aE(tZ.DepthFunc))}this.#ao(),this.#ap(this.#ai),this.#ar(this.#aj),this.#an=!1}}#ao(){this.#d.bindFramebuffer(this.#d.READ_FRAMEBUFFER,null),this.#d.bindFramebuffer(this.#d.DRAW_FRAMEBUFFER,this.#k)}#ap(tQ){if(tQ.length>0){let tK=tQ[0].GetResource(),tJ=tK.GetDesc(),t9=tQ[0].GetDesc();if(!(tK instanceof ID3D11Texture2D))throw Error("RTV texture type OM binding not yet implemented");if((4&tJ.MiscFlags)==4){let re;switch(t9.FirstArraySlice){case 0:re=this.#d.TEXTURE_CUBE_MAP_POSITIVE_X;break;case 1:re=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_X;break;case 2:re=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Y;break;case 3:re=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Y;break;case 4:re=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Z;break;case 5:re=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Z;break;default:throw Error("Only array slices 0-5 are valid for texture cube RTVs")}this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,re,tK.GetGLResource(),t9.MipSlice)}else tJ.ArraySize>1?this.#d.framebufferTextureLayer(this.#d.DRAW_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,tK.GetGLResource(),t9.MipSlice,t9.FirstArraySlice):this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,this.#d.TEXTURE_2D,tK.GetGLResource(),t9.MipSlice);tK.Release()}}#ar(rt){if(null==rt)this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.DEPTH_STENCIL_ATTACHMENT,this.#d.TEXTURE_2D,null,0),this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.DEPTH_ATTACHMENT,this.#d.TEXTURE_2D,null,0);else{let rr=rt.GetResource(),ri=rt.GetDesc(),rs=45==ri.Format,ra=rs?this.#d.DEPTH_STENCIL_ATTACHMENT:this.#d.DEPTH_ATTACHMENT;rs||this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.DEPTH_STENCIL_ATTACHMENT,this.#d.TEXTURE_2D,null,0),this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,ra,this.#d.TEXTURE_2D,rr.GetGLResource(),ri.MipSlice),rr.Release()}}Draw(e,t){this.#au(),this.#ax(),this.#az(),this.#aA(),this.#aD(),this.#aC(),this.#d.drawArrays(this.#aF(this.#J),t,e)}DrawIndexed(e,t){this.#au(),this.#ax(),this.#az(),this.#aA(),this.#aD(),this.#aC();let r=this.#d.UNSIGNED_SHORT;switch(this.#O){case 57:r=this.#d.UNSIGNED_SHORT;break;case 42:r=this.#d.UNSIGNED_INT}this.#d.drawElements(this.#aF(this.#J),e,r,t)}Flush(){this.#d.finish()}UpdateSubresource(e,t,r,i,s,a){if(e instanceof ID3D11Buffer){if(1==e.GetDesc().Usage)throw Error("Cannot update immutable resource");if(0!=t)throw Error("Invalid subresource ("+t+") used for buffer update");if(null!=r)throw Error("Cannot update a box within a buffer resource");this.#d.bindBuffer(this.#d.UNIFORM_BUFFER,e.GetGLResource()),this.#d.bufferSubData(this.#d.UNIFORM_BUFFER,0,i)}else throw Error("Updating non-buffer resource not yet implemented!")}#av(rn){return this.#d.FLOAT}#aw(rl){switch(rl){case 41:return 1;case 16:return 2;case 6:return 3;case 2:return 4;default:return 0}}#aE(ro){switch(ro){case 1:return this.#d.NEVER;case 2:return this.#d.LESS;case 3:return this.#d.EQUAL;case 4:return this.#d.LEQUAL;case 5:return this.#d.GREATER;case 6:return this.#d.NOTEQUAL;case 7:return this.#d.GEQUAL;case 8:return this.#d.ALWAYS;default:throw Error("Invalid comparison function")}}#aF(rh){switch(rh){case 1:return this.#d.POINTS;case 2:return this.#d.LINES;case 3:return this.#d.LINE_STRIP;case 4:case 0:default:return this.#d.TRIANGLES;case 5:return this.#d.TRIANGLE_STRIP}}}class IDXGISwapChain extends IUnknown{#aG;#c;#d;#aH;#k;constructor(e,t){if(super(),new.target===IDXGISwapChain)throw Error("Cannot instantiate IDXGISwapChain objects directly.  Use DXGICreateSwapChain() or D3D11CreateDeviceAndSwapChain() instead.");if(this.#aG=t.Copy(),this.#c=e,this.#d=e.GetAdapter(),this.#aG.Width<=0)throw Error("Swap Chain width must be greater than zero");if(this.#aG.Height<=0)throw Error("Swap Chain height must be greater than zero");if(28!=this.#aG.Format&&29!=this.#aG.Format)throw Error("Invalid Swap Chain format");this.#d.canvas.width=this.#d.canvas.clientWidth,this.#d.canvas.height=this.#d.canvas.clientHeight,this.#aI(),this.#k=e.GetBackBufferFramebuffer()}GetDesc(){return structuredClone(this.#aG)}GetBuffer(){return this.#aH.AddRef(),this.#aH}Present(){this.#d.bindFramebuffer(this.#d.FRAMEBUFFER,null),this.#d.bindFramebuffer(this.#d.READ_FRAMEBUFFER,this.#k),this.#d.framebufferTexture2D(this.#d.READ_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,this.#d.TEXTURE_2D,this.#aH.GetGLResource(),0);let e=this.#aG.Width,t=this.#aG.Height;this.#d.blitFramebuffer(0,0,e,t,0,0,e,t,this.#d.COLOR_BUFFER_BIT,this.#d.NEAREST),this.#d.flush()}Release(){super.Release(),0>=this.GetRef()&&this.#aH.Release()}ResizeBuffers(e,t,r=0){if(0==r&&(r=this.#aG.Format),this.#aG.Width!=e||this.#aG.Height!=t||this.#aG.Format!=r){if(e<=0)throw Error("Swap Chain width must be greater than zero");if(t<=0)throw Error("Swap Chain height must be greater than zero");if(28!=r&&29!=r)throw Error("Invalid Swap Chain format");if(this.#d.canvas.width=this.#d.canvas.clientWidth,this.#d.canvas.height=this.#d.canvas.clientHeight,this.#aG.Width=e,this.#aG.Height=t,this.#aG.Format=r,this.#aH.Release(),0!=this.#aH.GetRef())throw Error("One or more outstanding back buffer references exist; cannot resize");this.#aJ(),this.#aI()}}#aI(){let ru=new D3D11_TEXTURE2D_DESC(this.#aG.Width,this.#aG.Height,1,1,this.#aG.Format,new DXGI_SAMPLE_DESC(1,0),0,32,0,0);this.#aH=this.#c.CreateTexture2D(ru,null)}#aJ(){this.#d.bindFramebuffer(this.#d.DRAW_FRAMEBUFFER,this.#k),this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,this.#d.TEXTURE_2D,null,0),this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.DEPTH_ATTACHMENT,this.#d.TEXTURE_2D,null,0),this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.DEPTH_STENCIL_ATTACHMENT,this.#d.TEXTURE_2D,null,0)}#aK(){let rc=["Color","Depth","DepthStencil"],rp=[this.#d.COLOR_ATTACHMENT0,this.#d.DEPTH_ATTACHMENT,this.#d.DEPTH_STENCIL_ATTACHMENT],rf=["Read","Draw"],rT=[this.#d.READ_FRAMEBUFFER,this.#d.DRAW_FRAMEBUFFER],rS=[this.#d.READ_FRAMEBUFFER_BINDING,this.#d.DRAW_FRAMEBUFFER_BINDING];for(let rD=0;rD<rT.length;rD++){let rd=this.#d.getParameter(rS[rD]);for(let rm=0;rm<rp.length;rm++){let rE="NULL";null!=rd&&(rE=this.#d.getFramebufferAttachmentParameter(rT[rD],rp[rm],this.#d.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME)),console.log("Target: "+rf[rD]+" | Attachment: "+rc[rm]),console.log(rE),console.log(" ")}}console.log("---")}}class ID3D11DepthStencilState extends ID3D11DeviceChild{#aG;constructor(e,t){if(super(e),new.target===ID3D11DepthStencilState)throw e.Release(),Error("Cannot instantiate ID3D11DepthStencilState objects - use device.CreateDepthStencilState() instead");this.#aG=t.Copy()}GetDesc(){return this.#aG.Copy()}}class ID3D11InputLayout extends ID3D11DeviceChild{#aL;constructor(e,t){if(super(e),new.target===ID3D11InputLayout)throw e.Release(),Error("Cannot instantiate ID3D11InputLayout objects - use device.CreateInputLayout() instead");this.#aL=this.#aM(t)}#aM(rg){let rx=[];for(let r8=0;r8<rg.length;r8++)rx[r8]=rg[r8].Copy();return rx}GetInputElementDescs(){return this.#aM(this.#aL)}}class ID3D11PixelShader extends ID3D11DeviceChild{#aN;#aO;constructor(e,t,r){if(super(e),new.target===ID3D11PixelShader)throw e.Release(),Error("Cannot instantiate ID3D11PixelShader objects - use device.CreatePixelShader() instead");this.#aN=t,this.#aO=r}GetGLShader(){return this.#aN}GetCBuffers(){return this.#aO.GetCBuffers()}GetTextureSamplerCombinations(){return this.#aO.GetTextureSamplerCombinations()}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteShader(this.#aN),e.Release()}}}class ID3D11RasterizerState extends ID3D11DeviceChild{#aG;constructor(e,t){if(super(e),new.target===ID3D11RasterizerState)throw e.Release(),Error("Cannot instantiate ID3D11RasterizerState objects - use device.CreateRasterizerState() instead");this.#aG=t.Copy()}GetDesc(){return this.#aG.Copy()}}class ID3D11SamplerState extends ID3D11DeviceChild{#aG;#aP;#aQ;constructor(e,t){if(super(e),new.target===ID3D11SamplerState)throw e.Release(),Error("Cannot instantiate ID3D11SamplerState objects - use device.CreateSamplerState() instead");this.#aG=t.Copy();let r=e.GetAdapter();this.#aP=r.createSampler(),this.#aQ=r.createSampler(),this.#aR(e,this.#aP,t,!1),this.#aR(e,this.#aQ,t,!0)}GetDesc(){return this.#aG.Copy()}GetGLSampler(e){return e?this.#aQ:this.#aP}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteSampler(this.#aP),e.GetAdapter().deleteSampler(this.#aQ),e.Release()}}#aR(rR,r_,rI,rA){let rC=rR.GetAdapter();rC.samplerParameteri(r_,rC.TEXTURE_MAG_FILTER,this.#aS(rC,rI.Filter)),rC.samplerParameteri(r_,rC.TEXTURE_MIN_FILTER,this.#aT(rC,rI.Filter,rA)),rC.samplerParameteri(r_,rC.TEXTURE_WRAP_S,this.#aU(rC,rI.AddressU)),rC.samplerParameteri(r_,rC.TEXTURE_WRAP_T,this.#aU(rC,rI.AddressV)),rC.samplerParameteri(r_,rC.TEXTURE_WRAP_R,this.#aU(rC,rI.AddressW)),rC.samplerParameterf(r_,rC.TEXTURE_MIN_LOD,rI.MinLOD),rC.samplerParameterf(r_,rC.TEXTURE_MAX_LOD,rI.MaxLOD),this.#aV(rI.Filter)&&(rC.samplerParameteri(r_,rC.TEXTURE_COMPARE_MODE,rC.COMPARE_REF_TO_TEXTURE),rC.samplerParameteri(r_,rC.TEXTURE_COMPARE_FUNC,this.#aE(rC,rI.ComparisonFunc)));let rP=rR.CheckFeatureSupport(0);this.#aW(rI.Filter)&&null!=rP&&rC.samplerParameteri(r_,rP.TEXTURE_MAX_ANISOTROPY_EXT,rI.MaxAnisotropy)}#aS(r$,rw){return(4&rw)==4?r$.LINEAR:r$.NEAREST}#aT(rL,rM,rF){let rb=(16&rM)==16?rL.LINEAR:rL.NEAREST,ry=(1&rM)==1?rL.LINEAR:rL.NEAREST;if(!rF)return rb;if(rb==rL.LINEAR&&ry==rL.LINEAR)return rL.LINEAR_MIPMAP_LINEAR;if(rb==rL.LINEAR&&ry==rL.NEAREST)return rL.LINEAR_MIPMAP_NEAREST;if(rb==rL.NEAREST&&ry==rL.LINEAR)return rL.NEAREST_MIPMAP_LINEAR;if(rb==rL.NEAREST&&ry==rL.NEAREST)return rL.NEAREST_MIPMAP_NEAREST;throw Error("Invalid filter")}#aW(rv){return(64&rv)==64}#aV(r1){return(128&r1)==128}#aU(rN,rB){switch(rB){case 1:return rN.REPEAT;case 2:return rN.MIRRORED_REPEAT;case 3:return rN.CLAMP_TO_EDGE;default:throw Error("Invalid address mode")}}#aE(rG,rO){switch(rO){case 1:return rG.NEVER;case 2:return rG.LESS;case 3:return rG.EQUAL;case 4:return rG.LEQUAL;case 5:return rG.GREATER;case 6:return rG.NOTEQUAL;case 7:return rG.GEQUAL;case 8:return rG.ALWAYS;default:throw Error("Invalid comparison function")}}}class ID3D11VertexShader extends ID3D11DeviceChild{#aN;#aO;constructor(e,t,r){if(super(e),new.target===ID3D11VertexShader)throw e.Release(),Error("Cannot instantiate ID3D11VertexShader objects - use device.CreateVertexShader() instead");this.#aN=t,this.#aO=r}GetGLShader(){return this.#aN}GetCBuffers(){return this.#aO.GetCBuffers()}GetTextureSamplerCombinations(){return this.#aO.GetTextureSamplerCombinations()}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteShader(this.#aN),e.Release()}}}class ID3D11Resource extends ID3D11DeviceChild{#aG;#aX;#aY;constructor(e,t,r,i){if(super(e),new.target===ID3D11Buffer)throw this.Release(),Error("Cannot instantiate ID3D11Resource objects - use corresponding Create() functions of an ID3D11Device object instead");this.#aG=t.Copy(),this.#aX=r,this.#aY=i}GetDesc(){return this.#aG.Copy()}GetGLTarget(){return this.#aX}GetGLResource(){return this.#aY}}class ID3D11Buffer extends ID3D11Resource{constructor(e,t,r,i){if(super(e,t,r,i),new.target===ID3D11Buffer)throw this.Release(),Error("Cannot instantiate ID3D11Buffer objects - use device.CreateBuffer() instead")}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteBuffer(this.GetGLResource()),e.Release()}}}class ID3D11Texture1D extends ID3D11Resource{constructor(e,t,r,i){if(super(e,t,r,i),new.target===ID3D11Texture1D)throw this.Release(),Error("Cannot instantiate ID3D11Texture1D objects - use device.CreateTexture1D() instead")}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteTexture(this.GetGLResource()),e.Release()}}}class ID3D11Texture2D extends ID3D11Resource{constructor(e,t,r,i){if(super(e,t,r,i),new.target===ID3D11Texture2D)throw this.Release(),Error("Cannot instantiate ID3D11Texture2D objects - use device.CreateTexture2D() instead")}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteTexture(this.GetGLResource()),e.Release()}}}class ID3D11Texture3D extends ID3D11Resource{constructor(e,t,r,i){if(super(e,t,r,i),new.target===ID3D11Texture3D)throw this.Release(),Error("Cannot instantiate ID3D11Texture3D objects - use device.CreateTexture3D() instead")}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteTexture(this.GetGLResource()),e.Release()}}}class ID3D11View extends ID3D11DeviceChild{#aZ;#aG;constructor(e,t,r){if(super(e),new.target===ID3D11View)throw e.Release(),Error("Cannot instantiate ID3D11View objects - use corresponding Create___View() functions of an ID3D11Device object instead");this.#aZ=t,this.#aG=r.Copy(),this.#aZ.AddRef()}GetDesc(){return this.#aG.Copy()}GetResource(){return this.#aZ.AddRef(),this.#aZ}Release(){super.Release(),0>=this.GetRef()&&this.#aZ.Release()}}class ID3D11DepthStencilView extends ID3D11View{constructor(e,t,r){if(super(e,t,r),new.target===ID3D11DepthStencilView)throw e.Release(),Error("Cannot instantiate ID3D11DepthStencilView objects - use device.CreateDepthStencilView() instead")}}class ID3D11RenderTargetView extends ID3D11View{constructor(e,t,r){if(super(e,t,r),new.target===ID3D11RenderTargetView)throw e.Release(),Error("Cannot instantiate ID3D11RenderTargetView objects - use device.CreateRenderTargetView() instead")}}class ID3D11ShaderResourceView extends ID3D11View{constructor(e,t,r){if(super(e,t,r),new.target===ID3D11ShaderResourceView)throw e.Release(),Error("Cannot instantiate ID3D11ShaderResourceView objects - use device.CreateShaderResourceView() instead")}}const TokenUnknown=0,TokenWhiteSpace=1,TokenCommentMultiline=2,TokenCommentSingle=3,TokenOperator=4,TokenIdentifier=5,TokenNumericLiteral=6,TokenPeriod=7,TokenComma=8,TokenColon=9,TokenSemicolon=10,TokenScopeLeft=11,TokenScopeRight=12,TokenParenLeft=13,TokenParenRight=14,TokenBracketLeft=15,TokenBracketRight=16,ShaderTypeVertex=0,ShaderTypePixel=1,PrefixAttribute="_attrib_",PrefixVarying="_vary_",PrefixVSInput="_vs_input_",PrefixVSOutput="_vs_output_",PrefixPSInput="_ps_input_",PrefixPSOutput="_ps_output_",PrefixVSCBuffer="_vs_",PrefixPSCBuffer="_ps_",PSOutputVariable="_sv_target_",ShaderLanguageHLSL=0,ShaderLanguageGLSL=1,HLSLDataTypeConversion={void:"void",bool:"bool",bool1:"bool",bool2:"bvec2",bool3:"bvec3",bool4:"bvec4",int:"int",int1:"int",int2:"ivec2",int3:"ivec3",int4:"ivec4",uint:"uint",uint1:"uint",uint2:"uvec2",uint3:"uvec3",uint4:"uvec4",dword:"uint",dword1:"uint",dword2:"uvec2",dword3:"uvec3",dword4:"uvec4",half:"float",half1:"float",half2:"vec2",half3:"vec3",half4:"vec4",float:"float",float1:"float",float2:"vec2",float3:"vec3",float4:"vec4",double:"float",double1:"float",double2:"vec2",double3:"vec3",double4:"vec4",float2x2:"mat2x2",float2x3:"mat2x3",float2x4:"mat2x4",float3x2:"mat3x2",float3x3:"mat3x3",float3x4:"mat3x4",float4x2:"mat4x2",float4x3:"mat4x3",float4x4:"mat4x4",matrix:"mat4x4"},HLSLMatrixElementConversion={_m00:"[0][0]",_m01:"[1][0]",_m02:"[2][0]",_m03:"[3][0]",_m10:"[0][1]",_m11:"[1][1]",_m12:"[2][1]",_m13:"[3][1]",_m20:"[0][2]",_m21:"[1][2]",_m22:"[2][2]",_m23:"[3][2]",_m30:"[0][3]",_m31:"[1][3]",_m32:"[2][3]",_m33:"[3][3]",_11:"[0][0]",_12:"[1][0]",_13:"[2][0]",_14:"[3][0]",_21:"[0][1]",_22:"[1][1]",_23:"[2][1]",_24:"[3][1]",_31:"[0][2]",_32:"[1][2]",_33:"[2][2]",_34:"[3][2]",_41:"[0][3]",_42:"[1][3]",_43:"[2][3]",_44:"[3][3]"},HLSLMatrixConstructorConversion={float2x2:"float2x2_tr",float3x3:"float3x3_tr",float4x4:"float4x4_tr",matrix:"float4x4_tr"},HLSLReservedWordConversion={$Global:"_global_cbuffer",input:"_input",output:"_output",pow:"pow_hlsl",frac:"fract"},HLSLTextureSampleConversion={Sample:"texture",SampleLevel:"textureLod"};class TokenIterator{#a$;#a_;constructor(e){this.#a$=e,this.#a_=-1}MoveNext(){return this.#a_++,this.#a_<this.#a$.length}Current(){return this.#a_>=this.#a$.length?null:this.#a$[this.#a_]}More(){return this.#a_<this.#a$.length-1}Position(){return this.#a_}GetRange(e,t){if(e<0||t>=this.#a$.length+1||t<=e)throw Error("Invalid range for token iterator");return this.#a$.slice(e,t)}PeekPrev(){return this.#a0(-1)}PeekNext(){return this.#a0(1)}PeekNextNext(){return this.#a0(2)}#a0(rU){let rk=this.#a_+rU;return rk<0||rk>=this.#a$.length?null:this.#a$[rk]}}class HLSL{#aO;#a1;#a$;#a2;#a3;#a4;#a5;#a6;#a7;#a8;#a9;Rules=[{Type:1,Pattern:/^\s+/},{Type:2,Pattern:/^\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\//},{Type:3,Pattern:/^\/\/.*/},{Type:4,Pattern:/^((<<=)|(>>=))/},{Type:4,Pattern:/^((\+=)|(-=)|(\*=)|(\/=)|(%=)|(<<)|(>>)|(&=)|(\|=)|(\^=)|(&&)|(\|\|)|(==)|(!=)|(<=)|(>=)|(\+\+)|(--))/},{Type:4,Pattern:/^[\+\-\*\/\%\=\~\&\|\^\?\<\>\!]/},{Type:5,Pattern:/^[_A-Za-z][_A-Za-z0-9]*/},{Type:6,Pattern:/^[+-]?(([0][x][a-fA-F0-9]+([uU][lL])?([lL][uU])?[uU]?[lL]?)|(([0-9]*[.][0-9]+([eE][+-]?[0-9]+)?[fFlLhH]?)|([0-9]+[.]([eE][+-]?[0-9]+)?[fFlLhH])|([0-9]+[.])|([0-9]+([uU][lL])?([lL][uU])?[uU]?[lL]?)))/},{Type:11,Pattern:/^[{]/},{Type:12,Pattern:/^[}]/},{Type:13,Pattern:/^[(]/},{Type:14,Pattern:/^[)]/},{Type:15,Pattern:/^[\[]/},{Type:16,Pattern:/^[\]]/},{Type:10,Pattern:/^[;]/},{Type:9,Pattern:/^[:]/},{Type:8,Pattern:/^[,]/},{Type:7,Pattern:/^[\.]/},{Type:0,Pattern:/^./}];static TranslateToGLSL(e){return HLSLDataTypeConversion.hasOwnProperty(e)?HLSLDataTypeConversion[e]:HLSLReservedWordConversion.hasOwnProperty(e)?HLSLReservedWordConversion[e]:e}static DataTypeFromLiteralToken(e){if(6!=e.Type)throw Error("Invalid token for data type extraction");let t=e.Text.charAt(e.Text.length-1).toLowerCase(),r=1==e.Text.length?"":e.Text.charAt(e.Text.length-2).toLowerCase();if(e.Text.indexOf(".")>=0)switch(t){case"h":return"half";case"l":return"double";default:return"float"}return"u"==t||"u"==r?"uint":"int"}static async LoadTextFromURL(e,t=!0){let r=await fetch(e),i=await r.text();if(!t)return i;let s={},a="#include";for(;;){let n=i.indexOf(a);if(-1==n)break;let l=-1,o=-1;if(-1==(l=i.indexOf('"',n+a.length)))throw Error("Error with #include; expected start quote");if(-1==(o=i.indexOf('"',l+1)))throw Error("Error with #include; expected end quote");let h=i.substring(l+1,o),u="";s.hasOwnProperty(h)||(s[h]=!0,u=await (r=await fetch(h)).text()),i=i.substring(0,n)+u+i.substring(o+1)}return i}constructor(e,t){if(t!=ShaderTypeVertex&&t!=ShaderTypePixel)throw Error("Invalid shader type specified");this.#aO=e.repeat(1),this.#a1=t,this.#ba(),this.#bb()}GetCBuffers(){return this.#a3.slice()}GetTextureSamplerCombinations(){return this.#a6.slice()}#ba(){this.#a$=[];let r0=1,rV=this.#aO.repeat(1);for(;rV.length>0;){let rX=!1;for(let r2=0;r2<this.Rules.length;r2++){let rH=RegExp(this.Rules[r2].Pattern,"g"),rW=rH.exec(rV);if(null!=rW){if(rX=!0,r0+=(rW[0].match(/\n/g)||[]).length,2!=this.Rules[r2].Type&&3!=this.Rules[r2].Type&&1!=this.Rules[r2].Type){let rz={Type:this.Rules[r2].Type,Text:rW[0],Line:r0};this.#a$.push(rz)}rV=rV.substring(rH.lastIndex);break}}if(!1==rX){alert("problem");break}}}#bb(){this.#a2=[],this.#a3=[],this.#a4=[],this.#a5=[],this.#a6=[],this.#a7=[],this.#a8=[],this.#a9=null;let r3=new TokenIterator(this.#a$),r6="";switch(this.#a1){case ShaderTypePixel:r6=PrefixPSCBuffer;break;case ShaderTypeVertex:r6=PrefixVSCBuffer}let rq=new ShaderElementCBuffer("$Global",r6+"global_cbuffer",-1),rY=new ScopeStack;for(rY.PushScope(),r3.MoveNext();r3.More();){let r4=r3.Current();switch(r4.Text){case"const":let r7=this.#bc(r3);this.#a8.push(r7),rY.AddVarStatement(r7);break;case";":r3.MoveNext();break;case"struct":this.#a2.push(this.#bd(r3));break;case"cbuffer":this.#a3.push(this.#be(r3,rY));break;case"SamplerState":case"SamplerComparisonState":this.#a5.push(this.#bf(r3));break;case"Texture1D":case"Texture1DArray":case"Texture2D":case"Texture2DArray":case"TextureCube":case"TextureCubeArray":case"Texture3D":this.#a4.push(this.#bg(r3));break;case"Texture2DMS":case"Texture2DMSArray":throw new ParseError(r3.Line,"Not currently handling multisampled textures");default:if(!this.#bh(r4.Text)||5!=r3.PeekNext().Type)throw new ParseError(r4,"Invalid token");if(!this.#bi(r3,rq))throw Error("Error parsing global variable or function")}}if(null==this.#a9)throw new ParseError(null,"'main': entry point not found");rq.Members.length>0&&this.#a3.push(rq),this.#bj(this.#a3,999),this.#bj(this.#a5,999),this.#bj(this.#a4,999)}#bk(r5,...rj){for(let rZ of rj)if(r5.Current().Type==rZ)return r5.MoveNext(),!0;return!1}#bl(rQ,...rK){for(let rJ of rK)if(5==rQ.Current().Type&&rQ.Current().Text==rJ)return rQ.MoveNext(),!0;return!1}#bm(r9,...ie){for(let it of ie)if(4==r9.Current().Type&&r9.Current().Text==it)return r9.MoveNext(),!0;return!1}#bn(ir){let ii=ir.Current();return!!this.#bh(ii.Text)&&(ir.MoveNext(),!0)}#bo(is,ia){if(this.#bk(is,ia))return!0;throw Error("Error parsing HLSL on line "+is.Current().Line)}#bp(il,io){if(this.#bm(il,io))return!0;throw Error("Error parsing HLSL on line "+il.Current().Line)}#bq(ih,iu){if(this.#bl(ih,iu))return!0;throw Error("Error parsing HLSL on line "+ih.Current().Line)}#br(ic){let ip=ic.Current();if(this.#bh(ip.Text))return ic.MoveNext(),!0;throw Error("Error parsing HLSL on line "+ic.Current().Line)}#bs(iT){for(let iS=0;iS<this.#a2.length;iS++)if(this.#a2[iS].Name==iT)return!0;return!1}#bt(iD){for(let id=0;id<this.#a4.length;id++)if(this.#a4[id].Name==iD)return!0;return!1}#bu(im){for(let iE=0;iE<this.#a4.length;iE++)if(this.#a4[iE].Name==im)return this.#a4[iE];return null}#bv(ig){for(let ix=0;ix<this.#a5.length;ix++)if(this.#a5[ix].Name==ig)return!0;return!1}#bw(i8){for(let iR=0;iR<this.#a5.length;iR++)if(this.#a5[iR].Name==i8)return this.#a5[iR];return null}#bh(i_){let iI=this.#bs(i_),iA=HLSLDataTypeConversion.hasOwnProperty(i_);return iI||iA}#bx(iC){return HLSLReservedWordConversion.hasOwnProperty(iC)}#bd(iP){let i$=null,iw=[];this.#bq(iP,"struct"),this.#bo(iP,5),i$=iP.PeekPrev().Text,this.#bo(iP,11);do{if(12==iP.Current().Type)break;iw.push(this.#by(iP,!1,!0,!0,!1))}while(this.#bk(iP,10));return this.#bo(iP,12),this.#bo(iP,10),new ShaderElementStruct(i$,iw)}#bz(iL,iM){if(!this.#bk(iL,9))return -1;this.#bq(iL,"register"),this.#bo(iL,13),this.#bo(iL,5);let iF=iL.PeekPrev().Text;if(!iF.startsWith(iM))throw new ParseError(iL.PeekPrev(),"Invalid register type");let ib=parseInt(iF.substring(1));if(isNaN(ib))throw new ParseError(iL.PeekPrev(),"Invalid register index");return this.#bo(iL,14),ib}#be(iy,iv){let i1=null,iN=-1,iB=[];this.#bq(iy,"cbuffer"),this.#bo(iy,5),i1=iy.PeekPrev().Text,iN=this.#bz(iy,"b"),this.#bo(iy,11);do{if(12==iy.Current().Type)break;let iG=this.#by(iy,!1,!1,!1,!1);iB.push(iG),iv.AddVar(iG)}while(this.#bk(iy,10));this.#bo(iy,12);let iO="";switch(this.#a1){case ShaderTypePixel:iO=PrefixPSCBuffer;break;case ShaderTypeVertex:iO=PrefixVSCBuffer}let iU=HLSL.TranslateToGLSL(iO+i1);return new ShaderElementCBuffer(i1,iU,iN,iB)}#by(ik,i0,iV,iX,i2){let iH=[],iW=[],iz=null,i3=null,i6=null,iq=null,iY=null,i4=null,i7=null,i5=!1;do i5=!1,this.#bl(ik,"in")&&(iW.push("in"),i5=!0),this.#bl(ik,"inout")&&(iW.push("inout"),i5=!0),this.#bl(ik,"out")&&(iW.push("out"),i5=!0),this.#bl(ik,"uniform")&&(iW.push("uniform"),i5=!0),this.#bl(ik,"linear")&&(iH.push("linear"),i5=!0),this.#bl(ik,"centroid")&&(iH.push("centroid"),i5=!0),this.#bl(ik,"nointerpolation")&&(iH.push("nointerpolation"),i5=!0),this.#bl(ik,"noperspective")&&(iH.push("noperspective"),i5=!0),this.#bl(ik,"sample")&&(iH.push("sample"),i5=!0);while(i5);if(!i0&&iW.length>0)throw new ParseError(ik.PeekPrev(),"Input modifier not allowed here");if(iW.length>1)throw new ParseError(ik.PeekPrev(),"Multiple input modifiers found.");if(!iV&&iH.length>0)throw new ParseError(ik.PeekPrev(),"Interpolation modifier not allowed here");if(this.#br(ik),i3=ik.PeekPrev(),iz=ik.PeekPrev().Text,this.#bo(ik,5),iq=ik.PeekPrev(),i6=ik.PeekPrev().Text,this.#bk(ik,15)&&(i4=this.#bA(ik),this.#bo(ik,16)),this.#bk(ik,9)){if(!iX)throw new ParseError(ik.PeekPrev(),"Semantic not allowed here.");this.#bo(ik,5),iY=ik.PeekPrev().Text}if(this.#bm(ik,"=")){if(!i2)throw new ParseError(ik.PeekPrev(),"Initialization not allowed here.");i7=this.#bA(ik)}return new VarDec(!1,i3,iq,i4,i7,1==iW.length?iW[0]:null,iH,iY)}#bg(ij){let iZ=null,iQ=null,iK=-1;if(this.#bo(ij,5),iZ=ij.PeekPrev().Text,this.#bo(ij,5),iQ=ij.PeekPrev().Text,(iK=this.#bz(ij,"t"))>=0){for(let iJ=0;iJ<this.#a4.length;iJ++)if(this.#a4[iJ].RegisterIndex==iK)throw new ParseError(ij.PeekPrev(),"Duplicate texture register: t"+iK)}return this.#bo(ij,10),new ShaderElementTexture(iZ,iQ,iK)}#bf(i9){let se=null,st=null,sr=-1;if(this.#bo(i9,5),se=i9.PeekPrev().Text,this.#bo(i9,5),st=i9.PeekPrev().Text,(sr=this.#bz(i9,"s"))>=0){for(let si=0;si<this.#a5.length;si++)if(this.#a5[si].RegisterIndex==sr)throw new ParseError(i9.PeekPrev(),"Duplicate sampler register: s"+sr)}return this.#bo(i9,10),new ShaderElementSampler(se,st,sr)}#bi(ss,sa){this.#br(ss);let sn=ss.PeekPrev(),sl=ss.PeekPrev().Text;this.#bo(ss,5);let so=ss.PeekPrev(),sh=ss.PeekPrev().Text;if(this.#bk(ss,13)){let su=[];do{if(14==ss.Current().Type)break;su.push(this.#by(ss,!0,!0,!0,!0))}while(this.#bk(ss,8));this.#bo(ss,14);let sc=null;this.#bk(ss,9)&&(this.#bo(ss,5),sc=ss.PeekPrev().Text),this.#bo(ss,11);let sp=this.#bB(ss);this.#bo(ss,12);let sf=new ShaderElementFunction(sl,sh,sc,su,sp,null);if("main"==sh){if(null!=this.#a9)throw new ParseError(ss.PeekPrev(),"Multiple main functions detected");this.#a9=sf}else this.#a7.push(sf);return!0}return!!this.#bk(ss,10)&&(sa.Members.push(new VarDec(!1,sn,so,null,null)),!0)}#bB(sT){let sS=[];for(;12!=sT.Current().Type;)sS.push(this.#bC(sT));return sS}#bC(sD){if(this.#bk(sD,11))return this.#bD(sD);if(this.#bl(sD,"do"))return this.#bE(sD);if(this.#bl(sD,"for"))return this.#bF(sD);if(this.#bl(sD,"if"))return this.#bG(sD);if(this.#bl(sD,"return"))return this.#bH(sD);if(this.#bl(sD,"switch"))return this.#bI(sD);if(this.#bh(sD.Current().Text)||"const"==sD.Current().Text)return this.#bc(sD);if(this.#bl(sD,"while"))return this.#bJ(sD);if(this.#bl(sD,"break")||this.#bl(sD,"continue")||this.#bl(sD,"discard")){let sd=sD.PeekPrev();return this.#bo(sD,10),new StatementJump(sd)}return this.#bK(sD)}#bD(sm){let sE=[];for(;12!=sm.Current().Type;)sE.push(this.#bC(sm));return this.#bo(sm,12),new StatementBlock(sE)}#bE(sg){let sx=this.#bC(sg);this.#bq(sg,"while"),this.#bo(sg,13);let s8=this.#bA(sg);return this.#bo(sg,14),this.#bo(sg,10),new StatementDoWhile(sx,s8)}#bF(sR){let s_=null,sI=null,sA=null,sC=null;return this.#bo(sR,13),this.#bh(sR.Current().Text)?s_=this.#bc(sR):(s_=this.#bK(sR),this.#bo(sR,10)),10!=sR.Current().Type&&(sI=this.#bA(sR)),this.#bo(sR,10),14!=sR.Current().Type&&(sA=this.#bA(sR)),this.#bo(sR,14),sC=this.#bC(sR),new StatementFor(s_,sI,sA,sC)}#bG(sP){this.#bo(sP,13);let s$=this.#bA(sP);this.#bo(sP,14);let sw=this.#bC(sP),sL=null;return this.#bl(sP,"else")&&(sL=this.#bC(sP)),new StatementIf(s$,sw,sL)}#bH(sM){if(this.#bk(sM,10))return new StatementReturn(null);let sF=this.#bA(sM);return this.#bo(sM,10),new StatementReturn(sF)}#bI(sb){let sy=null,sv=[];this.#bo(sb,13),sy=this.#bA(sb),this.#bo(sb,14),this.#bo(sb,11);let s1=!1;for(;12!=sb.Current().Type;){let sN=null;if(this.#bl(sb,"case"))sN=this.#bA(sb);else if(this.#bl(sb,"default")){if(s1)throw new ParseError(sb.PeekPrev(),"More than one 'default' found in switch statement");s1=!0}else throw new ParseError(sb.Current(),"Invalid token in switch statement: "+sb.Current().Text);this.#bo(sb,9);let sB=[];for(;"case"!=sb.Current().Text&&"default"!=sb.Current().Text&&12!=sb.Current().Type;)sB.push(this.#bC(sb));null==sN?sv.push(new StatementDefault(sB)):sv.push(new StatementCase(sN,sB))}return this.#bo(sb,12),new StatementSwitch(sy,sv)}#bc(sG){let sO=this.#bl(sG,"const");this.#bo(sG,5);let sU=sG.PeekPrev(),sk=[];do{this.#bo(sG,5);let s0=sG.PeekPrev(),sV=null;this.#bk(sG,15)&&(sV=this.#bA(sG),this.#bo(sG,16));let sX=null;this.#bm(sG,"=")&&(sX=this.#bA(sG)),sk.push(new VarDec(sO,sU,s0,sV,sX))}while(this.#bk(sG,8));if(0==sk.length)throw new ParseError(sG.PeekPrev(),"Variable name expected");return this.#bo(sG,10),new StatementVar(sO,sU,sk)}#bJ(s2){this.#bo(s2,13);let sH=this.#bA(s2);this.#bo(s2,14);let sW=this.#bC(s2);return new StatementWhile(sH,sW)}#bK(sz){let s3=this.#bA(sz);return this.#bo(sz,10),new StatementExpression(s3)}#bA(s6){return this.#bL(s6)}#bL(sq){let sY=this.#bM(sq);if(this.#bm(sq,"=","+=","-=","*=","/=","%=","<<=",">>=","&=","^=","|=")){let s4=sq.PeekPrev().Text,s7=sY instanceof ExpVariable;if(!s7&&sY instanceof ExpMember&&(s7=sY.RightmostChildIsVariable()),!s7)throw new ParseError(sq.PeekPrev(),"Expected variable for assignment.");return new ExpAssignment(sY,s4,this.#bL(sq))}return sY}#bM(s5){let sj=this.#bN(s5);if(this.#bm(s5,"?")){let sZ=this.#bA(s5);if(this.#bo(s5,9)){let sQ=this.#bA(s5);return new ExpTernary(sj,sZ,sQ)}throw new ParseError(s5.PeekPrev(),"Expected ':' ternary operator")}return sj}#bN(sK){let sJ=this.#bO(sK);for(;this.#bm(sK,"||");)sJ=new ExpLogical(sJ,sK.PeekPrev(),this.#bO(sK));return sJ}#bO(s9){let ae=this.#bP(s9);for(;this.#bm(s9,"&&");)ae=new ExpLogical(ae,s9.PeekPrev(),this.#bP(s9));return ae}#bP(at){let ar=this.#bQ(at);for(;this.#bm(at,"|");)ar=new ExpBitwise(ar,at.PeekPrev(),this.#bQ(at));return ar}#bQ(ai){let as=this.#bR(ai);for(;this.#bm(ai,"^");)as=new ExpBitwise(as,ai.PeekPrev(),this.#bR(ai));return as}#bR(aa){let an=this.#bS(aa);for(;this.#bm(aa,"&");)an=new ExpBitwise(an,aa.PeekPrev(),this.#bS(aa));return an}#bS(al){let ao=this.#bT(al);for(;this.#bm(al,"==","!=");)ao=new ExpBinary(ao,al.PeekPrev(),this.#bT(al));return ao}#bT(ah){let au=this.#bU(ah);for(;this.#bm(ah,"<","<=",">",">=");)au=new ExpBinary(au,ah.PeekPrev(),this.#bU(ah));return au}#bU(ac){let ap=this.#bV(ac);for(;this.#bm(ac,"<<",">>");)ap=new ExpBinary(ap,ac.PeekPrev(),this.#bV(ac));return ap}#bV(af){let aT=this.#bW(af);for(;this.#bm(af,"+","-");)aT=new ExpBinary(aT,af.PeekPrev(),this.#bW(af));return aT}#bW(aS){let aD=this.#bX(aS);for(;this.#bm(aS,"*","/","%");)aD=new ExpBinary(aD,aS.PeekPrev(),this.#bX(aS));return aD}#bX(ad){if(this.#bm(ad,"+","-","!","~","++","--"))return new ExpUnary(ad.PeekPrev(),this.#bX(ad));if(13==ad.Current().Type&&this.#bh(ad.PeekNext().Text)&&14==ad.PeekNextNext().Type){this.#bo(ad,13),this.#br(ad);let am=ad.PeekPrev();return this.#bo(ad,14),new ExpCast(am,this.#bX(ad))}return this.#bY(ad)}#bY(aE){let ag=this.#bZ(aE);for(;;){if(!(ag instanceof ExpFunctionCall)&&this.#bm(aE,"++","--"))return new ExpPostfix(ag,aE.PeekPrev());if(!(ag instanceof ExpFunctionCall)&&this.#bk(aE,13)){let ax=[];if(14!=aE.Current().Type)do ax.push(this.#bA(aE));while(this.#bk(aE,8));this.#bo(aE,14),ag=new ExpFunctionCall(ag,ax),this.#b$(ag)}else if(this.#bk(aE,15))ag=new ExpArray(ag,this.#bA(aE)),this.#bo(aE,16);else if(this.#bk(aE,7))this.#bo(aE,5),ag=new ExpMember(ag,new ExpVariable(aE.PeekPrev()));else break}return ag}#b$(a8){if(!(a8 instanceof ExpFunctionCall)||!(a8.FuncExp instanceof ExpMember)||!(a8.FuncExp.ExpLeft instanceof ExpVariable)||!(a8.FuncExp.ExpRight instanceof ExpVariable))return;let aR=a8.FuncExp.ExpLeft.VarToken.Text;if(!this.#bt(aR))return;let a_=a8.FuncExp.ExpRight.VarToken.Text;switch(a_){case"Sample":if(this.#a1!=ShaderTypePixel)throw Error("Sample() only available in pixel shaders");break;case"SampleLevel":break;default:throw Error("Invalid (or not implemented) texture member function found.")}if(a8.Parameters.length<=1)throw Error("Invalid number of parameters for texture sampling function");if(!(a8.Parameters[0]instanceof ExpVariable))throw Error("Sampler expected");let aI=a8.Parameters[0].VarToken.Text;if(!this.#bv(aI))throw Error("Sampler expected");let aA=null;for(let aC=0;aC<this.#a6.length;aC++)if(this.#a6[aC].TextureName==aR&&this.#a6[aC].SamplerName==aI){aA=this.#a6[aC];break}null==aA&&(aA=new ShaderElementCombinedTextureAndSampler(aR,aI,this.#bu(aR),this.#bw(aI)),this.#a6.push(aA)),a8.IsTextureSample=!0,a8.CombinedTextureAndSampler=aA}#bZ(aP){if(aP.Current(),this.#bl(aP,"true","false")||this.#bk(aP,6))return new ExpLiteral(aP.PeekPrev());if(this.#bk(aP,5))return new ExpVariable(aP.PeekPrev());if(this.#bk(aP,13)){let a$=this.#bA(aP);return this.#bo(aP,14),new ExpGroup(a$)}throw new ParseError(aP.Current(),"Unexpected token '"+aP.Current().Text+"'")}#b_(aw,aL){for(let aM=0;aM<aw.length;aM++)if(aw[aM].RegisterIndex==aL)return!0;return!1}#bj(aF,ab){let ay=0;for(let av=0;av<aF.length;av++)if(-1==aF[av].RegisterIndex){for(;this.#b_(aF,ay);)ay++;if(ay>=ab)throw Error("Too many registers in use for shader");aF[av].RegisterIndex=ay,ay++}}GetGLSL(){let e="";switch(this.#a1){case ShaderTypeVertex:e=this.#b0();break;case ShaderTypePixel:e=this.#b1();break;default:throw Error("Invalid shader type")}return console.log(e),e}#b2(a1){for(let aN=0;aN<this.#a2.length;aN++)if(this.#a2[aN].Name==a1)return this.#a2[aN];return null}#b3(){let aB="";return aB+="mat4 mul(mat4 m1, mat4 m2){ return m1 * m2; }\n",aB+="vec4 mul(vec4 v, mat4 m){ return v * m; }\n",aB+="vec4 mul(mat4 m, vec4 v){ return m * v; }\n\n",aB+="mat3 mul(mat3 m1, mat3 m2){ return m1 * m2; }\n",aB+="vec3 mul(vec3 v, mat3 m){ return v * m; }\n",aB+="vec3 mul(mat3 m, vec3 v){ return m * v; }\n\n",aB+="mat2 mul(mat2 m1, mat2 m2){ return m1 * m2; }\n",aB+="vec2 mul(vec2 v, mat2 m){ return v * m; }\n",aB+="vec2 mul(mat2 m, vec2 v){ return m * v; }\n\n",aB+="float saturate(float x) { return clamp(x, 0.0, 1.0); }\n",aB+="vec2 saturate(vec2 x) { return clamp(x, 0.0, 1.0); }\n",aB+="vec3 saturate(vec3 x) { return clamp(x, 0.0, 1.0); }\n",aB+="int saturate(int x) { return clamp(x, 0, 1); }\n\n",aB+="float lerp(float a, float b, float t) { return mix(a, b, t); }\n",aB+="vec2 lerp(vec2 a, vec2 b, float t) { return mix(a, b, t); }\n",aB+="vec2 lerp(vec2 a, vec2 b, vec2 t) { return mix(a, b, t); }\n",aB+="vec3 lerp(vec3 a, vec3 b, float t) { return mix(a, b, t); }\n",aB+="vec3 lerp(vec3 a, vec3 b, vec3 t) { return mix(a, b, t); }\n\n",aB+="void sincos(float a, out float s, out float c) { s = sin(a); c = cos(a); }\n\n",aB+="float atan2(float a, float b) { return atan(b, a); }\n\n",aB+="float pow_hlsl(float a, float b) { return pow(a, b); }\n",aB+="vec2 pow_hlsl(vec2 v, float f) { return pow(v, vec2(f)); }\n",aB+="vec3 pow_hlsl(vec3 v, float f) { return pow(v, vec3(f)); }\n",aB+="vec4 pow_hlsl(vec4 v, float f) { return pow(v, vec4(f)); }\n",aB+="\n"}#b4(){let aG="";return aG+="mat2 float2x2_tr(mat2 m) { return mat2(m); }\n",aG+="mat2 float2x2_tr(mat3 m) { return mat2(m); }\n",aG+="mat2 float2x2_tr(mat4 m) { return mat2(m); }\n",aG+="mat3 float3x3_tr(mat2 m) { return mat3(m); }\n",aG+="mat3 float3x3_tr(mat3 m) { return mat3(m); }\n",aG+="mat3 float3x3_tr(mat4 m) { return mat3(m); }\n",aG+="mat4 float4x4_tr(mat2 m) { return mat4(m); }\n",aG+="mat4 float4x4_tr(mat3 m) { return mat4(m); }\n",aG+="mat4 float4x4_tr(mat4 m) { return mat4(m); }\n",aG+="mat2 float2x2_tr(vec2 a, vec2 b) { return transpose(mat2(a,b)); }\n",aG+="mat3 float3x3_tr(vec3 a, vec3 b, vec3 c) { return transpose(mat3(a,b,c)); }\n",aG+="mat4 float4x4_tr(vec4 a, vec4 b, vec4 c, vec4 d) { return transpose(mat4(a,b,c,d)); }\n\n",aG+="\n"}#b0(){let aO="#version 300 es\n\n",aU=this.#b5();return aO+=this.#b6(aU),aO+=this.#b7(),aO+=this.#b8(),aO+=this.#b9(),aO+=this.#ca(),aO+=this.#b3(),aO+=this.#b4(),aO+=this.#cb(),aO+=this.#cc(),aO+=this.#cd(aU)}#b5(){if(null==this.#a9)throw Error("Missing main() function in shader");let ak=[];for(let a0=0;a0<this.#a9.Parameters.length;a0++){let aV=this.#a9.Parameters[a0];if(this.#bs(aV.DataTypeToken.Text)){let aX=this.#b2(aV.DataTypeToken.Text);if(null==aX)throw Error("Invalid data type in vertex shader input");for(let a2=0;a2<aX.Members.length;a2++)ak.push(aX.Members[a2])}else ak.push(aV)}return ak}#b6(aH){let aW="";for(let az=0;az<aH.length;az++)aW+="in "+HLSL.TranslateToGLSL(aH[az].DataTypeToken.Text)+" "+PrefixAttribute+aH[az].NameToken.Text+";\n";return aW+"\n"}#b7(){if(!this.#bs(this.#a9.ReturnType))return"";let a3=this.#b2(this.#a9.ReturnType),a6="";for(let aq=0;aq<a3.Members.length;aq++){let aY=a3.Members[aq];(null==aY.Semantic||"SV_POSITION"!=aY.Semantic.toUpperCase())&&(a6+="out "+HLSL.TranslateToGLSL(aY.DataTypeToken.Text),a6+=" "+PrefixVarying+aY.Semantic+";\n")}return a6+"\n"}#b9(){let a4="";for(let a7=0;a7<this.#a2.length;a7++){let a5=this.#a2[a7];a4+="struct "+HLSL.TranslateToGLSL(a5.Name)+"\n",a4+="{\n";for(let aj=0;aj<a5.Members.length;aj++){let aZ=a5.Members[aj];a4+="	"+HLSL.TranslateToGLSL(aZ.DataTypeToken.Text),a4+=" "+HLSL.TranslateToGLSL(aZ.NameToken.Text),null!=aZ.ArrayExpression&&(a4+="["+aZ.ArrayExpression.ToString(1,"")+"]"),a4+=";\n"}a4+="};\n\n"}return a4}#ca(){let aQ="",aK="";switch(this.#a1){case ShaderTypePixel:aK=PrefixPSCBuffer;break;case ShaderTypeVertex:aK=PrefixVSCBuffer}for(let aJ=0;aJ<this.#a3.length;aJ++){let a9=this.#a3[aJ];aQ+="layout(std140) uniform "+HLSL.TranslateToGLSL(aK+a9.Name)+"\n",aQ+="{\n";for(let ne=0;ne<a9.Members.length;ne++){let nt=a9.Members[ne];aQ+="	"+HLSL.TranslateToGLSL(nt.DataTypeToken.Text),aQ+=" "+HLSL.TranslateToGLSL(nt.NameToken.Text),null!=nt.ArrayExpression&&(aQ+="["+nt.ArrayExpression.ToString(1,"")+"]"),aQ+=";\n"}aQ+="};\n\n"}return aQ}#cb(){if(0==this.#a6.length)return"";let nr="";for(let ni=0;ni<this.#a6.length;ni++){let ns=this.#a6[ni],na;switch(ns.Texture.Type){case"Texture1D":case"Texture2D":na="sampler2D";break;case"Texture3D":na="sampler3D";break;case"TextureCube":na="samplerCube";break;default:throw Error("Texture type '"+ns.Texture.Type+"' not implemented yet!")}nr+="uniform "+na+" "+ns.CombinedName+";\n"}return nr+"\n"}#b8(){let nn="";for(let nl=0;nl<this.#a8.length;nl++)nn+=this.#a8[nl].ToString(1,"")+"\n";return nn+"\n"}#cc(){let no="";for(let nh=0;nh<this.#a7.length;nh++)no+=this.#a7[nh].ToString(1)+"\n\n";return no+(this.#a9.ToString(1,"hlsl_")+"\n\n")}#cd(nu){let nc="void main()\n";nc+="{\n";for(let np=0;np<nu.length;np++)null!=nu[np].Semantic&&"SV_VERTEXID"==nu[np].Semantic.toUpperCase()?(nc+="	uint "+nu[np].NameToken.Text+" = ",nc+="uint(gl_VertexID);\n"):(nc+="	"+HLSL.TranslateToGLSL(nu[np].DataTypeToken.Text)+" "+nu[np].NameToken.Text+" = ",nc+=PrefixAttribute+nu[np].NameToken.Text+";\n");for(let nf=0;nf<this.#a9.Parameters.length;nf++){let nT=this.#a9.Parameters[nf];if(this.#bs(nT.DataTypeToken.Text)){let nS=HLSL.TranslateToGLSL(nT.NameToken.Text);nc+="\n	"+nT.DataTypeToken.Text,nc+=" "+nS+";\n";let nD=this.#b2(nT.DataTypeToken.Text);for(let nd=0;nd<nD.Members.length;nd++){let nm=nD.Members[nd];nc+="	"+nS+"."+HLSL.TranslateToGLSL(nm.NameToken.Text)+" = ",nc+=HLSL.TranslateToGLSL(nm.NameToken.Text)+";\n"}}}nc+="\n	"+HLSL.TranslateToGLSL(this.#a9.ReturnType)+" "+PrefixVSOutput+" = hlsl_main(";for(let nE=0;nE<this.#a9.Parameters.length;nE++)nc+=HLSL.TranslateToGLSL(this.#a9.Parameters[nE].NameToken.Text),nE<this.#a9.Parameters.length-1&&(nc+=", ");if(nc+=");\n\n",null!=this.#a9.Semantic&&"SV_POSITION"==this.#a9.Semantic.toUpperCase())nc+="	gl_Position = "+PrefixVSOutput+";\n";else{let ng=null,nx=this.#b2(this.#a9.ReturnType);for(let n8=0;n8<nx.Members.length;n8++){let nR=nx.Members[n8];null!=nR.Semantic&&"SV_POSITION"==nR.Semantic.toUpperCase()?ng=nR.NameToken.Text:nc+="	"+PrefixVarying+nR.Semantic+" = "+PrefixVSOutput+"."+nR.NameToken.Text+";\n"}nc+="	gl_Position = "+PrefixVSOutput+"."+ng+";\n"}return nc+="	gl_PointSize = 1.0;\n",nc+="}\n"}#ce(){if(null==this.#a9)throw Error("Missing main() function in shader");let n_=[];for(let nI=0;nI<this.#a9.Parameters.length;nI++){let nA=this.#a9.Parameters[nI];if(this.#bs(nA.DataTypeToken.Text)){let nC=this.#b2(nA.DataTypeToken.Text);if(null==nC)throw Error("Invalid data type in pixel shader input");for(let nP=0;nP<nC.Members.length;nP++)n_.push(nC.Members[nP])}else n_.push(nA)}return n_}#cf(n$){if(0==n$.length)return"";let nw="",nL=!1;for(let nM=0;nM<this.#a9.Parameters.length;nM++){let nF=this.#a9.Parameters[nM];if(this.#bs(nF.DataTypeToken.Text)){let nb=this.#b2(nF.DataTypeToken.Text);for(let ny=0;ny<nb.Members.length;ny++){let nv=nb.Members[ny];if(null!=nv.Semantic&&"SV_POSITION"==nv.Semantic.toUpperCase()){nL=!0;continue}nw+="in "+HLSL.TranslateToGLSL(nv.DataTypeToken.Text),nw+=" "+PrefixVarying+nv.Semantic+";\n"}}else null!=nF.Semantic&&"SV_POSITION"==nF.Semantic.toUpperCase()?nL=!0:(nw+="in "+HLSL.TranslateToGLSL(nF.DataTypeToken.Text),nw+=" "+PrefixVarying+nF.Semantic+";\n")}return nw+"\n"}#cg(n1){let nN="void main()\n";nN+="{\n";for(let nB=0;nB<n1.length;nB++)nN+="	"+HLSL.TranslateToGLSL(n1[nB].DataTypeToken.Text)+" "+n1[nB].NameToken.Text+" = ","SV_POSITION"==n1[nB].Semantic.toUpperCase()?nN+="gl_FragCoord;\n":nN+=PrefixVarying+n1[nB].Semantic+";\n";for(let nG=0;nG<this.#a9.Parameters.length;nG++){let nO=this.#a9.Parameters[nG];if(this.#bs(nO.DataTypeToken.Text)){let nU=HLSL.TranslateToGLSL(nO.NameToken.Text);nN+="\n	"+nO.DataTypeToken.Text,nN+=" "+nU+";\n";let nk=this.#b2(nO.DataTypeToken.Text);for(let n0=0;n0<nk.Members.length;n0++){let nV=nk.Members[n0];nN+="	"+nU+"."+HLSL.TranslateToGLSL(nV.NameToken.Text)+" = ",nN+=HLSL.TranslateToGLSL(nV.NameToken.Text)+";\n"}}}nN+="\n	"+HLSL.TranslateToGLSL(this.#a9.ReturnType)+" "+PrefixPSOutput+" = hlsl_main(";for(let nX=0;nX<this.#a9.Parameters.length;nX++)nN+=HLSL.TranslateToGLSL(this.#a9.Parameters[nX].NameToken.Text),nX<this.#a9.Parameters.length-1&&(nN+=", ");if(nN+=");\n\n",null!=this.#a9.Semantic&&("SV_TARGET"==this.#a9.Semantic.toUpperCase()||"SV_TARGET0"==this.#a9.Semantic.toUpperCase()))nN+="	"+PSOutputVariable+" = "+PrefixPSOutput+";\n";else{let n2=null,nH=this.#b2(this.#a9.ReturnType);for(let nW=0;nW<nH.Members.length;nW++){let nz=nH.Members[nW];if(null!=nz.Semantic&&("SV_TARGET"==nz.Semantic.toUpperCase()||"SV_TARGET0"==nz.Semantic.toUpperCase()))n2=nz.NameToken.Text;else throw Error("Error converting pixel shader: Only 1 render target currently supported")}nN+="	"+PSOutputVariable+" = "+PrefixPSOutput+"."+n2+";\n"}return nN+"}\n"}#b1(){let n3="#version 300 es\n\n",n6=this.#ce();return n3+="precision mediump float;\n\n",n3+="precision mediump sampler3D;\n\n",n3+="out vec4 "+PSOutputVariable+";\n\n",n3+=this.#cf(n6),n3+=this.#b8(),n3+=this.#b9(),n3+=this.#ca(),n3+=this.#b3(),n3+=this.#b4(),n3+=this.#cb(),n3+=this.#cc(),n3+=this.#cg(n6)}}class ShaderElement{}class ShaderElementCBuffer extends ShaderElement{Name;NameGL;RegisterIndex;Members;constructor(e,t,r,i=[]){super(),this.Name=e,this.NameGL=t,this.RegisterIndex=r,this.Members=i}}class ShaderElementFunction extends ShaderElement{ReturnType;Name;Semantic;Parameters;Statements;constructor(e,t,r,i,s){super(),this.ReturnType=e,this.Name=t,this.Semantic=r,this.Parameters=i,this.Statements=s}ToString(e,t=""){let r="";switch(e){default:case 0:throw Error("IMPLEMENT ME");case 1:r+=HLSL.TranslateToGLSL(this.ReturnType)+" "+HLSL.TranslateToGLSL(t+this.Name)+"(";for(let i=0;i<this.Parameters.length;i++)r+=this.Parameters[i].ToString(e,!0),i<this.Parameters.length-1&&(r+=", ");r+=")\n",r+="{\n";for(let s=0;s<this.Statements.length;s++)r+=this.Statements[s].ToString(e,"	")+"\n";r+="}"}return r}}class ShaderElementSampler extends ShaderElement{Type;Name;RegisterIndex;constructor(e,t,r){super(),this.Type=e,this.Name=t,this.RegisterIndex=r}}class ShaderElementStruct extends ShaderElement{Name;Members;constructor(e,t){super(),this.Name=e,this.Members=t}ToString(e){let t="struct "+this.Name+"\n";t+="{\n";for(let r=0;r<this.Members.length;r++)t+=this.Members[r].ToString(e,"	");return t+"}\n"}}class ShaderElementTexture extends ShaderElement{Type;Name;RegisterIndex;constructor(e,t,r){super(),this.Type=e,this.Name=t,this.RegisterIndex=r}}class ShaderElementCombinedTextureAndSampler extends ShaderElement{TextureName;SamplerName;CombinedName;Texture;Sampler;constructor(e,t,r,i){super(),this.TextureName=e,this.SamplerName=t,this.CombinedName="combined_"+e+"_"+t,this.Texture=r,this.Sampler=i}}class Statement{}class StatementBlock extends Statement{Statements;constructor(e){super(),this.Statements=e}ToString(e,t=""){let r=t+"{\n";for(let i=0;i<this.Statements.length;i++)r+=this.Statements[i].ToString(e,t+"	")+"\n";return r+(t+"}")}}class StatementCase extends Statement{CaseValueExpression;Statements;constructor(e,t){super(),this.CaseValueExpression=e,this.Statements=t}ToString(e,t=""){let r=t+"case "+this.CaseValueExpression.ToString(e)+":\n";for(let i=0;i<this.Statements.length;i++)r+=this.Statements[i].ToString(e,t+"	")+"\n";return r}}class StatementDefault extends Statement{Statements;constructor(e){super(),this.Statements=e}ToString(e,t=""){let r=t+"default:\n";for(let i=0;i<this.Statements.length;i++)r+=this.Statements[i].ToString(e,t+"	")+"\n";return r}}class StatementDoWhile extends Statement{Body;Condition;constructor(e,t){super(),this.Body=e,this.Condition=t}ToString(e,t=""){let r=t+"do\n";return r+=this.Body.ToString(e,t+"	"),r+=t+"while("+this.Condition.ToString(e)+");\n"}}class StatementExpression extends Statement{Exp;constructor(e){super(),this.Exp=e}ToString(e,t=""){return t+this.Exp.ToString(e)+";"}}class StatementFor extends Statement{InitStatement;ConditionExpression;IterateExpression;BodyStatement;constructor(e,t,r,i){super(),this.InitStatement=e,this.ConditionExpression=t,this.IterateExpression=r,this.BodyStatement=i}ToString(e,t=""){let r=t+"for(";return r+=this.InitStatement.ToString(e,"")+" ",r+=this.ConditionExpression.ToString(e)+"; ",r+=this.IterateExpression.ToString(e)+")\n",r+=this.BodyStatement.ToString(e,t+"	")}}class StatementIf extends Statement{Condition;If;Else;constructor(e,t,r){super(),this.Condition=e,this.If=t,this.Else=r}ToString(e,t=""){let r=t+"if("+this.Condition.ToString(e)+")\n";return r+=this.If.ToString(e,t+"	")+"\n",null!=this.Else&&(r+=t+"else\n",r+=this.Else.ToString(e,t+"	")+"\n"),r}}class StatementJump extends Statement{JumpToken;constructor(e){super(),this.JumpToken=e}ToString(e,t=""){return t+this.JumpToken.Text+";"}}class StatementReturn extends Statement{Expression;constructor(e){super(),this.Expression=e}ToString(e,t=""){return t+"return "+this.Expression.ToString(e)+";"}}class StatementSwitch extends Statement{SelectorExpression;Cases;constructor(e,t){super(),this.SelectorExpression=e,this.Cases=t}ToString(e,t=""){let r=t+"switch("+this.SelectorExpression.ToString(e)+")\n";r+=t+"{\n";for(let i=0;i<this.Cases.length;i++)r+=this.Cases[i].ToString(e,t+"	");return r+(t+"}")}}class StatementWhile extends Statement{Condition;Body;constructor(e,t){super(),this.Condition=e,this.Body=t}ToString(e,t=""){let r=t+"while("+this.Condition.ToString(e)+")\n";return r+this.Body.ToString(e,t+"	")}}class StatementVar extends Statement{IsConst;DataTypeToken;VarDecs;constructor(e,t,r){super(),this.IsConst=e,this.DataTypeToken=t,this.VarDecs=r}ToString(e,t=""){let r=t;for(let i=0;i<this.VarDecs.length;i++)i>0&&(r+=", "),r+=this.VarDecs[i].ToString(e,0==i);return r+";"}}class VarDec extends Statement{DataTypeToken;NameToken;ArrayExpression;DefinitionExpression;IsConst;InputModifier;InterpModifiers;Semantic;constructor(e,t,r,i,s,a=null,n=[],l=null){super(),this.IsConst=e,this.DataTypeToken=t,this.NameToken=r,this.ArrayExpression=i,this.DefinitionExpression=s,this.InputModifier=a,this.InterpModifiers=n,this.Semantic=l}ToString(e,t){let r="";if(t){this.IsConst&&(r+="const ");for(let i=0;0==e&&i<this.InterpModifiers.length;i++)r+=this.InterpModifiers[i]+" ";switch(null!=this.InputModifier&&(r+=this.InputModifier+" "),e){default:case 0:r+=this.DataTypeToken.Text+" ";break;case 1:r+=HLSL.TranslateToGLSL(this.DataTypeToken.Text)+" "}}switch(e){default:case 0:r+=this.NameToken.Text;break;case 1:r+=HLSL.TranslateToGLSL(this.NameToken.Text)}return null!=this.ArrayExpression&&(r+="["+this.ArrayExpression.ToString(e)+"]"),0==e&&null!=this.Semantic&&(r+=" : "+this.Semantic),null!=this.DefinitionExpression&&(r+=" = "+this.DefinitionExpression.ToString(e)),r}}class Expression{}class ExpArray extends Expression{ExpArray;ExpIndex;constructor(e,t){super(),this.ExpArray=e,this.ExpIndex=t}ToString(e){return this.ExpArray.ToString(e)+"["+this.ExpIndex.ToString(e)+"]"}}class ExpAssignment extends Expression{VarExp;AssignOperator;AssignExp;constructor(e,t,r){super(),this.VarExp=e,this.AssignOperator=t,this.AssignExp=r}ToString(e){return this.VarExp.ToString(e)+" "+this.AssignOperator+" "+this.AssignExp.ToString(e)}}class ExpBinary extends Expression{ExpLeft;OperatorToken;ExpRight;constructor(e,t,r){super(),this.ExpLeft=e,this.OperatorToken=t,this.ExpRight=r}ToString(e){return this.ExpLeft.ToString(e)+" "+this.OperatorToken.Text+" "+this.ExpRight.ToString(e)}}class ExpBitwise extends Expression{ExpLeft;OperatorToken;ExpRight;constructor(e,t,r){super(),this.ExpLeft=e,this.OperatorToken=t,this.ExpRight=r}ToString(e){return this.ExpLeft.ToString(e)+" "+this.OperatorToken.Text+" "+this.ExpRight.ToString(e)}}class ExpCast extends Expression{TypeToken;Exp;constructor(e,t){super(),this.TypeToken=e,this.Exp=t}ToString(e){switch(e){default:case 0:return"("+this.TypeToken.Text+")"+this.Exp.ToString(e);case 1:return HLSL.TranslateToGLSL(this.TypeToken.Text)+"("+this.Exp.ToString(e)+")"}}}class ExpFunctionCall extends Expression{FuncExp;Parameters;IsTextureSample;CombinedTextureAndSampler;constructor(e,t){super(),this.FuncExp=e,this.Parameters=t,this.IsTextureSample=!1,this.CombinedTextureAndSampler=null}ToString(e){if(1==e&&this.IsTextureSample){let t=this.FuncExp.ExpRight.VarToken.Text;if(!HLSLTextureSampleConversion.hasOwnProperty(t))throw Error("Sample function type not yet implemented!");let r=HLSLTextureSampleConversion[t]+"("+this.CombinedTextureAndSampler.CombinedName+", ",i=this.Parameters[1].ToString(e);switch(this.CombinedTextureAndSampler.Texture.Type){case"Texture1D":i="vec2("+i+", 0.5)";break;case"Texture2D":i="vec2(0.0, 1.0) + vec2(1.0, -1.0) * ("+i+")";break;case"Texture3D":i="vec3(0.0, 1.0, 0.0) + vec3(1.0, -1.0, 1.0) * ("+i+")";break;case"TextureCube":i="vec3(1.0, -1.0, 1.0) * ("+i+")";break;default:throw Error("Invalid texture type or not yet implemented")}r+=i;for(let s=2;s<this.Parameters.length;s++)r+=", "+this.Parameters[s].ToString(e);return r+")"}{let a=this.FuncExp.ToString(e);if(1==e&&this.FuncExp instanceof ExpVariable){let n=this.FuncExp.VarToken.Text;HLSLMatrixConstructorConversion.hasOwnProperty(n)&&(a=HLSLMatrixConstructorConversion[n])}a+="(";for(let l=0;l<this.Parameters.length;l++)l>0&&(a+=", "),a+=this.Parameters[l].ToString(e);return a+")"}}}class ExpGroup extends Expression{Exp;constructor(e){super(),this.Exp=e}ToString(e){return"("+this.Exp.ToString(e)+")"}}class ExpLiteral extends Expression{DataType;LiteralToken;constructor(e){super(),this.LiteralToken=e,this.DataType=HLSL.DataTypeFromLiteralToken(e)}ToString(e){return this.LiteralToken.Text}}class ExpLogical extends Expression{ExpLeft;OperatorToken;ExpRight;constructor(e,t,r){super(),this.ExpLeft=e,this.OperatorToken=t,this.ExpRight=r}ToString(e){return this.ExpLeft.ToString(e)+" "+this.OperatorToken.Text+" "+this.ExpRight.ToString(e)}}class ExpMember extends Expression{ExpLeft;ExpRight;constructor(e,t){super(),this.ExpLeft=e,this.ExpRight=t}RightmostChildIsVariable(){let e=this.ExpRight;for(;e instanceof ExpMember;)e=e.ExpRight;return e instanceof ExpVariable}ToString(e){switch(e){default:case 0:return this.ExpLeft.ToString(e)+"."+this.ExpRight.ToString(e);case 1:let t=this.ExpLeft.ToString(e),r=this.ExpRight.ToString(e);if(HLSLMatrixElementConversion.hasOwnProperty(r))return t+HLSLMatrixElementConversion[r];return t+"."+r}}}class ExpPostfix extends Expression{ExpLeft;OperatorToken;constructor(e,t){super(),this.ExpLeft=e,this.OperatorToken=t}ToString(e){return this.ExpLeft.ToString(e)+this.OperatorToken.Text}}class ExpTernary extends Expression{ExpCondition;ExpIf;ExpElse;constructor(e,t,r){super(),this.ExpCondition=e,this.ExpIf=t,this.ExpElse=r}ToString(e){return this.ExpCondition.ToString(e)+" ? "+this.ExpIf.ToString(e)+" : "+this.ExpElse.ToString(e)}}class ExpUnary extends Expression{OperatorToken;ExpRight;constructor(e,t){super(),this.OperatorToken=e,this.ExpRight=t}ToString(e){return this.OperatorToken.Text+this.ExpRight.ToString(e)}}class ExpVariable extends Expression{VarToken;constructor(e){super(),this.VarToken=e}ToString(e){switch(e){default:case 0:return this.VarToken.Text;case 1:return HLSL.TranslateToGLSL(this.VarToken.Text)}}}class ParseError extends Error{line;text;constructor(e,...t){super(...t),this.line=null==e?-1:e.Line,this.text=null==e?"":e.Text}}class ScopeStack{#ch;#ci;constructor(){this.#ch=[],this.#ci={}}PushScope(){this.#ch.push([])}PopScope(){let e=this.#ch.pop();for(let t=0;t<e.length;t++)delete this.#ci[e[t].NameToken.Text]}AddVarStatement(e){for(let t=0;t<e.VarDecs.length;t++)this.AddVar(e.VarDecs[t])}AddVar(e){if(0==this.#ch.length)throw Error("Cannot add variable to empty scope stack");let t=e.NameToken.Text;if(this.#ci.hasOwnProperty(t))throw new ParseError(e.NameToken,"Redefinition of '"+t+"'");this.#ch[this.#ch.length-1].push(e),this.#ci[t]=e}IsVarInScope(e){return this.#ci.hasOwnProperty(e)}}