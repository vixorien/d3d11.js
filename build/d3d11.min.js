const D3D11_APPEND_ALIGNED_ELEMENT=4294967295,D3D11_BIND_VERTEX_BUFFER=1,D3D11_BIND_INDEX_BUFFER=2,D3D11_BIND_CONSTANT_BUFFER=4,D3D11_BIND_SHADER_RESOURCE=8,D3D11_BIND_RENDER_TARGET=32,D3D11_BIND_DEPTH_STENCIL=64,D3D11_COMPARISON_NEVER=1,D3D11_COMPARISON_LESS=2,D3D11_COMPARISON_EQUAL=3,D3D11_COMPARISON_LESS_EQUAL=4,D3D11_COMPARISON_GREATER=5,D3D11_COMPARISON_NOT_EQUAL=6,D3D11_COMPARISON_GREATER_EQUAL=7,D3D11_COMPARISON_ALWAYS=8,D3D11_CPU_ACCESS_WRITE=65536,D3D11_CPU_ACCESS_READ=131072,D3D11_JS_CREATE_DEVICE_ALPHA_CANVAS=1,D3D11_JS_CREATE_DEVICE_PREMULTIPLIED_ALPHA=2,D3D11_CULL_NONE=1,D3D11_CULL_FRONT=2,D3D11_CULL_BACK=3,D3D11_DEFAULT_STENCIL_READ_MASK=255,D3D11_DEFAULT_STENCIL_WRITE_MASK=255,D3D11_DEPTH_WRITE_MASK_ZERO=0,D3D11_DEPTH_WRITE_MASK_ALL=1,D3D11_DSV_DIMENSION_TEXTURE1D=1,D3D11_DSV_DIMENSION_TEXTURE1DARRAY=2,D3D11_DSV_DIMENSION_TEXTURE2D=3,D3D11_DSV_DIMENSION_TEXTURE2DARRAY=4,D3D11_DSV_READ_ONLY_DEPTH=1,D3D11_DSV_READ_ONLY_STENCIL=2,D3D11_JS_FEATURE_ANISOTROPIC_FILTER_SUPPORT=0,D3D11_JS_FEATURE_FLOAT_TEXTURE_SUPPORT=1,D3D11_JS_FEATURE_FLOAT_TEXTURE_FILTER_SUPPORT=2,D3D11_JS_FEATURE_COMPRESSED_TEXTURE_S3TC_SUPPORT=3,D3D11_FILL_WIREFRAME=2,D3D11_FILL_SOLID=3,D3D11_FILTER_MIN_MAG_MIP_POINT=0,D3D11_FILTER_MIN_MAG_POINT_MIP_LINEAR=1,D3D11_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT=4,D3D11_FILTER_MIN_POINT_MAG_MIP_LINEAR=5,D3D11_FILTER_MIN_LINEAR_MAG_MIP_POINT=16,D3D11_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR=17,D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT=20,D3D11_FILTER_MIN_MAG_MIP_LINEAR=21,D3D11_FILTER_ANISOTROPIC=85,D3D11_FILTER_COMPARISON_MIN_MAG_MIP_POINT=128,D3D11_FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR=129,D3D11_FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT=132,D3D11_FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR=133,D3D11_FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT=144,D3D11_FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR=145,D3D11_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT=148,D3D11_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR=149,D3D11_FILTER_COMPARISON_ANISOTROPIC=213,D3D11_FLOAT32_MAX=3402823466e29,D3D11_CLEAR_DEPTH=1,D3D11_CLEAR_STENCIL=2,D3D11_INPUT_PER_VERTEX_DATA=0,D3D11_INPUT_PER_INSTANCE_DATA=1,D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED=0,D3D11_PRIMITIVE_TOPOLOGY_POINTLIST=1,D3D11_PRIMITIVE_TOPOLOGY_LINELIST=2,D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP=3,D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST=4,D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP=5,D3D11_RESOURCE_DIMENSION_UNKNOWN=0,D3D11_RESOURCE_DIMENSION_BUFFER=1,D3D11_RESOURCE_DIMENSION_TEXTURE1D=2,D3D11_RESOURCE_DIMENSION_TEXTURE2D=3,D3D11_RESOURCE_DIMENSION_TEXTURE3D=4,D3D11_RESOURCE_MISC_GENERATE_MIPS=1,D3D11_RESOURCE_MISC_TEXTURECUBE=4,D3D11_SRV_DIMENSION_TEXTURE1D=2,D3D11_SRV_DIMENSION_TEXTURE1DARRAY=3,D3D11_SRV_DIMENSION_TEXTURE2D=4,D3D11_SRV_DIMENSION_TEXTURE2DARRAY=5,D3D11_SRV_DIMENSION_TEXTURE3D=8,D3D11_SRV_DIMENSION_TEXTURECUBE=9,D3D11_STENCIL_OP_KEEP=1,D3D11_STENCIL_OP_ZERO=2,D3D11_STENCIL_OP_REPLACE=3,D3D11_STENCIL_OP_INCR_SAT=4,D3D11_STENCIL_OP_DECR_SAT=5,D3D11_STENCIL_OP_INVERT=6,D3D11_STENCIL_OP_INCR=7,D3D11_STENCIL_OP_DECR=8,D3D11_RTV_DIMENSION_TEXTURE1D=2,D3D11_RTV_DIMENSION_TEXTURE1DARRAY=3,D3D11_RTV_DIMENSION_TEXTURE2D=4,D3D11_RTV_DIMENSION_TEXTURE2DARRAY=5,D3D11_RTV_DIMENSION_TEXTURE3D=8,D3D11_TEXTURE_ADDRESS_WRAP=1,D3D11_TEXTURE_ADDRESS_MIRROR=2,D3D11_TEXTURE_ADDRESS_CLAMP=3,D3D11_TEXTURE_ADDRESS_BORDER=4,D3D11_TEXTURE_ADDRESS_MIRROR_ONCE=5,D3D11_USAGE_DEFAULT=0,D3D11_USAGE_IMMUTABLE=1,D3D11_USAGE_DYNAMIC=2,D3D11_USAGE_STAGING=3,DXGI_FORMAT_UNKNOWN=0,DXGI_FORMAT_R32G32B32A32_FLOAT=2,DXGI_FORMAT_R32G32B32_FLOAT=6,DXGI_FORMAT_R16G16B16A16_FLOAT=10,DXGI_FORMAT_R32G32_FLOAT=16,DXGI_FORMAT_R8G8B8A8_UNORM=28,DXGI_FORMAT_R8G8B8A8_UNORM_SRGB=29,DXGI_FORMAT_R16G16_FLOAT=34,DXGI_FORMAT_D32_FLOAT=40,DXGI_FORMAT_R32_FLOAT=41,DXGI_FORMAT_R32_UINT=42,DXGI_FORMAT_D24_UNORM_S8_UINT=45,DXGI_FORMAT_D16_UNORM=55,DXGI_FORMAT_R16_UINT=57,DXGI_FORMAT_BC1_UNORM=71,DXGI_FORMAT_BC2_UNORM=74,DXGI_FORMAT_BC3_UNORM=77,DXGI_FORMAT_B8G8R8A8_UNORM=87,DXGI_FORMAT_B8G8R8X8_UNORM=88;class D3D11_BUFFER_DESC{ByteWidth;Usage;BindFlags;CPUAccessFlags;MiscFlags;StructureByteStride;constructor(e,t,r,s=0,i=0,a=0){this.ByteWidth=e,this.Usage=t,this.BindFlags=r,this.CPUAccessFlags=s,this.MiscFlags=i,this.StructureByteStride=a}Copy(){return new D3D11_BUFFER_DESC(this.ByteWidth,this.Usage,this.BindFlags,this.CPUAccessFlags,this.MiscFlags,this.StructureByteStride)}}class D3D11_DEPTH_STENCIL_DESC{DepthEnable;DepthWriteMask;DepthFunc;StencilEnable;StencilReadMask;StencilWriteMask;FrontFace;BackFace;constructor(e=!0,t=1,r=2,s=!1,i=255,a=255,n=new D3D11_DEPTH_STENCILOP_DESC,l=new D3D11_DEPTH_STENCILOP_DESC){this.DepthEnable=e,this.DepthWriteMask=t,this.DepthFunc=r,this.StencilEnable=s,this.StencilReadMask=i,this.StencilWriteMask=a,this.FrontFace=n.Copy(),this.BackFace=l.Copy()}Copy(){return new D3D11_DEPTH_STENCIL_DESC(this.DepthEnable,this.DepthWriteMask,this.DepthFunc,this.StencilEnable,this.StencilReadMask,this.StencilWriteMask,this.FrontFace.Copy(),this.BackFace.Copy())}}class D3D11_DEPTH_STENCILOP_DESC{StencilFailOp;StencilDepthFailOp;StencilPassOp;StencilFunc;constructor(e=1,t=1,r=1,s=8){this.StencilFailOp=e,this.StencilDepthFailOp=t,this.StencilPassOp=r,this.StencilFunc=s}Copy(){return new D3D11_DEPTH_STENCILOP_DESC(this.StencilFailOp,this.StencilDepthFailOp,this.StencilPassOp,this.StencilFunc)}}class D3D11_DEPTH_STENCIL_VIEW_DESC{Format;ViewDimension;Flags;MipSlice;FirstArraySlice;ArraySize;constructor(e,t,r=0,s=0,i=0,a=1){this.Format=e,this.ViewDimension=t,this.Flags=r,this.MipSlice=s,this.FirstArraySlice=i,this.ArraySize=a}Copy(){return new D3D11_DEPTH_STENCIL_VIEW_DESC(this.Format,this.ViewDimension,this.Flags,this.MipSlice,this.FirstArraySlice,this.ArraySize)}}class D3D11_INPUT_ELEMENT_DESC{SemanticName;SemanticIndex;Format;InputSlot;AlignedByteOffset;InputSlotClass;InstanceDataStepRate;constructor(e,t,r,s,i,a,n){this.SemanticName=e,this.SemanticIndex=t,this.Format=r,this.InputSlot=s,this.AlignedByteOffset=i,this.InputSlotClass=a,this.InstanceDataStepRate=n}Copy(){return new D3D11_INPUT_ELEMENT_DESC(this.SemanticName,this.SemanticIndex,this.Format,this.InputSlot,this.AlignedByteOffset,this.InputSlotClass,this.InstanceDataStepRate)}}class D3D11_RASTERIZER_DESC{FillMode;CullMode;FrontCounterClockwise;DepthBias;DepthBiasClamp;SlopeScaledDepthBias;DepthClipEnable;ScissorEnable;MultisampleEnable;AntiasliasedLineEnable;constructor(e,t,r=!1,s=0,i=0,a=0,n=!0,l=!1,o=!1,h=!1){this.FillMode=e,this.CullMode=t,this.FrontCounterClockwise=r,this.DepthBias=s,this.DepthBiasClamp=i,this.SlopeScaledDepthBias=a,this.DepthClipEnable=n,this.ScissorEnable=l,this.MultisampleEnable=o,this.AntiasliasedLineEnable=h}Copy(){return new D3D11_RASTERIZER_DESC(this.FillMode,this.CullMode,this.FrontCounterClockwise,this.DepthBias,this.DepthBiasClamp,this.SlopeScaledDepthBias,this.DepthClipEnable,this.ScissorEnable,this.MultisampleEnable,this.AntiasliasedLineEnable)}}class D3D11_RENDER_TARGET_VIEW_DESC{Format;ViewDimension;MipSlice;FirstArraySlice;ArraySize;constructor(e,t,r=0,s=0,i=1){this.Format=e,this.ViewDimension=t,this.MipSlice=r,this.FirstArraySlice=s,this.ArraySize=i}Copy(){return new D3D11_RENDER_TARGET_VIEW_DESC(this.Format,this.ViewDimension,this.MipSlice,this.FirstArraySlice,this.ArraySize)}}class D3D11_SAMPLER_DESC{Filter;AddressU;AddressV;AddressW;MipLODBias;MaxAnisotropy;ComparisonFunc;BorderColor;MinLOD;MaxLOD;constructor(e,t,r,s,i,a,n,l,o,h){this.Filter=e,this.AddressU=t,this.AddressV=r,this.AddressW=s,this.MipLODBias=i,this.MaxAnisotropy=a,this.ComparisonFunc=n,this.BorderColor=l,this.MinLOD=o,this.MaxLOD=h}Copy(){return new D3D11_SAMPLER_DESC(this.Filter,this.AddressU,this.AddressV,this.AddressW,this.MipLODBias,this.MaxAnisotropy,this.ComparisonFunc,this.BorderColor,this.MinLOD,this.MaxLOD)}}class D3D11_SHADER_RESOURCE_VIEW_DESC{Format;ViewDimension;MostDetailedMip;MipLevels;FirstArraySlice;ArraySize;constructor(e,t,r=0,s=1,i=0,a=1){this.Format=e,this.ViewDimension=t,this.MostDetailedMip=r,this.MipLevels=s,this.FirstArraySlice=i,this.ArraySize=a}Copy(){return new D3D11_SHADER_RESOURCE_VIEW_DESC(this.Format,this.ViewDimension,this.MostDetailedMip,this.MipLevels,this.FirstArraySlice,this.ArraySize)}}class D3D11_TEXTURE1D_DESC{Width;MipLevels;ArraySize;Format;Usage;BindFlags;CPUAccessFlags;MiscFlags;constructor(e,t,r,s,i,a,n,l){this.Width=e,this.MipLevels=t,this.ArraySize=r,this.Format=s,this.Usage=i,this.BindFlags=a,this.CPUAccessFlags=n,this.MiscFlags=l}Copy(){return new D3D11_TEXTURE1D_DESC(this.Width,this.MipLevels,this.ArraySize,this.Format,this.Usage,this.BindFlags,this.CPUAccessFlags,this.MiscFlags)}}class D3D11_TEXTURE2D_DESC{Width;Height;MipLevels;ArraySize;Format;SampleDesc;Usage;BindFlags;CPUAccessFlags;MiscFlags;constructor(e,t,r,s,i,a,n,l,o,h){this.Width=e,this.Height=t,this.MipLevels=r,this.ArraySize=s,this.Format=i,this.SampleDesc=a.Copy(),this.Usage=n,this.BindFlags=l,this.CPUAccessFlags=o,this.MiscFlags=h}Copy(){return new D3D11_TEXTURE2D_DESC(this.Width,this.Height,this.MipLevels,this.ArraySize,this.Format,this.SampleDesc.Copy(),this.Usage,this.BindFlags,this.CPUAccessFlags,this.MiscFlags)}}class D3D11_TEXTURE3D_DESC{Width;Height;Depth;MipLevels;Format;Usage;BindFlags;CPUAccessFlags;MiscFlags;constructor(e,t,r,s,i,a,n,l,o){this.Width=e,this.Height=t,this.Depth=r,this.MipLevels=s,this.Format=i,this.Usage=a,this.BindFlags=n,this.CPUAccessFlags=l,this.MiscFlags=o}Copy(){return new D3D11_TEXTURE3D_DESC(this.Width,this.Height,this.Depth,this.MipLevels,this.Format,this.Usage,this.BindFlags,this.CPUAccessFlags,this.MiscFlags)}}class DXGI_SAMPLE_DESC{Count;Quality;constructor(e=1,t=0){this.Count=e,this.Quality=t}Copy(){return new DXGI_SAMPLE_DESC(this.Count,this.Quality)}}class DXGI_SWAP_CHAIN_DESC{Width;Height;Format;constructor(e,t,r=28){this.Width=e,this.Height=t,this.Format=r}Copy(){return new DXGI_SWAP_CHAIN_DESC(this.Width,this.Height,this.Format)}}class D3D11_VIEWPORT{TopLeftX;TopLeftY;Width;Height;MinDepth;MaxDepth;constructor(e,t,r,s,i,a){this.TopLeftX=e,this.TopLeftY=t,this.Width=r,this.Height=s,this.MinDepth=i,this.MaxDepth=a}}class D3D11_RECT{Left;Top;Right;Bottom;constructor(e,t,r,s){this.Left=e,this.Top=t,this.Right=r,this.Bottom=s}}class D3D11_BOX{Left;Top;Front;Right;Bottom;Back;constructor(e,t,r,s,i=0,a=1){this.Left=e,this.Top=t,this.Right=r,this.Bottom=s,this.Front=i,this.Back=a}IsEmpty(){return this.Right<=this.Left||this.Bottom<=this.Top||this.Back<=this.Front}}class IUnknown{#a;constructor(){if(new.target===IUnknown)throw Error("Cannot instantiate IUnknown objects directly.");this.#a=0,this.AddRef()}GetRef(){return this.#a}AddRef(){return this.#a++,this.#a}Release(){return this.#a--,this.#b(),this.#a}#b(){if(this.#a<0)throw Error("Object has been released and is no longer available")}}class ID3D11DeviceChild extends IUnknown{#c;constructor(e){if(super(),new.target===ID3D11DeviceChild)throw Error("Cannot instantiate ID3D11DeviceChild objects directly.");this.#c=e,this.#c.AddRef()}Release(){return super.Release(),0>=this.GetRef()&&this.#c.Release(),this.GetRef()}GetDevice(){return this.#c.AddRef(),this.#c}}function D3D11CreateDevice(e,t){let r=e.getContext("webgl2",{alpha:(1&t)==1,premultipliedAlpha:(2&t)==2,antialias:!1,depth:!1,preserveDrawingBuffer:!0});if(null===r)throw Error("Unable to create internal WebGL2 rendering context for d3d11.js");return new class extends ID3D11Device{}(r)}function D3D11CreateDeviceAndSwapChain(e,t,r){let s=D3D11CreateDevice(e,t),i=s.GetImmediateContext(),a=DXGICreateSwapChain(s,r);return[s,i,a]}function DXGICreateSwapChain(e,t){return new class extends IDXGISwapChain{}(e,t)}function D3D11CalcSubresource(e,t,r){return e+t*r}class ID3D11Device extends IUnknown{#d;#e;#f;#g;#h;#i;#j;#k;constructor(e){if(super(),new.target===ID3D11Device)throw Error("Cannot instantiate ID3D11Device objects directly.  Use D3D11CreateDevice() or D3D11CreateDeviceAndSwapChain() instead.");this.#d=e,this.#e=null,this.#j=this.#d.createFramebuffer(),this.#k=this.#d.createFramebuffer(),this.#f=this.#d.getExtension("EXT_texture_filter_anisotropic")||this.#d.getExtension("MOZ_EXT_texture_filter_anisotropic")||this.#d.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),this.#g=this.#d.getExtension("EXT_color_buffer_float"),this.#h=this.#d.getExtension("OES_texture_float_linear"),this.#i=this.#d.getExtension("WEBGL_compressed_texture_s3tc"),this.#d.pixelStorei(this.#d.UNPACK_FLIP_Y_WEBGL,!1)}Release(){super.Release(),0>=this.GetRef()&&(this.#e.Release(),this.#d.deleteFramebuffer(this.#j),this.#d.deleteFramebuffer(this.#k))}GetAdapter(){return this.#d}CheckFeatureSupport(e){switch(e){case 0:return this.#f;case 1:return this.#g;case 2:return this.#h;case 3:return this.#i;default:return null}}GetBackBufferFramebuffer(){return this.#k}GetImmediateContext(){return null==this.#e?this.#e=new class extends ID3D11DeviceContext{}(this):this.#e.AddRef(),this.#e}CreateBuffer(e,t){this.#l(e,t),null!=this.#e&&this.#e.DirtyPipeline();let r=this.#d.createBuffer(),s=this.#d.STATIC_DRAW;switch(e.Usage){case 1:s=this.#d.STATIC_DRAW;break;case 2:default:s=this.#d.DYNAMIC_DRAW;break;case 3:s=this.#d.DYNAMIC_READ}let i,a;return 2==e.BindFlags?(i=this.#d.ELEMENT_ARRAY_BUFFER,a=this.#d.getParameter(this.#d.ELEMENT_ARRAY_BUFFER_BINDING)):4==e.BindFlags?(i=this.#d.UNIFORM_BUFFER,a=this.#d.getParameter(this.#d.UNIFORM_BUFFER_BINDING)):(i=this.#d.ARRAY_BUFFER,a=this.#d.getParameter(this.#d.ARRAY_BUFFER_BINDING)),this.#d.bindBuffer(i,r),null==t?this.#d.bufferData(i,e.ByteWidth,s):this.#d.bufferData(i,t,s),this.#d.bindBuffer(i,a),new class extends ID3D11Buffer{}(this,e,i,r)}CreateDepthStencilState(e){if(null==e)throw Error("Depth-Stencil description cannot be null");return this.#m(e),new class extends ID3D11DepthStencilState{}(this,e)}CreateDepthStencilView(e,t){if(null==t){let r=null;if(e instanceof ID3D11Texture1D)r=1;else if(e instanceof ID3D11Texture2D)r=3;else throw Error("Invalid resource type for DSV");let s=e.GetDesc();t=new D3D11_DEPTH_STENCIL_VIEW_DESC(s.Format,r,0,0,0,s.ArraySize)}return this.#n(e,t),new class extends ID3D11DepthStencilView{}(this,e,t)}CreateInputLayout(e){return null!=this.#e&&this.#e.DirtyPipeline(),new class extends ID3D11InputLayout{}(this,e)}CreatePixelShader(e){null!=this.#e&&this.#e.DirtyPipeline();let t=new HLSL(e,ShaderTypePixel),r=this.#o(t.GetGLSL(),this.#d.FRAGMENT_SHADER);return new class extends ID3D11PixelShader{}(this,r,t)}CreateRasterizerState(e){if(null==e)throw Error("Rasterizer description cannot be null");return this.#p(e),new class extends ID3D11RasterizerState{}(this,e)}CreateRenderTargetView(e,t){if(null==t){let r=null;if(e instanceof ID3D11Texture1D)r=2;else if(e instanceof ID3D11Texture2D)r=4;else if(e instanceof ID3D11Texture3D)r=8;else throw Error("Invalid resource type for RTV");let s=e.GetDesc();t=new D3D11_RENDER_TARGET_VIEW_DESC(s.Format,r,0,0,s.ArraySize)}this.#q(e,t);let i=t.Copy();return(4&e.GetDesc().MiscFlags)==4&&(2==i.FirstArraySlice?i.FirstArraySlice=3:3==i.FirstArraySlice&&(i.FirstArraySlice=2)),new class extends ID3D11RenderTargetView{}(this,e,i)}CreateSamplerState(e){if(null==e)throw Error("Sampler description cannot be null");return this.#r(e),new class extends ID3D11SamplerState{}(this,e)}CreateShaderResourceView(e,t){if(null==t){let r=e.GetDesc(),s=null;if(e instanceof ID3D11Texture1D)s=r.ArraySize>1?3:2;else if(e instanceof ID3D11Texture2D)s=!0&r.MiscFlags&&6==r.ArraySize?9:r.ArraySize>1?5:4;else if(e instanceof ID3D11Texture3D)s=8;else throw Error("Invalid resource type for SRV");t=new D3D11_SHADER_RESOURCE_VIEW_DESC(r.Format,s,0,r.MipLevels,0,r.ArraySize)}return this.#s(e,t),new class extends ID3D11ShaderResourceView{}(this,e,t)}CreateTexture1D(e,t){return this.#t(1,e,t)}CreateTexture2D(e,t){return this.#t(2,e,t)}CreateTexture3D(e,t){return this.#t(3,e,t)}#t(e,t,r){null!=this.#e&&this.#e.DirtyPipeline(),this.#u(e,t,r);let s=this.#d.createTexture(),i=this.#v(t.Format),a=i.InternalFormat,n=i.Format,l=i.Type;i.IsDepth,i.HasStencil;let o=i.IsCompressed,h=t.MipLevels>1,u=this.#w(e,t);this.#d.bindTexture(u,s);let c=1,p=1,f=1;switch(e){case 3:f=t.Depth;case 2:p=t.Height;case 1:c=t.Width}switch(u){case this.#d.TEXTURE_2D:case this.#d.TEXTURE_CUBE_MAP:this.#d.texStorage2D(u,t.MipLevels,a,c,p);break;case this.#d.TEXTURE_2D_ARRAY:this.#d.texStorage3D(u,t.MipLevels,a,c,p,t.ArraySize);break;case this.#d.TEXTURE_3D:this.#d.texStorage3D(u,t.MipLevels,a,c,p,f)}if(null!=r&&r.length>0)switch(u){case this.#d.TEXTURE_2D:for(let T=0;T<t.MipLevels&&T<r.length;T++){if(null==r[T])continue;let S=Math.pow(2,T),D=Math.max(1,Math.floor(c/S)),d=Math.max(1,Math.floor(p/S));this.#d.texSubImage2D(u,T,0,0,D,d,n,l,r[T])}break;case this.#d.TEXTURE_CUBE_MAP:let E=[this.#d.TEXTURE_CUBE_MAP_POSITIVE_X,this.#d.TEXTURE_CUBE_MAP_NEGATIVE_X,this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Y,this.#d.TEXTURE_CUBE_MAP_POSITIVE_Y,this.#d.TEXTURE_CUBE_MAP_POSITIVE_Z,this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Z];for(let m=0;m<6;m++)for(let g=0;g<t.MipLevels&&g<r.length/6;g++){if(null==r[g+m*t.MipLevels])continue;let x=Math.pow(2,g),R=Math.max(1,Math.floor(c/x)),_=Math.max(1,Math.floor(p/x));o?this.#d.compressedTexSubImage2D(E[m],g,0,0,R,_,n,r[g+m*t.MipLevels]):this.#d.texSubImage2D(E[m],g,0,0,R,_,n,l,r[g+m*t.MipLevels])}break;case this.#d.TEXTURE_2D_ARRAY:for(let I=0;I<t.ArraySize;I++)for(let A=0;A<t.MipLevels&&A<r.length/t.ArraySize;A++){if(null==r[A+I*t.MipLevels])continue;let C=Math.pow(2,A),P=Math.max(1,Math.floor(c/C)),$=Math.max(1,Math.floor(p/C));o?this.#d.compressedTexSubImage3D(u,A,0,0,I,P,$,1,n,r[A+I*t.MipLevels]):this.#d.texSubImage3D(u,A,0,0,I,P,$,1,n,l,r[A+I*t.MipLevels])}break;case this.#d.TEXTURE_3D:for(let w=0;w<t.MipLevels&&w<r.length;w++){if(null==r[w])continue;let L=Math.pow(2,w),M=Math.max(1,Math.floor(c/L)),F=Math.max(1,Math.floor(p/L)),b=Math.max(1,Math.floor(f/L));o?this.#d.compressedTexSubImage3D(u,w,0,0,0,M,F,b,n,r[w+arraySlice*t.MipLevels]):this.#d.texSubImage3D(u,w,0,0,0,M,F,b,n,l,r[w])}}switch(this.#x(u,h),this.#d.bindTexture(u,null),e){case 1:return new class extends ID3D11Texture1D{}(this,t,u,s);case 2:return new class extends ID3D11Texture2D{}(this,t,u,s);case 3:return new class extends ID3D11Texture3D{}(this,t,u,s);default:throw Error("Invalid texture dimension")}}CreateVertexShader(e){null!=this.#e&&this.#e.DirtyPipeline();let t=new HLSL(e,ShaderTypeVertex),r=this.#o(t.GetGLSL(),this.#d.VERTEX_SHADER);return new class extends ID3D11VertexShader{}(this,r,t)}ReadFromSubresource(e,t,r,s=null){if(!(null!=s&&s.IsEmpty())){if(t instanceof ID3D11Texture2D){let i=t.GetDesc();if(3!=i.Usage)throw Error("Invalid usage on resource - can only read from staging resources");if((131072&i.CPUAccessFlags)==0)throw Error("Invalid CPU Access flag on resource - must be set for reading");let a=D3D11CalcSubresource(i.MipLevels-1,i.ArraySize-1,i.MipLevels);if(r<0||r>a)throw Error("Invalid subresource index for reading");let n=Math.floor(r/i.MipLevels),l=r-n*i.MipLevels,o=Math.pow(2,l),h=Math.max(1,Math.floor(i.Width/o)),u=Math.max(1,Math.floor(i.Height/o)),c=0,p=0,f=h,T=u;null!=s&&(c=s.Left,p=u-s.Bottom,f=s.Right-s.Left,T=s.Bottom-s.Top),this.#e.DirtyPipeline(),this.#d.bindFramebuffer(this.#d.READ_FRAMEBUFFER,this.#j);let S=(4&i.MiscFlags)==4;if(!(i.ArraySize>1)||S){let D=this.#d.TEXTURE_2D;if(S)switch(n){case 0:D=this.#d.TEXTURE_CUBE_MAP_POSITIVE_X;break;case 1:D=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_X;break;case 2:D=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Y;break;case 3:D=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Y;break;case 4:D=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Z;break;case 5:D=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Z;break;default:throw Error("Invalid subresource for cube map reading")}this.#d.framebufferTexture2D(this.#d.READ_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,D,t.GetGLResource(),l)}else this.#d.framebufferTextureLayer(this.#d.READ_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,t.GetGLResource(),l,n);let d=this.#v(i.Format);this.#d.readPixels(c,p,f,T,d.Format,d.Type,e)}else if(t instanceof ID3D11Buffer)throw Error("Reading from a buffer is not yet implemented!");else throw Error("Given source resource is invalid or not yet implemented!")}}#o(y,v){let N=this.#d.createShader(v);this.#d.shaderSource(N,y),this.#d.compileShader(N);if(!this.#d.getShaderParameter(N,this.#d.COMPILE_STATUS))throw Error("Error compiling shader: "+this.#d.getShaderInfoLog(N));return N}#w(B,G){let O=G.ArraySize>1,U=(4&G.MiscFlags)==4;if(3==B)return this.#d.TEXTURE_3D;if(2==B&&U)return this.#d.TEXTURE_CUBE_MAP;if((1==B||2==B)&&!U)return O?this.#d.TEXTURE_2D_ARRAY:this.#d.TEXTURE_2D;throw Error("Description does not match any known WebGL texture types")}#v(k){let V={Type:null,Format:null,InternalFormat:null,IsDepth:!1,HasStencil:!1,IsCompressed:!1};switch(k){case 55:V.Type=this.#d.UNSIGNED_SHORT,V.Format=this.#d.DEPTH_COMPONENT,V.InternalFormat=this.#d.DEPTH_COMPONENT16,V.IsDepth=!0,V.HasStencil=!1;break;case 45:V.Type=this.#d.UNSIGNED_INT_24_8,V.Format=this.#d.DEPTH_STENCIL,V.InternalFormat=this.#d.DEPTH24_STENCIL8,V.IsDepth=!0,V.HasStencil=!0;break;case 40:V.Type=this.#d.FLOAT,V.Format=this.#d.DEPTH_COMPONENT,V.InternalFormat=this.#d.DEPTH_COMPONENT32F,V.IsDepth=!0,V.HasStencil=!1;break;case 28:V.Type=this.#d.UNSIGNED_BYTE,V.Format=this.#d.RGBA,V.InternalFormat=this.#d.RGBA8;break;case 29:V.Type=this.#d.UNSIGNED_BYTE,V.Format=this.#d.RGBA,V.InternalFormat=this.#d.SRGB8_ALPHA8;break;case 34:V.Type=this.#d.HALF_FLOAT,V.Format=this.#d.RG,V.InternalFormat=this.#d.RG16F;break;case 10:V.Type=this.#d.HALF_FLOAT,V.Format=this.#d.RGBA,V.InternalFormat=this.#d.RGBA16F;break;case 2:V.Type=this.#d.FLOAT,V.Format=this.#d.RGBA,V.InternalFormat=this.#d.RGBA32F;break;case 71:if(null==this.#i)throw Error("DXT compressed texture formats not supported by your device");V.Format=this.#i.COMPRESSED_RGBA_S3TC_DXT1_EXT,V.InternalFormat=this.#i.COMPRESSED_RGBA_S3TC_DXT1_EXT,V.IsCompressed=!0;break;case 74:if(null==this.#i)throw Error("DXT compressed texture formats not supported by your device");V.Format=this.#i.COMPRESSED_RGBA_S3TC_DXT3_EXT,V.InternalFormat=this.#i.COMPRESSED_RGBA_S3TC_DXT3_EXT,V.IsCompressed=!0;break;case 77:if(null==this.#i)throw Error("DXT compressed texture formats not supported by your device");V.Format=this.#i.COMPRESSED_RGBA_S3TC_DXT5_EXT,V.InternalFormat=this.#i.COMPRESSED_RGBA_S3TC_DXT5_EXT,V.IsCompressed=!0;break;default:throw Error("Format specified is not implemented yet!")}return V}#x(X,H){this.#d.texParameteri(X,this.#d.TEXTURE_MAG_FILTER,this.#d.LINEAR),this.#d.texParameteri(X,this.#d.TEXTURE_MIN_FILTER,H?this.#d.LINEAR_MIPMAP_LINEAR:this.#d.LINEAR),this.#d.texParameteri(X,this.#d.TEXTURE_WRAP_S,this.#d.CLAMP_TO_EDGE),this.#d.texParameteri(X,this.#d.TEXTURE_WRAP_T,this.#d.CLAMP_TO_EDGE),this.#d.texParameteri(X,this.#d.TEXTURE_WRAP_R,this.#d.CLAMP_TO_EDGE),this.#d.texParameterf(X,this.#d.TEXTURE_MIN_LOD,-3402823466e29),this.#d.texParameterf(X,this.#d.TEXTURE_MAX_LOD,3402823466e29),this.#d.texParameteri(X,this.#d.TEXTURE_COMPARE_MODE,this.#d.NONE),this.#d.texParameteri(X,this.#d.TEXTURE_COMPARE_FUNC,this.#d.NEVER),null!=this.#f&&this.#d.texParameterf(X,this.#f.TEXTURE_MAX_ANISOTROPY_EXT,1)}#l(W,z){let q=(1&W.BindFlags)==1,Y=(2&W.BindFlags)==2,j=(4&W.BindFlags)==4,Z=(8&W.BindFlags)==8,Q=(32&W.BindFlags)==32,K=(64&W.BindFlags)==64;if(W.ByteWidth<=0)throw Error("Invalid byte width for buffer description.  Must be greater than zero.");if(j&&W.ByteWidth%16!=0)throw Error("Invalid byte width for buffer description.  Constant buffer byte width must be a multiple of 16");if(this.#y(W,z),q||Y||j||Z||Q||K){if(j&&4!=W.BindFlags)throw Error("Constant Buffer bind flag cannot be combined with any other flags.");if(Y&&2!=W.BindFlags)throw Error("Index Buffer bind flag cannot be combined with any other flags.")}else throw Error("Invalid bind flag for buffer description.");if(0!=W.CPUAccessFlags&&131072!=W.CPUAccessFlags&&65536!=W.CPUAccessFlags)throw Error("Invalid CPU Access Flags for buffer description.");if(131072==W.CPUAccessFlags&&3!=W.Usage)throw Error("Invalid CPU Access in buffer description.  CPU Access Read can only be used with Staging usage.");if(65536==W.CPUAccessFlags&&(0==W.Usage||1==W.Usage))throw Error("Invalid CPU Access in buffer description.  CPU Access Write can only be used with Dynamic or Staging usage.");if(0!=W.MiscFlags)throw Error("Invalid Misc Flags for buffer description.");if(0!=W.StructureByteStride)throw Error("Invalid Structured Byte Stride for buffer description.")}#m(J){if(1!=J.DepthWriteMask&&0!=J.DepthWriteMask)throw Error("Invalid Depth Write Mask for depth stencil description");if(J.DepthFunc<1||J.DepthFunc>8)throw Error("Invalid Depth Function for depth stencil description");if(J.StencilEnable)throw Error("Stencil support not yet implemented!")}#n(ee,et){if(null==ee)throw Error("Resource cannot be null when creating a DSV");let er=ee.GetDesc();if((64&er.BindFlags)==0)throw Error("Cannot create DSV: resource is not marked for depth/stencil binding");if(0==et.Format)et.Format=er.Format;else if(et.Format!=er.Format)throw Error("Specified DSV Format does not match resource");switch(et.Format){case 55:case 40:case 45:break;default:throw Error("Specified DSV Format is invalid or not yet implemented!")}switch(et.ViewDimension){case 3:if(!(ee instanceof ID3D11Texture2D))throw Error("Specified DSV View Dimension does not match resource");break;case 1:if(!(ee instanceof ID3D11Texture1D))throw Error("Specified DSV View Dimension does not match resource");break;case 2:case 4:throw Error("Specified DSV View Dimension is not yet implemented!");default:throw Error("Specified DSV View Dimension is invalid")}switch(et.Flags){case 0:break;case 1:case 2:throw Error("Specified DSV Flags not yet implemented!");default:throw Error("Specified DSV Flags are invalid")}if(et.MipSlice<0||et.MipSlice>=er.MipLevels)throw Error("Specified DSV Mip Slice is invalid");if(et.FirstArraySlice<0||et.FirstArraySlice>=er.ArraySize)throw Error("Specified DSV First Array Slice is invalid");let es=et.FirstArraySlice+et.ArraySize-1;if(0==et.ArraySize||es<0||es>=er.ArraySize)throw Error("Specified DSV Array Size is invalid")}#p(ei){switch(ei.FillMode){case 3:break;case 2:throw Error("Wireframe fill mode not yet implemented!");default:throw Error("Invalid Fill Mode for rasterizer description")}if(1!=ei.CullMode&&2!=ei.CullMode&&3!=ei.CullMode)throw Error("Invalid Cull Mode for rasterizer description");if(0!=ei.DepthBiasClamp)throw Error("Depth Bias Clamp unsupported in WebGL");if(!ei.DepthClipEnable)throw Error("Disabling Depth Clip unsupported in WebGL");if(ei.MultisampleEnable)throw Error("Multisampling not yet implemented");if(ei.AntiasliasedLineEnable)throw Error("Antialiased Lines not yet implemented")}#r(ea){let en=ea.Filter;if(en<0||en>213||(2&en)==2||(8&en)==8||(32&en)==32)throw Error("Invalid filter mode for sampler state");let el=ea.AddressU,eo=ea.AddressV,eh=ea.AddressW;if(el<1||el>5)throw Error("Invalid address U mode for sampler state");if(eo<1||eo>5)throw Error("Invalid address V mode for sampler state");if(eh<1||eh>5)throw Error("Invalid address W mode for sampler state");if(4==el||4==eo||4==eh)throw Error("Border address mode unsupported in WebGL");if(5==el||5==eo||5==eh)throw Error("MirrorOnce address mode unsupported in WebGL");let eu=(64&en)==64;if(this.#f&&eu){let ec=this.#d.getParameter(this.#f.MAX_TEXTURE_MAX_ANISOTROPY_EXT);if(ea.MaxAnisotropy<1||ea.MaxAnisotropy>ec)throw Error(`Invalid MaxAnisotropy value for sampler state - range is [1, ${ec}]`)}else if(eu)throw Error("Anisotropic filtering not available on this device");let ep=ea.ComparisonFunc;if((128&en)==128&&(ep<1||ep>8))throw Error("Invalid comparison function for sampler state");let ef=ea.BorderColor;if((4==el||4==eo||4==eh)&&ef[0]<0||ef[0]>1||ef[1]<0||ef[1]>1||ef[2]<0||ef[2]>1||ef[3]<0||ef[3]>1)throw Error("Invalid border color for sampler state")}#q(eT,eS){if(null==eT)throw Error("Resource cannot be null when creating an RTV");let eD=eT.GetDesc();if((32&eD.BindFlags)==0)throw Error("Cannot create RTV: resource is not marked for render target binding");if(0==eS.Format)eS.Format=eD.Format;else if(eS.Format!=eD.Format)throw Error("Specified RTV Format does not match resource");switch(eS.Format){case 28:case 29:case 34:case 10:case 2:break;default:throw Error("Specified RTV Format is invalid or not yet implemented!")}switch(eS.ViewDimension){case 4:case 5:if(!(eT instanceof ID3D11Texture2D))throw Error("Specified RTV View Dimension does not match resource");break;case 2:case 3:if(!(eT instanceof ID3D11Texture1D))throw Error("Specified RTV View Dimension does not match resource");break;case 8:if(!(eT instanceof ID3D11Texture3D))throw Error("Specified RTV View Dimension does not match resource");break;default:throw Error("Specified RTV View Dimension is invalid")}if(eS.MipSlice<0||eS.MipSlice>=eD.MipLevels)throw Error("Specified RTV Mip Slice is invalid");if(eS.FirstArraySlice<0||eS.FirstArraySlice>=eD.ArraySize)throw Error("Specified RTV First Array Slice is invalid");let ed=eS.FirstArraySlice+eS.ArraySize-1;if(0==eS.ArraySize||ed<0||ed>=eD.ArraySize)throw Error("Specified RTV Array Size is invalid")}#s(eE,em){if(null==eE)throw Error("Resource cannot be null when creating an SRV");let eg=eE.GetDesc();if((8&eg.BindFlags)==0)throw Error("Cannot create SRV: resource is not marked for shader resource binding");switch(em.Format){case 28:case 29:case 34:case 10:case 2:case 71:case 74:case 77:break;default:throw Error("Specified SRV Format is invalid or not yet implemented!")}if(em.Format!=eg.Format)throw Error("Specified SRV Format does not match resource");switch(em.ViewDimension){case 4:case 5:case 9:if(!(eE instanceof ID3D11Texture2D))throw Error("Specified SRV View Dimension does not match resource");break;case 2:case 3:if(!(eE instanceof ID3D11Texture1D))throw Error("Specified SRV View Dimension does not match resource");break;case 8:if(!(eE instanceof ID3D11Texture3D))throw Error("Specified SRV View Dimension does not match resource");break;default:throw Error("Specified SRV View Dimension is invalid")}if(em.MostDetailedMip<0||em.MostDetailedMip>=eg.MipLevels)throw Error("Specified SRV Most Detailed Mip is invalid");let ex=em.MostDetailedMip+em.MipLevels-1;if(0==em.MipLevels||ex<0||ex>=eg.MipLevels)throw Error("Specified SRV Mip Levels value is invalid");if(em.FirstArraySlice<0||em.FirstArraySlice>=eg.ArraySize)throw Error("Specified SRV First Array Slice is invalid");let e8=em.FirstArraySlice+em.ArraySize-1;if(0==em.ArraySize||e8<0||e8>=eg.ArraySize)throw Error("Specified SRV Array Size is invalid")}#u(eR,e_,eI){if(null==e_)throw Error("Description cannot be null when creating a texture");if(eR<1||eR>3)throw Error("Invalid texture dimension");let eA=this.#d.getParameter(this.#d.MAX_TEXTURE_SIZE),eC=this.#d.getParameter(this.#d.MAX_3D_TEXTURE_SIZE),eP=this.#d.getParameter(this.#d.MAX_CUBE_MAP_TEXTURE_SIZE),e$=this.#d.getParameter(this.#d.MAX_ARRAY_TEXTURE_LAYERS),ew=(4&e_.MiscFlags)==4,eL=(1&e_.MiscFlags)==1;if(ew&&2!=eR)throw Error("Only 2D textures may be used as cube maps");if(ew){if(e_.Width<=0||e_.Width>eP||e_.Height<=0||e_.Height>eP)throw Error(`Texture Cube dimensions must be between 1 and ${eP}, inclusive`)}else{let eM=3==eR?eC:eA;switch(eR){case 3:if(e_.Depth<=0||e_.Height>eM)throw Error(`Texture depth must be between 1 and ${eM}, inclusive`);case 2:if(e_.Height<=0||e_.Height>eM)throw Error(`Texture height must be between 1 and ${eM}, inclusive`);case 1:if(e_.Width<=0||e_.Width>eM)throw Error(`Texture width must be between 1 and ${eM}, inclusive`)}}if(3==eR&&Object.hasOwn(e_,"ArraySize"))throw Error("3D textures cannot have an array size");if(ew&&6!=e_.ArraySize)throw Error("Invalid array size for texture cube - must be exactly 6");if(e_.ArraySize<=0||e_.ArraySize>e$)throw Error(`Array size must be greater than zero and less than or equal to ${e$}`);let eF=Math.log2(Math.max(e_.Width,e_.Height))+1;if(0==e_.MipLevels&&(e_.MipLevels=eF),e_.MipLevels<=0||e_.MipLevels>eF)throw Error("Invalid mip levels specified for texture");switch(e_.Format){case 55:case 40:case 45:case 28:case 29:break;case 71:case 74:case 77:if(null==this.#i)throw Error("DXT compressed texture formats not supported by your device");break;case 34:case 10:case 2:if(null==this.#g)throw Error("Floating point texture formats are unsupported on your device");break;default:throw Error("Specified texture format is invalid or not yet implemented!")}switch(this.#y(e_,eI),e_.BindFlags){case 0:case 8:case 32:case 64:case 40:case 72:break;default:throw Error("Invalid bind flags specified")}if(eL&&((8&e_.BindFlags)==0||(32&e_.BindFlags)==0))throw Error("Resource must have SHADER_RESOURCE and RENDER_TARGET bind flags to generate mip maps")}#y(eb,ey){switch(eb.Usage){case 0:break;case 2:if((64&eb.BindFlags)==64||(32&eb.BindFlags)==32)throw Error("Dynamic resources cannot be bound for output");if(0==eb.BindFlags)throw Error("Dynamic resources must have at least one Bind Flag");if(65536!=eb.CPUAccessFlags)throw Error("Dynamic resources must have CPU Access Write");if(!(eb instanceof D3D11_BUFFER_DESC)){if(1!=eb.MipLevels)throw Error("Invalid mip levels - dynamic resources can only have a single subresource");if(1!=eb.ArraySize)throw Error("Invalid array size - dynamic resources can only have a single subresource")}break;case 3:if(0!=eb.BindFlags)throw Error("Staging resources cannot be bound to the pipeline and cannot have any bind flags set");if(0==eb.CPUAccessFlags)throw Error("Staging resources must have a CPU Access of either Read or Write.");break;case 1:if(null==ey||0==ey.length)throw Error("Immutable textures must have initial data");if((64&eb.BindFlags)==64||(32&eb.BindFlags)==32)throw Error("Immutable resources cannot be bound for output");break;default:throw Error("Invalid usage specified")}}}class ID3D11DeviceContext extends ID3D11DeviceChild{#d;#k;#z;#A;#B;#C;#D;#E;#F;#G;#H;#I;#J;#K;#L;#M;#N;#O;#P;#Q;#R;#S;#T;#U;#V;#W;#X;#Y;#Z;#$;#_;#aa;#ab;#ac;#ad;#ae;#af;#ag;#ah;#ai;#aj;#ak;#al;#am;#an;constructor(e){if(super(e),new.target===ID3D11DeviceContext)throw this.Release(),Error("Cannot instantiate ID3D11DeviceContext objects - use device.GetImmediateContext() or D3D11CreateDeviceAndSwapChain() instead");this.#d=e.GetAdapter(),this.#d.enable(this.#d.CULL_FACE),this.#d.frontFace(this.#d.CW),this.#d.enable(this.#d.DEPTH_TEST),this.#k=e.GetBackBufferFramebuffer(),this.#z=this.#d.createFramebuffer(),this.#B=new Map,this.#A=this.#d.getParameter(this.#d.MAX_COMBINED_TEXTURE_IMAGE_UNITS),this.#F=Array(this.#A).fill(!1),this.#C=null,this.#D=null,this.#G=!0,this.#H=!0,this.#I=null,this.#J=0,this.#K=[],this.#L=[],this.#M=[],this.#N=null,this.#O=57,this.#P=null,this.#Q=this.#d.getParameter(this.#d.MAX_VERTEX_TEXTURE_IMAGE_UNITS),this.#R=this.#d.getParameter(this.#d.MAX_VERTEX_UNIFORM_BLOCKS),this.#S=Array(this.#R).fill(null),this.#T=!0,this.#U=null,this.#Z=!0,this.#V=new D3D11_RECT(0,0,0,0),this.#$=!0,this.#W=null,this.#Y=!0,this.#X=new D3D11_RASTERIZER_DESC(3,3),this.#_=null,this.#aa=this.#d.getParameter(this.#d.MAX_TEXTURE_IMAGE_UNITS),this.#ab=this.#d.getParameter(this.#d.MAX_FRAGMENT_UNIFORM_BLOCKS),this.#ac=Array(this.#ab).fill(null),this.#ae=Array(this.#aa).fill(null),this.#ag=Array(this.#aa).fill(null),this.#ad=!0,this.#af=!0,this.#ah=!0,this.#ai=[],this.#aj=null,this.#ak=null,this.#al=0,this.#an=!0,this.#am=new D3D11_DEPTH_STENCIL_DESC}DirtyPipeline(){this.#H=!0,this.#G=!0,this.#T=!0,this.#Y=!0,this.#ad=!0,this.#af=!0,this.#ah=!0,this.#an=!0}ClearRenderTargetView(e,t){if(null==e)throw Error("Invalid RenderTargetView for clear");this.#ao(),this.#ap([e]);let[r,s]=this.#aq();this.#d.scissor(0,0,r,s),this.#d.clearColor(t[0],t[1],t[2],t[3]),this.#d.clear(this.#d.COLOR_BUFFER_BIT),this.#$=!0}ClearDepthStencilView(e,t,r,s){if(null==e)throw Error("Invalid DepthStencilView for clear");let i=!0&t,a=!0&t;if(!i&&!a)return;this.#ao(),this.#ar(e);let[n,l]=this.#aq();this.#d.scissor(0,0,n,l);let o=0;i&&(this.#d.clearDepth(r),o|=this.#d.DEPTH_BUFFER_BIT),a&&(this.#d.clearStencil(s),o|=this.#d.STENCIL_BUFFER_BIT),this.#d.clear(o),this.#$=!0}CopyResource(e,t){if(e==t)throw Error("Cannot copy resource when destination and source are the same resource");if(e instanceof ID3D11Buffer&&t instanceof ID3D11Buffer)throw Error("Buffer resource copying not yet implemented!");if(e instanceof ID3D11Texture2D&&t instanceof ID3D11Texture2D){let r=t.GetDesc(),s=e.GetDesc();if(1==e.Usage)throw Error("Cannot use an immutable resource as a copy destination");if(r.Width!=s.Width||r.Height!=s.Height||r.ArraySize!=s.ArraySize||r.MipLevels!=s.MipLevels)throw Error("Source and destination resources do not match in size or subresource count");if(r.Format!=s.Format)throw Error("Source and destination resources have different formats");for(let i=0;i<r.ArraySize;i++)for(let a=0;a<r.MipLevels;a++){let n=D3D11CalcSubresource(a,i,r.MipLevels);this.CopySubresourceRegion(e,n,0,0,0,t,n,null)}}else throw Error("Resources being copied do not match or are not yet implemented!")}CopySubresourceRegion(e,t,r,s,i,a,n,l=null){if(null!=l&&l.IsEmpty())return;let o=a.GetDesc(),h=e.GetDesc();if(1==h.Usage)throw Error("Cannot copy into an immutable resource");if(this.#as(o,n),this.#as(h,t),a==e&&n==t)throw Error("Cannot use the same subresource as both the source and destination of a copy");if(o.Format!=h.Format)throw Error("Source and destination must have same format when copying");let u=a instanceof ID3D11Buffer,c=e instanceof ID3D11Buffer;if(u&&!c||c&&!u)throw Error("Source and destination must be the same type (buffer or texture) when copying");if(a instanceof ID3D11Texture2D){if(0!=i)throw Error("Invalid destination Z value for 2D textures - must be zero");if(null!=l){let p=Math.floor(n/o.MipLevels),f=n-p*o.MipLevels,T=Math.pow(2,f),S=Math.max(1,Math.floor(h.Width/T)),D=Math.max(1,Math.floor(h.Height/T));if(l.Left<0||l.Right>S||l.Top<0||l.Bottom>D)throw Error("Source box extends outside source resource dimensions for mip level "+f)}}else throw Error("Given source resource is invalid or not yet implemented!");if(e instanceof ID3D11Texture2D){let d=Math.floor(t/h.MipLevels),E=t-d*h.MipLevels,m=h.ArraySize>1,g=(4&h.MiscFlags)==4,x=Math.pow(2,E),R=Math.max(1,Math.floor(h.Width/x)),_=Math.max(1,Math.floor(h.Height/x)),I=0,A=0,C=R,P=_;if(null!=l){I=l.Left,A=_-l.Bottom,C=l.Right-l.Left;let $=s+(P=l.Bottom-l.Top);s=_-$}if(r<0||s<0||r+C>R||s+P>_)throw Error("Destination offset extends outside destination resource dimensions for mip level "+E);if(g&&(d<0||d>=6))throw Error("Invalid subresource for cube map copying");if(this.#at(a,o,n),this.#an=!0,!m||g){let w=this.#d.TEXTURE_2D;if(g){switch(d){case 0:w=this.#d.TEXTURE_CUBE_MAP_POSITIVE_X;break;case 1:w=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_X;break;case 2:w=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Y;break;case 3:w=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Y;break;case 4:w=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Z;break;case 5:w=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Z}this.#d.bindTexture(this.#d.TEXTURE_CUBE_MAP,e.GetGLResource())}else this.#d.bindTexture(this.#d.TEXTURE_2D,e.GetGLResource());this.#d.copyTexSubImage2D(w,E,r,s,I,A,C,P)}else this.#d.bindTexture(this.#d.TEXTURE_2D_ARRAY,e.GetGLResource()),this.#d.copyTexSubImage3D(this.#d.TEXTURE_2D_ARRAY,E,r,s,d,I,A,C,P)}else throw Error("Given destination resource is invalid or not yet implemented!")}#as(ev,e1){let eN=D3D11CalcSubresource(ev.MipLevels-1,ev.ArraySize-1,ev.MipLevels);if(e1<0||e1>eN)throw Error("Invalid subresource index")}#at(eB,eG,eO){this.#d.bindFramebuffer(this.#d.READ_FRAMEBUFFER,this.#z);let eU=Math.floor(eO/eG.MipLevels),ek=eO-eU*eG.MipLevels,e0=(4&eG.MiscFlags)==4;if(!(eG.ArraySize>1)||e0){let eV=this.#d.TEXTURE_2D;if(e0)switch(eU){case 0:eV=this.#d.TEXTURE_CUBE_MAP_POSITIVE_X;break;case 1:eV=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_X;break;case 2:eV=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Y;break;case 3:eV=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Y;break;case 4:eV=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Z;break;case 5:eV=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Z;break;default:throw Error("Invalid subresource for cube map reading")}this.#d.framebufferTexture2D(this.#d.READ_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,eV,eB.GetGLResource(),ek)}else this.#d.framebufferTextureLayer(this.#d.READ_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,eB.GetGLResource(),ek,eU)}GenerateMips(e){let t=e.GetResource();if((1&t.GetDesc().MiscFlags)==0){t.Release();return}let r=t.GetGLTarget();this.#d.bindTexture(r,t.GetGLResource()),this.#d.generateMipmap(r),this.DirtyPipeline(),t.Release()}IASetInputLayout(e){this.#I=e,this.#H=!0}IASetIndexBuffer(e,t){this.#N=e,this.#O=t,null==e?this.#d.bindBuffer(this.#d.ELEMENT_ARRAY_BUFFER,null):this.#d.bindBuffer(this.#d.ELEMENT_ARRAY_BUFFER,this.#N.GetGLResource()),this.#H=!0}IASetPrimitiveTopology(e){this.#J=e}IASetVertexBuffers(e,t,r,s){this.#K=[],this.#L=[],this.#M=[];for(let i=0;i<t.length;i++)this.#K[e+i]=t[i],this.#L[e+i]=r[i],this.#M[e+i]=s[i];this.#H=!0}VSSetShader(e){this.#P=e,this.#G=!0}VSSetConstantBuffers(e,t){if(e+t.length<0||e+t.length>=this.#R)throw Error("Attempting to set VS constant buffers outside valid range");for(let r=0;r<t.length;r++)this.#S[r+e]=t[r];this.#T=!0}RSGetState(){return null==this.#W?null:(this.#W.AddRef(),this.#W)}RSSetState(e){this.#W=e,this.#Y=!0}RSGetScissorRects(){return[structuredClone(this.#V)]}RSSetScissorRects(e){this.#V=structuredClone(e[0]),this.#$=!0,this.#Y=!0}RSGetViewports(){return[structuredClone(this.#U)]}RSSetViewports(e){this.#U=structuredClone(e[0]),this.#Z=!0}PSSetShader(e){this.#_=e,this.#G=!0}PSSetConstantBuffers(e,t){if(e<0||e+t.length>=this.#ab)throw Error("Attempting to set PS constant buffers outside valid range");for(let r=0;r<t.length;r++)this.#ac[r+e]=t[r];this.#ad=!0}PSSetSamplers(e,t){if(e<0||e+t.length>=this.#aa)throw Error("Attempting to set PS samplers outside valid range");for(let r=0;r<t.length;r++)this.#ag[r+e]=t[r];this.#ah=!0}PSSetShaderResources(e,t){if(e<0||e+t.length>=this.#aa)throw Error("Attempting to set PS shader resources outside valid range");for(let r=0;r<t.length;r++)this.#ae[r+e]=t[r];this.#af=!0}OMSetDepthStencilState(e,t){this.#ak=e,this.#al=t,this.#an=!0}OMSetRenderTargets(e,t){if(null==e||0==e.length)throw Error("Unbinding render targets not yet implemented!");if(e.length>1)throw Error("Multiple render targets not yet implemented!");this.#ai=e.slice(),this.#aj=t,this.#an=!0,this.#Z=!0}OMGetRenderTargets(){return[this.#ai.slice(),this.#aj]}#au(){if(!this.#H||null==this.#I)return;let eX=this.#I.GetInputElementDescs(),e2=-1;for(let eH=0;eH<eX.length;eH++){let eW=eX[eH],ez=this.#av(eW.Format),e3=this.#aw(eW.Format),e6=eW.InputSlot;e6>=this.#K.length||(e6!=e2&&(this.#d.bindBuffer(this.#d.ARRAY_BUFFER,this.#K[e6].GetGLResource()),e2=e6),this.#d.enableVertexAttribArray(eH),this.#d.vertexAttribPointer(eH,e3,ez,!1,this.#L[e6],this.#M[e6]+eW.AlignedByteOffset))}this.#H=!1}#ax(){if(!this.#G)return;if(null==this.#P)throw Error("No vertex shader bound!");if(null==this.#_)throw Error("No pixel shader bound!");this.#B.has(this.#P)||this.#B.set(this.#P,new Map);let eq=this.#B.get(this.#P);if(!eq.has(this.#_)){let eY=Array(this.#Q),e4=Array(this.#Q),e7=Array(this.#aa),e5=Array(this.#aa);for(let ej=0;ej<this.#Q;ej++)eY[ej]=[],e4[ej]=[];for(let eZ=0;eZ<this.#aa;eZ++)e7[eZ]=[],e5[eZ]=[];eq.set(this.#_,{GLProgram:null,CBufferMap:Array(this.#R+this.#ab).fill(-1),TextureSamplerMap:{VSTextures:eY,VSSamplers:e4,PSTextures:e7,PSSamplers:e5}})}let eQ=eq.get(this.#_),eK=eQ.GLProgram;if(null==eK){eK=this.#ay(this.#P,this.#_),eQ.GLProgram=eK;let eJ=this.#P.GetCBuffers();for(let e9=0;e9<eJ.length;e9++){let te=eJ[e9];if(te.RegisterIndex<0||te.RegisterIndex>=this.#R)throw Error("Invalid register index for vertex shader constant buffer");let tt=this.#d.getUniformBlockIndex(eK,te.NameGL);eQ.CBufferMap[te.RegisterIndex]=tt}let tr=this.#_.GetCBuffers();for(let ts=0;ts<tr.length;ts++){let ti=tr[ts];if(ti.RegisterIndex<0||ti.RegisterIndex>=this.#ab)throw Error("Invalid register index for pixel shader constant buffer");let ta=this.#d.getUniformBlockIndex(eK,ti.NameGL),tn=ti.RegisterIndex+this.#R;eQ.CBufferMap[tn]=ta}let tl=0,to=this.#P.GetTextureSamplerCombinations();for(let th=0;th<to.length;th++){let tu=to[th];if(tl>=this.#Q)throw Error("Too many vertex shader texture/sampler combinations in use!");let tc=tu.Texture.RegisterIndex,tp=tu.Sampler.RegisterIndex,tf=this.#d.getUniformLocation(eK,tu.CombinedName);eQ.TextureSamplerMap.VSTextures[tc].push({TextureUnit:tl,UniformLocation:tf}),eQ.TextureSamplerMap.VSSamplers[tp].push(tl),tl++}let tT=this.#_.GetTextureSamplerCombinations();for(let tS=0;tS<tT.length;tS++){let tD=tT[tS];if(tl>=this.#aa)throw Error("Too many pixel shader texture/sampler combinations in use!");if(tl>=this.#A)throw Error("Too many total texture/sampler combinations in use!");let td=tD.Texture.RegisterIndex,tE=tD.Sampler.RegisterIndex,tm=this.#d.getUniformLocation(eK,tD.CombinedName);eQ.TextureSamplerMap.PSTextures[td].push({TextureUnit:tl,UniformLocation:tm}),eQ.TextureSamplerMap.PSSamplers[tE].push(tl),tl++}}this.#d.useProgram(eK),this.#C=eK,this.#D=eQ.CBufferMap,this.#E=eQ.TextureSamplerMap,this.#G=!1,this.#T=!0,this.#ad=!0,this.#ah=!0,this.#af=!0}#ay(tg,tx){let t8=this.#d.createProgram();this.#d.attachShader(t8,tg.GetGLShader()),this.#d.attachShader(t8,tx.GetGLShader()),this.#d.linkProgram(t8);if(!this.#d.getProgramParameter(t8,this.#d.LINK_STATUS))throw Error("Error linking shaders: "+this.#d.getProgramInfoLog(t8));this.#d.validateProgram(t8);if(!this.#d.getProgramParameter(t8,this.#d.VALIDATE_STATUS))throw Error("Error validating shaders: "+this.#d.getProgramInfoLog(t8));return t8}#az(){if(this.#T)for(let tR=0;tR<this.#S.length;tR++){let t_=this.#S[tR],tI=this.#D[tR];-1==tI||null==t_?this.#d.bindBufferBase(this.#d.UNIFORM_BUFFER,tR,null):(this.#d.bindBufferBase(this.#d.UNIFORM_BUFFER,tR,t_.GetGLResource()),this.#d.uniformBlockBinding(this.#C,tI,tR))}if(this.#ad)for(let tA=0;tA<this.#ac.length;tA++){let tC=this.#ac[tA],tP=tA+this.#R,t$=this.#D[tP];-1==t$||null==tC?this.#d.bindBufferBase(this.#d.UNIFORM_BUFFER,tP,null):(this.#d.bindBufferBase(this.#d.UNIFORM_BUFFER,tP,tC.GetGLResource()),this.#d.uniformBlockBinding(this.#C,t$,tP))}this.#T=!1,this.#ad=!1}#aA(){if(this.#F.fill(!1),this.#af)for(let tw=0;tw<this.#ae.length;tw++){let tL=this.#ae[tw];if(null==tL)continue;let tM=this.#E.PSTextures[tw];for(let tF=0;tF<tM.length;tF++){let tb=tL.GetResource(),ty=tb.GetGLTarget();this.#F[tM[tF].TextureUnit]=1!=tb.GetDesc().MipLevels,this.#d.activeTexture(this.#aB(tM[tF].TextureUnit)),this.#d.bindTexture(ty,tb.GetGLResource()),this.#d.uniform1i(tM[tF].UniformLocation,tM[tF].TextureUnit);let tv=tL.GetDesc(),t1=tv.MostDetailedMip,tN=tv.MostDetailedMip+tv.MipLevels-1;this.#d.texParameteri(ty,this.#d.TEXTURE_BASE_LEVEL,t1),this.#d.texParameteri(ty,this.#d.TEXTURE_MAX_LEVEL,tN),tb.Release()}}if(this.#ah)for(let tB=0;tB<this.#ag.length;tB++){let tG=this.#ag[tB];if(null==tG)continue;let tO=this.#E.PSSamplers[tB];for(let tU=0;tU<tO.length;tU++){let tk=this.#F[tO[tU]];this.#d.bindSampler(tO[tU],tG.GetGLSampler(tk))}}this.#ah=!1,this.#af=!1}#aB(t0){return this.#d.TEXTURE0+t0}#aq(){let tV=0,tX=0;if(null!=this.#ai){for(let t2=0;t2<this.#ai.length;t2++)if(null!=this.#ai[t2]){let tH=this.#ai[t2].GetResource();tV=tH.GetDesc().Width,tX=tH.GetDesc().Height,tH.Release();let tW=Math.pow(2,this.#ai[t2].GetDesc().MipSlice);tV=Math.max(1,Math.floor(tV/tW)),tX=Math.max(1,Math.floor(tX/tW));break}}if(0==tX&&null!=this.#aj){let tz=this.#aj.GetResource();tV=tz.GetDesc().Width,tX=tz.GetDesc().Height,tz.Release();let t3=Math.pow(2,this.#aj.GetDesc().MipSlice);tV=Math.max(1,Math.floor(tV/t3)),tX=Math.max(1,Math.floor(tX/t3))}return[tV,tX]}#aC(){let t6=0,tq=0;if((this.#Z||this.#$)&&([t6,tq]=this.#aq()),this.#Z&&null!=this.#U&&tq>0&&t6>0){let tY=tq-this.#U.Height;this.#d.viewport(this.#U.TopLeftX,tY-this.#U.TopLeftY,this.#U.Width,this.#U.Height),this.#d.depthRange(this.#U.MinDepth,this.#U.MaxDepth),this.#Z=!1}if(this.#$&&tq>0&&t6>0){let t4=this.#V.Right-this.#V.Left,t7=this.#V.Bottom-this.#V.Top,t5=tq-t7;this.#d.scissor(this.#V.Left,t5-this.#V.Top,t4,t7),this.#$=!1}if(!this.#Y)return;let tj;switch((tj=null==this.#W?this.#X:this.#W.GetDesc()).CullMode){case 3:this.#d.enable(this.#d.CULL_FACE),this.#d.cullFace(this.#d.BACK);break;case 2:this.#d.enable(this.#d.CULL_FACE),this.#d.cullFace(this.#d.FRONT);break;default:this.#d.disable(this.#d.CULL_FACE)}this.#d.frontFace(tj.FrontCounterClockwise?this.#d.CCW:this.#d.CW),0==tj.DepthBias&&0==tj.SlopeScaleDepthBias?this.#d.disable(this.#d.POLYGON_OFFSET_FILL):(this.#d.enable(this.#d.POLYGON_OFFSET_FILL),this.#d.polygonOffset(tj.SlopeScaleDepthBias,tj.DepthBias)),tj.ScissorEnable?this.#d.enable(this.#d.SCISSOR_TEST):this.#d.disable(this.#d.SCISSOR_TEST),this.#Y=!1}#aD(){if(this.#an){{let tZ;(tZ=null==this.#ak?this.#am:this.#ak.GetDesc()).DepthEnable?this.#d.enable(this.#d.DEPTH_TEST):this.#d.disable(this.#d.DEPTH_TEST),0==tZ.DepthWriteMask?this.#d.depthMask(!1):1==tZ.DepthWriteMask&&this.#d.depthMask(!0),this.#d.depthFunc(this.#aE(tZ.DepthFunc))}this.#ao(),this.#ap(this.#ai),this.#ar(this.#aj),this.#an=!1}}#ao(){this.#d.bindFramebuffer(this.#d.READ_FRAMEBUFFER,null),this.#d.bindFramebuffer(this.#d.DRAW_FRAMEBUFFER,this.#k)}#ap(tQ){if(tQ.length>0){let tK=tQ[0].GetResource(),tJ=tK.GetDesc(),t9=tQ[0].GetDesc();if(!(tK instanceof ID3D11Texture2D))throw Error("RTV texture type OM binding not yet implemented");if((4&tJ.MiscFlags)==4){let re;switch(t9.FirstArraySlice){case 0:re=this.#d.TEXTURE_CUBE_MAP_POSITIVE_X;break;case 1:re=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_X;break;case 2:re=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Y;break;case 3:re=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Y;break;case 4:re=this.#d.TEXTURE_CUBE_MAP_POSITIVE_Z;break;case 5:re=this.#d.TEXTURE_CUBE_MAP_NEGATIVE_Z;break;default:throw Error("Only array slices 0-5 are valid for texture cube RTVs")}this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,re,tK.GetGLResource(),t9.MipSlice)}else tJ.ArraySize>1?this.#d.framebufferTextureLayer(this.#d.DRAW_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,tK.GetGLResource(),t9.MipSlice,t9.FirstArraySlice):this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,this.#d.TEXTURE_2D,tK.GetGLResource(),t9.MipSlice);tK.Release()}}#ar(rt){if(null==rt)this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.DEPTH_STENCIL_ATTACHMENT,this.#d.TEXTURE_2D,null,0),this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.DEPTH_ATTACHMENT,this.#d.TEXTURE_2D,null,0);else{let rr=rt.GetResource(),rs=rt.GetDesc(),ri=45==rs.Format,ra=ri?this.#d.DEPTH_STENCIL_ATTACHMENT:this.#d.DEPTH_ATTACHMENT;ri||this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.DEPTH_STENCIL_ATTACHMENT,this.#d.TEXTURE_2D,null,0),this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,ra,this.#d.TEXTURE_2D,rr.GetGLResource(),rs.MipSlice),rr.Release()}}Draw(e,t){this.#au(),this.#ax(),this.#az(),this.#aA(),this.#aD(),this.#aC(),this.#d.drawArrays(this.#aF(this.#J),t,e)}DrawIndexed(e,t){this.#au(),this.#ax(),this.#az(),this.#aA(),this.#aD(),this.#aC();let r=this.#d.UNSIGNED_SHORT;switch(this.#O){case 57:r=this.#d.UNSIGNED_SHORT;break;case 42:r=this.#d.UNSIGNED_INT}this.#d.drawElements(this.#aF(this.#J),e,r,t)}Flush(){this.#d.finish()}UpdateSubresource(e,t,r,s,i,a){if(e instanceof ID3D11Buffer){if(1==e.GetDesc().Usage)throw Error("Cannot update immutable resource");if(0!=t)throw Error("Invalid subresource ("+t+") used for buffer update");if(null!=r)throw Error("Cannot update a box within a buffer resource");this.#d.bindBuffer(this.#d.UNIFORM_BUFFER,e.GetGLResource()),this.#d.bufferSubData(this.#d.UNIFORM_BUFFER,0,s)}else throw Error("Updating non-buffer resource not yet implemented!")}#av(rn){return this.#d.FLOAT}#aw(rl){switch(rl){case 41:return 1;case 16:return 2;case 6:return 3;case 2:return 4;default:return 0}}#aE(ro){switch(ro){case 1:return this.#d.NEVER;case 2:return this.#d.LESS;case 3:return this.#d.EQUAL;case 4:return this.#d.LEQUAL;case 5:return this.#d.GREATER;case 6:return this.#d.NOTEQUAL;case 7:return this.#d.GEQUAL;case 8:return this.#d.ALWAYS;default:throw Error("Invalid comparison function")}}#aF(rh){switch(rh){case 1:return this.#d.POINTS;case 2:return this.#d.LINES;case 3:return this.#d.LINE_STRIP;case 4:case 0:default:return this.#d.TRIANGLES;case 5:return this.#d.TRIANGLE_STRIP}}}class IDXGISwapChain extends IUnknown{#aG;#c;#d;#aH;#k;constructor(e,t){if(super(),new.target===IDXGISwapChain)throw Error("Cannot instantiate IDXGISwapChain objects directly.  Use DXGICreateSwapChain() or D3D11CreateDeviceAndSwapChain() instead.");if(this.#aG=t.Copy(),this.#c=e,this.#d=e.GetAdapter(),this.#aG.Width<=0)throw Error("Swap Chain width must be greater than zero");if(this.#aG.Height<=0)throw Error("Swap Chain height must be greater than zero");if(28!=this.#aG.Format&&29!=this.#aG.Format)throw Error("Invalid Swap Chain format");this.#d.canvas.width=this.#d.canvas.clientWidth,this.#d.canvas.height=this.#d.canvas.clientHeight,this.#aI(),this.#k=e.GetBackBufferFramebuffer()}GetDesc(){return structuredClone(this.#aG)}GetBuffer(){return this.#aH.AddRef(),this.#aH}Present(){this.#d.bindFramebuffer(this.#d.FRAMEBUFFER,null),this.#d.bindFramebuffer(this.#d.READ_FRAMEBUFFER,this.#k),this.#d.framebufferTexture2D(this.#d.READ_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,this.#d.TEXTURE_2D,this.#aH.GetGLResource(),0);let e=this.#aG.Width,t=this.#aG.Height;this.#d.blitFramebuffer(0,0,e,t,0,0,e,t,this.#d.COLOR_BUFFER_BIT,this.#d.NEAREST),this.#d.flush()}Release(){super.Release(),0>=this.GetRef()&&this.#aH.Release()}ResizeBuffers(e,t,r=0){if(0==r&&(r=this.#aG.Format),this.#aG.Width!=e||this.#aG.Height!=t||this.#aG.Format!=r){if(e<=0)throw Error("Swap Chain width must be greater than zero");if(t<=0)throw Error("Swap Chain height must be greater than zero");if(28!=r&&29!=r)throw Error("Invalid Swap Chain format");if(this.#d.canvas.width=this.#d.canvas.clientWidth,this.#d.canvas.height=this.#d.canvas.clientHeight,this.#aG.Width=e,this.#aG.Height=t,this.#aG.Format=r,this.#aH.Release(),0!=this.#aH.GetRef())throw Error("One or more outstanding back buffer references exist; cannot resize");this.#aJ(),this.#aI()}}#aI(){let ru=new D3D11_TEXTURE2D_DESC(this.#aG.Width,this.#aG.Height,1,1,this.#aG.Format,new DXGI_SAMPLE_DESC(1,0),0,32,0,0);this.#aH=this.#c.CreateTexture2D(ru,null)}#aJ(){this.#d.bindFramebuffer(this.#d.DRAW_FRAMEBUFFER,this.#k),this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.COLOR_ATTACHMENT0,this.#d.TEXTURE_2D,null,0),this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.DEPTH_ATTACHMENT,this.#d.TEXTURE_2D,null,0),this.#d.framebufferTexture2D(this.#d.DRAW_FRAMEBUFFER,this.#d.DEPTH_STENCIL_ATTACHMENT,this.#d.TEXTURE_2D,null,0)}#aK(){let rc=["Color","Depth","DepthStencil"],rp=[this.#d.COLOR_ATTACHMENT0,this.#d.DEPTH_ATTACHMENT,this.#d.DEPTH_STENCIL_ATTACHMENT],rf=["Read","Draw"],rT=[this.#d.READ_FRAMEBUFFER,this.#d.DRAW_FRAMEBUFFER],rS=[this.#d.READ_FRAMEBUFFER_BINDING,this.#d.DRAW_FRAMEBUFFER_BINDING];for(let rD=0;rD<rT.length;rD++){let rd=this.#d.getParameter(rS[rD]);for(let rE=0;rE<rp.length;rE++){let rm="NULL";null!=rd&&(rm=this.#d.getFramebufferAttachmentParameter(rT[rD],rp[rE],this.#d.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME)),console.log("Target: "+rf[rD]+" | Attachment: "+rc[rE]),console.log(rm),console.log(" ")}}console.log("---")}}class ID3D11DepthStencilState extends ID3D11DeviceChild{#aG;constructor(e,t){if(super(e),new.target===ID3D11DepthStencilState)throw e.Release(),Error("Cannot instantiate ID3D11DepthStencilState objects - use device.CreateDepthStencilState() instead");this.#aG=t.Copy()}GetDesc(){return this.#aG.Copy()}}class ID3D11InputLayout extends ID3D11DeviceChild{#aL;constructor(e,t){if(super(e),new.target===ID3D11InputLayout)throw e.Release(),Error("Cannot instantiate ID3D11InputLayout objects - use device.CreateInputLayout() instead");this.#aL=this.#aM(t)}#aM(rg){let rx=[];for(let r8=0;r8<rg.length;r8++)rx[r8]=rg[r8].Copy();return rx}GetInputElementDescs(){return this.#aM(this.#aL)}}class ID3D11PixelShader extends ID3D11DeviceChild{#aN;#aO;constructor(e,t,r){if(super(e),new.target===ID3D11PixelShader)throw e.Release(),Error("Cannot instantiate ID3D11PixelShader objects - use device.CreatePixelShader() instead");this.#aN=t,this.#aO=r}GetGLShader(){return this.#aN}GetCBuffers(){return this.#aO.GetCBuffers()}GetTextureSamplerCombinations(){return this.#aO.GetTextureSamplerCombinations()}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteShader(this.#aN),e.Release()}}}class ID3D11RasterizerState extends ID3D11DeviceChild{#aG;constructor(e,t){if(super(e),new.target===ID3D11RasterizerState)throw e.Release(),Error("Cannot instantiate ID3D11RasterizerState objects - use device.CreateRasterizerState() instead");this.#aG=t.Copy()}GetDesc(){return this.#aG.Copy()}}class ID3D11SamplerState extends ID3D11DeviceChild{#aG;#aP;#aQ;constructor(e,t){if(super(e),new.target===ID3D11SamplerState)throw e.Release(),Error("Cannot instantiate ID3D11SamplerState objects - use device.CreateSamplerState() instead");this.#aG=t.Copy();let r=e.GetAdapter();this.#aP=r.createSampler(),this.#aQ=r.createSampler(),this.#aR(e,this.#aP,t,!1),this.#aR(e,this.#aQ,t,!0)}GetDesc(){return this.#aG.Copy()}GetGLSampler(e){return e?this.#aQ:this.#aP}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteSampler(this.#aP),e.GetAdapter().deleteSampler(this.#aQ),e.Release()}}#aR(rR,r_,rI,rA){let rC=rR.GetAdapter();rC.samplerParameteri(r_,rC.TEXTURE_MAG_FILTER,this.#aS(rC,rI.Filter)),rC.samplerParameteri(r_,rC.TEXTURE_MIN_FILTER,this.#aT(rC,rI.Filter,rA)),rC.samplerParameteri(r_,rC.TEXTURE_WRAP_S,this.#aU(rC,rI.AddressU)),rC.samplerParameteri(r_,rC.TEXTURE_WRAP_T,this.#aU(rC,rI.AddressV)),rC.samplerParameteri(r_,rC.TEXTURE_WRAP_R,this.#aU(rC,rI.AddressW)),rC.samplerParameterf(r_,rC.TEXTURE_MIN_LOD,rI.MinLOD),rC.samplerParameterf(r_,rC.TEXTURE_MAX_LOD,rI.MaxLOD),this.#aV(rI.Filter)&&(rC.samplerParameteri(r_,rC.TEXTURE_COMPARE_MODE,rC.COMPARE_REF_TO_TEXTURE),rC.samplerParameteri(r_,rC.TEXTURE_COMPARE_FUNC,this.#aE(rC,rI.ComparisonFunc)));let rP=rR.CheckFeatureSupport(0);this.#aW(rI.Filter)&&null!=rP&&rC.samplerParameteri(r_,rP.TEXTURE_MAX_ANISOTROPY_EXT,rI.MaxAnisotropy)}#aS(r$,rw){return(4&rw)==4?r$.LINEAR:r$.NEAREST}#aT(rL,rM,rF){let rb=(16&rM)==16?rL.LINEAR:rL.NEAREST,ry=(1&rM)==1?rL.LINEAR:rL.NEAREST;if(!rF)return rb;if(rb==rL.LINEAR&&ry==rL.LINEAR)return rL.LINEAR_MIPMAP_LINEAR;if(rb==rL.LINEAR&&ry==rL.NEAREST)return rL.LINEAR_MIPMAP_NEAREST;if(rb==rL.NEAREST&&ry==rL.LINEAR)return rL.NEAREST_MIPMAP_LINEAR;if(rb==rL.NEAREST&&ry==rL.NEAREST)return rL.NEAREST_MIPMAP_NEAREST;throw Error("Invalid filter")}#aW(rv){return(64&rv)==64}#aV(r1){return(128&r1)==128}#aU(rN,rB){switch(rB){case 1:return rN.REPEAT;case 2:return rN.MIRRORED_REPEAT;case 3:return rN.CLAMP_TO_EDGE;default:throw Error("Invalid address mode")}}#aE(rG,rO){switch(rO){case 1:return rG.NEVER;case 2:return rG.LESS;case 3:return rG.EQUAL;case 4:return rG.LEQUAL;case 5:return rG.GREATER;case 6:return rG.NOTEQUAL;case 7:return rG.GEQUAL;case 8:return rG.ALWAYS;default:throw Error("Invalid comparison function")}}}class ID3D11VertexShader extends ID3D11DeviceChild{#aN;#aO;constructor(e,t,r){if(super(e),new.target===ID3D11VertexShader)throw e.Release(),Error("Cannot instantiate ID3D11VertexShader objects - use device.CreateVertexShader() instead");this.#aN=t,this.#aO=r}GetGLShader(){return this.#aN}GetCBuffers(){return this.#aO.GetCBuffers()}GetTextureSamplerCombinations(){return this.#aO.GetTextureSamplerCombinations()}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteShader(this.#aN),e.Release()}}}class ID3D11Resource extends ID3D11DeviceChild{#aG;#aX;#aY;constructor(e,t,r,s){if(super(e),new.target===ID3D11Buffer)throw this.Release(),Error("Cannot instantiate ID3D11Resource objects - use corresponding Create() functions of an ID3D11Device object instead");this.#aG=t.Copy(),this.#aX=r,this.#aY=s}GetDesc(){return this.#aG.Copy()}GetGLTarget(){return this.#aX}GetGLResource(){return this.#aY}}class ID3D11Buffer extends ID3D11Resource{constructor(e,t,r,s){if(super(e,t,r,s),new.target===ID3D11Buffer)throw this.Release(),Error("Cannot instantiate ID3D11Buffer objects - use device.CreateBuffer() instead")}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteBuffer(this.GetGLResource()),e.Release()}}}class ID3D11Texture1D extends ID3D11Resource{constructor(e,t,r,s){if(super(e,t,r,s),new.target===ID3D11Texture1D)throw this.Release(),Error("Cannot instantiate ID3D11Texture1D objects - use device.CreateTexture1D() instead")}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteTexture(this.GetGLResource()),e.Release()}}}class ID3D11Texture2D extends ID3D11Resource{constructor(e,t,r,s){if(super(e,t,r,s),new.target===ID3D11Texture2D)throw this.Release(),Error("Cannot instantiate ID3D11Texture2D objects - use device.CreateTexture2D() instead")}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteTexture(this.GetGLResource()),e.Release()}}}class ID3D11Texture3D extends ID3D11Resource{constructor(e,t,r,s){if(super(e,t,r,s),new.target===ID3D11Texture3D)throw this.Release(),Error("Cannot instantiate ID3D11Texture3D objects - use device.CreateTexture3D() instead")}Release(){if(super.Release(),0>=this.GetRef()){let e=this.GetDevice();e.GetAdapter().deleteTexture(this.GetGLResource()),e.Release()}}}class ID3D11View extends ID3D11DeviceChild{#aZ;#aG;constructor(e,t,r){if(super(e),new.target===ID3D11View)throw e.Release(),Error("Cannot instantiate ID3D11View objects - use corresponding Create___View() functions of an ID3D11Device object instead");this.#aZ=t,this.#aG=r.Copy(),this.#aZ.AddRef()}GetDesc(){return this.#aG.Copy()}GetResource(){return this.#aZ.AddRef(),this.#aZ}Release(){super.Release(),0>=this.GetRef()&&this.#aZ.Release()}}class ID3D11DepthStencilView extends ID3D11View{constructor(e,t,r){if(super(e,t,r),new.target===ID3D11DepthStencilView)throw e.Release(),Error("Cannot instantiate ID3D11DepthStencilView objects - use device.CreateDepthStencilView() instead")}}class ID3D11RenderTargetView extends ID3D11View{constructor(e,t,r){if(super(e,t,r),new.target===ID3D11RenderTargetView)throw e.Release(),Error("Cannot instantiate ID3D11RenderTargetView objects - use device.CreateRenderTargetView() instead")}}class ID3D11ShaderResourceView extends ID3D11View{constructor(e,t,r){if(super(e,t,r),new.target===ID3D11ShaderResourceView)throw e.Release(),Error("Cannot instantiate ID3D11ShaderResourceView objects - use device.CreateShaderResourceView() instead")}}const TokenUnknown=0,TokenWhiteSpace=1,TokenCommentMultiline=2,TokenCommentSingle=3,TokenOperator=4,TokenIdentifier=5,TokenNumericLiteral=6,TokenPeriod=7,TokenComma=8,TokenColon=9,TokenSemicolon=10,TokenScopeLeft=11,TokenScopeRight=12,TokenParenLeft=13,TokenParenRight=14,TokenBracketLeft=15,TokenBracketRight=16,ShaderTypeVertex=0,ShaderTypePixel=1,PrefixAttribute="_attrib_",PrefixVarying="_vary_",PrefixVSInput="_vs_input_",PrefixVSOutput="_vs_output_",PrefixPSInput="_ps_input_",PrefixPSOutput="_ps_output_",PrefixVSCBuffer="_vs_",PrefixPSCBuffer="_ps_",PSOutputVariable="_sv_target_",ShaderLanguageHLSL=0,ShaderLanguageGLSL=1,HLSLDataTypeConversion={void:"void",bool:"bool",bool1:"bool",bool2:"bvec2",bool3:"bvec3",bool4:"bvec4",int:"int",int1:"int",int2:"ivec2",int3:"ivec3",int4:"ivec4",uint:"uint",uint1:"uint",uint2:"uvec2",uint3:"uvec3",uint4:"uvec4",dword:"uint",dword1:"uint",dword2:"uvec2",dword3:"uvec3",dword4:"uvec4",half:"float",half1:"float",half2:"vec2",half3:"vec3",half4:"vec4",float:"float",float1:"float",float2:"vec2",float3:"vec3",float4:"vec4",double:"float",double1:"float",double2:"vec2",double3:"vec3",double4:"vec4",float2x2:"mat2x2",float2x3:"mat2x3",float2x4:"mat2x4",float3x2:"mat3x2",float3x3:"mat3x3",float3x4:"mat3x4",float4x2:"mat4x2",float4x3:"mat4x3",float4x4:"mat4x4",matrix:"mat4x4"},HLSLMatrixElementConversion={_m00:"[0][0]",_m01:"[1][0]",_m02:"[2][0]",_m03:"[3][0]",_m10:"[0][1]",_m11:"[1][1]",_m12:"[2][1]",_m13:"[3][1]",_m20:"[0][2]",_m21:"[1][2]",_m22:"[2][2]",_m23:"[3][2]",_m30:"[0][3]",_m31:"[1][3]",_m32:"[2][3]",_m33:"[3][3]",_11:"[0][0]",_12:"[1][0]",_13:"[2][0]",_14:"[3][0]",_21:"[0][1]",_22:"[1][1]",_23:"[2][1]",_24:"[3][1]",_31:"[0][2]",_32:"[1][2]",_33:"[2][2]",_34:"[3][2]",_41:"[0][3]",_42:"[1][3]",_43:"[2][3]",_44:"[3][3]"},HLSLMatrixConstructorConversion={float2x2:"float2x2_tr",float3x3:"float3x3_tr",float4x4:"float4x4_tr",matrix:"float4x4_tr"},HLSLReservedWordConversion={$Global:"_global_cbuffer",input:"_input",output:"_output",pow:"pow_hlsl",frac:"fract"},HLSLTextureSampleConversion={Sample:"texture",SampleLevel:"textureLod"};class TokenIterator{#a$;#a_;constructor(e){this.#a$=e,this.#a_=-1}MoveNext(){return this.#a_++,this.#a_<this.#a$.length}Current(){return this.#a_>=this.#a$.length?null:this.#a$[this.#a_]}More(){return this.#a_<this.#a$.length-1}Position(){return this.#a_}GetRange(e,t){if(e<0||t>=this.#a$.length+1||t<=e)throw Error("Invalid range for token iterator");return this.#a$.slice(e,t)}PeekPrev(){return this.#a0(-1)}PeekNext(){return this.#a0(1)}PeekNextNext(){return this.#a0(2)}#a0(rU){let rk=this.#a_+rU;return rk<0||rk>=this.#a$.length?null:this.#a$[rk]}}class HLSL{#aO;#a1;#a$;#a2;#a3;#a4;#a5;#a6;#a7;#a8;#a9;Rules=[{Type:1,Pattern:/^\s+/},{Type:2,Pattern:/^\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\//},{Type:3,Pattern:/^\/\/.*/},{Type:4,Pattern:/^((<<=)|(>>=))/},{Type:4,Pattern:/^((\+=)|(-=)|(\*=)|(\/=)|(%=)|(<<)|(>>)|(&=)|(\|=)|(\^=)|(&&)|(\|\|)|(==)|(!=)|(<=)|(>=)|(\+\+)|(--))/},{Type:4,Pattern:/^[\+\-\*\/\%\=\~\&\|\^\?\<\>\!]/},{Type:5,Pattern:/^[_A-Za-z][_A-Za-z0-9]*/},{Type:6,Pattern:/^[+-]?(([0][x][a-fA-F0-9]+([uU][lL])?([lL][uU])?[uU]?[lL]?)|(([0-9]*[.][0-9]+([eE][+-]?[0-9]+)?[fFlLhH]?)|([0-9]+[.]([eE][+-]?[0-9]+)?[fFlLhH])|([0-9]+[.])|([0-9]+([uU][lL])?([lL][uU])?[uU]?[lL]?)))/},{Type:11,Pattern:/^[{]/},{Type:12,Pattern:/^[}]/},{Type:13,Pattern:/^[(]/},{Type:14,Pattern:/^[)]/},{Type:15,Pattern:/^[\[]/},{Type:16,Pattern:/^[\]]/},{Type:10,Pattern:/^[;]/},{Type:9,Pattern:/^[:]/},{Type:8,Pattern:/^[,]/},{Type:7,Pattern:/^[\.]/},{Type:0,Pattern:/^./}];static TranslateToGLSL(e){return HLSLDataTypeConversion.hasOwnProperty(e)?HLSLDataTypeConversion[e]:HLSLReservedWordConversion.hasOwnProperty(e)?HLSLReservedWordConversion[e]:e}static DataTypeFromLiteralToken(e){if(6!=e.Type)throw Error("Invalid token for data type extraction");let t=e.Text.charAt(e.Text.length-1).toLowerCase(),r=1==e.Text.length?"":e.Text.charAt(e.Text.length-2).toLowerCase();if(e.Text.indexOf(".")>=0)switch(t){case"h":return"half";case"l":return"double";default:return"float"}return"u"==t||"u"==r?"uint":"int"}static async LoadTextFromURL(e,t=!0){let r=await fetch(e),s=await r.text();if(!t)return s;let i={},a="#include";for(;;){let n=s.indexOf(a);if(-1==n)break;let l=-1,o=-1;if(-1==(l=s.indexOf('"',n+a.length)))throw Error("Error with #include; expected start quote");if(-1==(o=s.indexOf('"',l+1)))throw Error("Error with #include; expected end quote");let h=s.substring(l+1,o),u="";i.hasOwnProperty(h)||(i[h]=!0,u=await (r=await fetch(h)).text()),s=s.substring(0,n)+u+s.substring(o+1)}return s}constructor(e,t){if(t!=ShaderTypeVertex&&t!=ShaderTypePixel)throw Error("Invalid shader type specified");this.#aO=e.repeat(1),this.#a1=t,this.#ba(),this.#bb()}GetCBuffers(){return this.#a3.slice()}GetTextureSamplerCombinations(){return this.#a6.slice()}#ba(){this.#a$=[];let r0=1,rV=this.#aO.repeat(1);for(;rV.length>0;){let rX=!1;for(let r2=0;r2<this.Rules.length;r2++){let rH=RegExp(this.Rules[r2].Pattern,"g"),rW=rH.exec(rV);if(null!=rW){if(rX=!0,r0+=(rW[0].match(/\n/g)||[]).length,2!=this.Rules[r2].Type&&3!=this.Rules[r2].Type&&1!=this.Rules[r2].Type){let rz={Type:this.Rules[r2].Type,Text:rW[0],Line:r0};this.#a$.push(rz)}rV=rV.substring(rH.lastIndex);break}}if(!1==rX){alert("problem");break}}}#bb(){this.#a2=[],this.#a3=[],this.#a4=[],this.#a5=[],this.#a6=[],this.#a7=[],this.#a8=[],this.#a9=null;let r3=new TokenIterator(this.#a$),r6="";switch(this.#a1){case ShaderTypePixel:r6=PrefixPSCBuffer;break;case ShaderTypeVertex:r6=PrefixVSCBuffer}let rq=new ShaderElementCBuffer("$Global",r6+"global_cbuffer",-1),rY=new ScopeStack;for(rY.PushScope(),r3.MoveNext();r3.More();){let r4=r3.Current();switch(r4.Text){case"const":let r7=this.#bc(r3,rY);this.#a8.push(r7);break;case";":r3.MoveNext();break;case"struct":this.#a2.push(this.#bd(r3));break;case"cbuffer":this.#a3.push(this.#be(r3,rY));break;case"SamplerState":case"SamplerComparisonState":this.#a5.push(this.#bf(r3));break;case"Texture1D":case"Texture1DArray":case"Texture2D":case"Texture2DArray":case"TextureCube":case"TextureCubeArray":case"Texture3D":this.#a4.push(this.#bg(r3));break;case"Texture2DMS":case"Texture2DMSArray":throw new ParseError(r3.Line,"Not currently handling multisampled textures");default:if(!this.#bh(r4.Text)||5!=r3.PeekNext().Type)throw new ParseError(r4,"Invalid token");if(!this.#bi(r3,rY,rq))throw Error("Error parsing global variable or function")}}if(null==this.#a9)throw new ParseError(null,"'main': entry point not found");rq.Members.length>0&&this.#a3.push(rq),this.#bj(this.#a3,999),this.#bj(this.#a5,999),this.#bj(this.#a4,999)}#bk(r5,...rj){for(let rZ of rj)if(r5.Current().Type==rZ)return r5.MoveNext(),!0;return!1}#bl(rQ,...rK){for(let rJ of rK)if(5==rQ.Current().Type&&rQ.Current().Text==rJ)return rQ.MoveNext(),!0;return!1}#bm(r9,...se){for(let st of se)if(4==r9.Current().Type&&r9.Current().Text==st)return r9.MoveNext(),!0;return!1}#bn(sr){let ss=sr.Current();return!!this.#bh(ss.Text)&&(sr.MoveNext(),!0)}#bo(si,sa){if(this.#bk(si,sa))return!0;throw Error("Error parsing HLSL on line "+si.Current().Line)}#bp(sn,sl){if(this.#bm(sn,sl))return!0;throw Error("Error parsing HLSL on line "+sn.Current().Line)}#bq(so,sh){if(this.#bl(so,sh))return!0;throw Error("Error parsing HLSL on line "+so.Current().Line)}#br(su){let sc=su.Current();if(this.#bh(sc.Text))return su.MoveNext(),!0;throw Error("Error parsing HLSL on line "+su.Current().Line)}#bs(sp){for(let sf=0;sf<this.#a2.length;sf++)if(this.#a2[sf].Name==sp)return!0;return!1}#bt(sT){for(let sS=0;sS<this.#a4.length;sS++)if(this.#a4[sS].Name==sT)return!0;return!1}#bu(sD){for(let sd=0;sd<this.#a4.length;sd++)if(this.#a4[sd].Name==sD)return this.#a4[sd];return null}#bv(sE){for(let sm=0;sm<this.#a5.length;sm++)if(this.#a5[sm].Name==sE)return!0;return!1}#bw(sg){for(let sx=0;sx<this.#a5.length;sx++)if(this.#a5[sx].Name==sg)return this.#a5[sx];return null}#bh(s8){let sR=this.#bs(s8),s_=HLSLDataTypeConversion.hasOwnProperty(s8);return sR||s_}#bx(sI){return HLSLReservedWordConversion.hasOwnProperty(sI)}#bd(sA){let sC=null,sP=[];this.#bq(sA,"struct"),this.#bo(sA,5),sC=sA.PeekPrev().Text,this.#bo(sA,11);do{if(12==sA.Current().Type)break;sP.push(this.#by(sA,!1,!0,!0,!1))}while(this.#bk(sA,10));return this.#bo(sA,12),this.#bo(sA,10),new ShaderElementStruct(sC,sP)}#bz(s$,sw){if(!this.#bk(s$,9))return -1;this.#bq(s$,"register"),this.#bo(s$,13),this.#bo(s$,5);let sL=s$.PeekPrev().Text;if(!sL.startsWith(sw))throw new ParseError(s$.PeekPrev(),"Invalid register type");let sM=parseInt(sL.substring(1));if(isNaN(sM))throw new ParseError(s$.PeekPrev(),"Invalid register index");return this.#bo(s$,14),sM}#be(sF,sb){let sy=null,sv=-1,s1=[];this.#bq(sF,"cbuffer"),this.#bo(sF,5),sy=sF.PeekPrev().Text,sv=this.#bz(sF,"b"),this.#bo(sF,11);do{if(12==sF.Current().Type)break;let sN=this.#by(sF,!1,!1,!1,!1);s1.push(sN),sb.AddVar(sN)}while(this.#bk(sF,10));this.#bo(sF,12);let sB="";switch(this.#a1){case ShaderTypePixel:sB=PrefixPSCBuffer;break;case ShaderTypeVertex:sB=PrefixVSCBuffer}let sG=HLSL.TranslateToGLSL(sB+sy);return new ShaderElementCBuffer(sy,sG,sv,s1)}#by(sO,sU,sk,s0,sV){let sX=[],s2=[],sH=null,sW=null,sz=null,s3=null,s6=null,sq=!1;do sq=!1,this.#bl(sO,"in")&&(s2.push("in"),sq=!0),this.#bl(sO,"inout")&&(s2.push("inout"),sq=!0),this.#bl(sO,"out")&&(s2.push("out"),sq=!0),this.#bl(sO,"uniform")&&(s2.push("uniform"),sq=!0),this.#bl(sO,"linear")&&(sX.push("linear"),sq=!0),this.#bl(sO,"centroid")&&(sX.push("centroid"),sq=!0),this.#bl(sO,"nointerpolation")&&(sX.push("nointerpolation"),sq=!0),this.#bl(sO,"noperspective")&&(sX.push("noperspective"),sq=!0),this.#bl(sO,"sample")&&(sX.push("sample"),sq=!0);while(sq);if(!sU&&s2.length>0)throw new ParseError(sO.PeekPrev(),"Input modifier not allowed here");if(s2.length>1)throw new ParseError(sO.PeekPrev(),"Multiple input modifiers found.");if(!sk&&sX.length>0)throw new ParseError(sO.PeekPrev(),"Interpolation modifier not allowed here");if(this.#br(sO),sH=sO.PeekPrev(),this.#bo(sO,5),sW=sO.PeekPrev(),this.#bk(sO,15)&&(s3=this.#bA(sO),this.#bo(sO,16)),this.#bk(sO,9)){if(!s0)throw new ParseError(sO.PeekPrev(),"Semantic not allowed here.");this.#bo(sO,5),sz=sO.PeekPrev().Text}if(this.#bm(sO,"=")){if(!sV)throw new ParseError(sO.PeekPrev(),"Initialization not allowed here.");s6=this.#bA(sO)}return new VarDec(!1,sH,sW,s3,s6,1==s2.length?s2[0]:null,sX,sz)}#bg(sY){let s4=null,s7=null,s5=-1;if(this.#bo(sY,5),s4=sY.PeekPrev().Text,this.#bo(sY,5),s7=sY.PeekPrev().Text,(s5=this.#bz(sY,"t"))>=0){for(let sj=0;sj<this.#a4.length;sj++)if(this.#a4[sj].RegisterIndex==s5)throw new ParseError(sY.PeekPrev(),"Duplicate texture register: t"+s5)}return this.#bo(sY,10),new ShaderElementTexture(s4,s7,s5)}#bf(sZ){let sQ=null,sK=null,sJ=-1;if(this.#bo(sZ,5),sQ=sZ.PeekPrev().Text,this.#bo(sZ,5),sK=sZ.PeekPrev().Text,(sJ=this.#bz(sZ,"s"))>=0){for(let s9=0;s9<this.#a5.length;s9++)if(this.#a5[s9].RegisterIndex==sJ)throw new ParseError(sZ.PeekPrev(),"Duplicate sampler register: s"+sJ)}return this.#bo(sZ,10),new ShaderElementSampler(sQ,sK,sJ)}#bi(ie,it,ir){this.#br(ie);let is=ie.PeekPrev(),ii=ie.PeekPrev().Text;this.#bo(ie,5);let ia=ie.PeekPrev(),il=ie.PeekPrev().Text;if(this.#bk(ie,13)){it.PushScope();let io=[];do{if(14==ie.Current().Type)break;let ih=this.#by(ie,!0,!0,!0,!0);io.push(ih),it.AddVar(ih)}while(this.#bk(ie,8));this.#bo(ie,14);let iu=null;this.#bk(ie,9)&&(this.#bo(ie,5),iu=ie.PeekPrev().Text),this.#bo(ie,11);let ic=this.#bB(ie,it);this.#bo(ie,12);let ip=new ShaderElementFunction(ii,il,iu,io,ic,null);if("main"==il){if(null!=this.#a9)throw new ParseError(ie.PeekPrev(),"Multiple main functions detected");this.#a9=ip}else this.#a7.push(ip);return it.PopScope(),!0}if(this.#bk(ie,10)){let iT=new VarDec(!1,is,ia,null,null);return ir.Members.push(iT),it.AddVar(iT),!0}return!1}#bB(iS,iD){let id=[];for(;12!=iS.Current().Type;)id.push(this.#bC(iS,iD));return id}#bC(iE,im){if(this.#bk(iE,11))return this.#bD(iE,im);if(this.#bl(iE,"do"))return this.#bE(iE,im);if(this.#bl(iE,"for"))return this.#bF(iE,im);if(this.#bl(iE,"if"))return this.#bG(iE,im);if(this.#bl(iE,"return"))return this.#bH(iE,im);if(this.#bl(iE,"switch"))return this.#bI(iE,im);if(this.#bh(iE.Current().Text)||"const"==iE.Current().Text)return this.#bc(iE,im);if(this.#bl(iE,"while"))return this.#bJ(iE,im);if(this.#bl(iE,"break")||this.#bl(iE,"continue")||this.#bl(iE,"discard")){let ig=iE.PeekPrev();return this.#bo(iE,10),new StatementJump(ig)}return this.#bK(iE,im)}#bD(ix,i8){i8.PushScope();let iR=[];for(;12!=ix.Current().Type;)iR.push(this.#bC(ix,i8));return this.#bo(ix,12),i8.PopScope(),new StatementBlock(iR)}#bE(i_,iI){let iA=this.#bC(i_,iI);this.#bq(i_,"while"),this.#bo(i_,13);let iC=this.#bA(i_);return this.#bo(i_,14),this.#bo(i_,10),new StatementDoWhile(iA,iC)}#bF(iP,i$){let iw=null,iL=null,iM=null,iF=null;return this.#bo(iP,13),i$.PushScope(),this.#bh(iP.Current().Text)?iw=this.#bc(iP,i$):(iw=this.#bK(iP,i$),this.#bo(iP,10)),10!=iP.Current().Type&&(iL=this.#bA(iP)),this.#bo(iP,10),14!=iP.Current().Type&&(iM=this.#bA(iP)),this.#bo(iP,14),iF=this.#bC(iP,i$),i$.PopScope(),new StatementFor(iw,iL,iM,iF)}#bG(ib,iy){this.#bo(ib,13);let iv=this.#bA(ib);this.#bo(ib,14);let i1=this.#bC(ib,iy),iN=null;return this.#bl(ib,"else")&&(iN=this.#bC(ib,iy)),new StatementIf(iv,i1,iN)}#bH(iB,iG){if(this.#bk(iB,10))return new StatementReturn(null);let iO=this.#bA(iB);return this.#bo(iB,10),new StatementReturn(iO)}#bI(iU,ik){let i0=null,iV=[];this.#bo(iU,13),i0=this.#bA(iU),this.#bo(iU,14),this.#bo(iU,11);let iX=!1;for(;12!=iU.Current().Type;){let i2=null;if(this.#bl(iU,"case"))i2=this.#bA(iU);else if(this.#bl(iU,"default")){if(iX)throw new ParseError(iU.PeekPrev(),"More than one 'default' found in switch statement");iX=!0}else throw new ParseError(iU.Current(),"Invalid token in switch statement: "+iU.Current().Text);this.#bo(iU,9);let iH=[];for(;"case"!=iU.Current().Text&&"default"!=iU.Current().Text&&12!=iU.Current().Type;)iH.push(this.#bC(iU,ik));null==i2?iV.push(new StatementDefault(iH)):iV.push(new StatementCase(i2,iH))}return this.#bo(iU,12),new StatementSwitch(i0,iV)}#bc(iW,iz){let i3=this.#bl(iW,"const");this.#bo(iW,5);let i6=iW.PeekPrev(),iq=[];do{this.#bo(iW,5);let iY=iW.PeekPrev(),i4=null;this.#bk(iW,15)&&(i4=this.#bA(iW),this.#bo(iW,16));let i7=null;this.#bm(iW,"=")&&(i7=this.#bA(iW));let i5=new VarDec(i3,i6,iY,i4,i7);iq.push(i5),iz.AddVar(i5)}while(this.#bk(iW,8));if(0==iq.length)throw new ParseError(iW.PeekPrev(),"Variable name expected");return this.#bo(iW,10),new StatementVar(i3,i6,iq)}#bJ(ij,iZ){this.#bo(ij,13);let iQ=this.#bA(ij);this.#bo(ij,14);let iK=this.#bC(ij,iZ);return new StatementWhile(iQ,iK)}#bK(iJ,i9){let ae=this.#bA(iJ);return this.#bo(iJ,10),new StatementExpression(ae)}#bA(at){return this.#bL(at)}#bL(ar){let as=this.#bM(ar);if(this.#bm(ar,"=","+=","-=","*=","/=","%=","<<=",">>=","&=","^=","|=")){let ai=ar.PeekPrev().Text,aa=as instanceof ExpVariable;if(!aa&&as instanceof ExpMember&&(aa=as.RightmostChildIsVariable()),!aa)throw new ParseError(ar.PeekPrev(),"Expected variable for assignment.");return new ExpAssignment(as,ai,this.#bL(ar))}return as}#bM(an){let al=this.#bN(an);if(this.#bm(an,"?")){let ao=this.#bA(an);if(this.#bo(an,9)){let ah=this.#bA(an);return new ExpTernary(al,ao,ah)}throw new ParseError(an.PeekPrev(),"Expected ':' ternary operator")}return al}#bN(au){let ac=this.#bO(au);for(;this.#bm(au,"||");)ac=new ExpLogical(ac,au.PeekPrev(),this.#bO(au));return ac}#bO(ap){let af=this.#bP(ap);for(;this.#bm(ap,"&&");)af=new ExpLogical(af,ap.PeekPrev(),this.#bP(ap));return af}#bP(aT){let aS=this.#bQ(aT);for(;this.#bm(aT,"|");)aS=new ExpBitwise(aS,aT.PeekPrev(),this.#bQ(aT));return aS}#bQ(aD){let ad=this.#bR(aD);for(;this.#bm(aD,"^");)ad=new ExpBitwise(ad,aD.PeekPrev(),this.#bR(aD));return ad}#bR(aE){let am=this.#bS(aE);for(;this.#bm(aE,"&");)am=new ExpBitwise(am,aE.PeekPrev(),this.#bS(aE));return am}#bS(ag){let ax=this.#bT(ag);for(;this.#bm(ag,"==","!=");)ax=new ExpBinary(ax,ag.PeekPrev(),this.#bT(ag));return ax}#bT(a8){let aR=this.#bU(a8);for(;this.#bm(a8,"<","<=",">",">=");)aR=new ExpBinary(aR,a8.PeekPrev(),this.#bU(a8));return aR}#bU(a_){let aI=this.#bV(a_);for(;this.#bm(a_,"<<",">>");)aI=new ExpBinary(aI,a_.PeekPrev(),this.#bV(a_));return aI}#bV(aA){let aC=this.#bW(aA);for(;this.#bm(aA,"+","-");)aC=new ExpBinary(aC,aA.PeekPrev(),this.#bW(aA));return aC}#bW(aP){let a$=this.#bX(aP);for(;this.#bm(aP,"*","/","%");)a$=new ExpBinary(a$,aP.PeekPrev(),this.#bX(aP));return a$}#bX(aw){if(this.#bm(aw,"+","-","!","~","++","--"))return new ExpUnary(aw.PeekPrev(),this.#bX(aw));if(13==aw.Current().Type&&this.#bh(aw.PeekNext().Text)&&14==aw.PeekNextNext().Type){this.#bo(aw,13),this.#br(aw);let aL=aw.PeekPrev();return this.#bo(aw,14),new ExpCast(aL,this.#bX(aw))}return this.#bY(aw)}#bY(aM){let aF=this.#bZ(aM);for(;;){if(!(aF instanceof ExpFunctionCall)&&this.#bm(aM,"++","--"))return new ExpPostfix(aF,aM.PeekPrev());if(!(aF instanceof ExpFunctionCall)&&this.#bk(aM,13)){let ab=[];if(14!=aM.Current().Type)do ab.push(this.#bA(aM));while(this.#bk(aM,8));this.#bo(aM,14),aF=new ExpFunctionCall(aF,ab),this.#b$(aF)}else if(this.#bk(aM,15))aF=new ExpArray(aF,this.#bA(aM)),this.#bo(aM,16);else if(this.#bk(aM,7))this.#bo(aM,5),aF=new ExpMember(aF,new ExpVariable(aM.PeekPrev()));else break}return aF}#b$(ay){if(!(ay instanceof ExpFunctionCall)||!(ay.FuncExp instanceof ExpMember)||!(ay.FuncExp.ExpLeft instanceof ExpVariable)||!(ay.FuncExp.ExpRight instanceof ExpVariable))return;let av=ay.FuncExp.ExpLeft.VarToken.Text;if(!this.#bt(av))return;let a1=ay.FuncExp.ExpRight.VarToken.Text;switch(a1){case"Sample":if(this.#a1!=ShaderTypePixel)throw Error("Sample() only available in pixel shaders");break;case"SampleLevel":break;default:throw Error("Invalid (or not implemented) texture member function found.")}if(ay.Parameters.length<=1)throw Error("Invalid number of parameters for texture sampling function");if(!(ay.Parameters[0]instanceof ExpVariable))throw Error("Sampler expected");let aN=ay.Parameters[0].VarToken.Text;if(!this.#bv(aN))throw Error("Sampler expected");let aB=null;for(let aG=0;aG<this.#a6.length;aG++)if(this.#a6[aG].TextureName==av&&this.#a6[aG].SamplerName==aN){aB=this.#a6[aG];break}null==aB&&(aB=new ShaderElementCombinedTextureAndSampler(av,aN,this.#bu(av),this.#bw(aN)),this.#a6.push(aB)),ay.IsTextureSample=!0,ay.CombinedTextureAndSampler=aB}#bZ(aO){if(aO.Current(),this.#bl(aO,"true","false")||this.#bk(aO,6))return new ExpLiteral(aO.PeekPrev());if(this.#bk(aO,5))return new ExpVariable(aO.PeekPrev());if(this.#bk(aO,13)){let aU=this.#bA(aO);return this.#bo(aO,14),new ExpGroup(aU)}throw new ParseError(aO.Current(),"Unexpected token '"+aO.Current().Text+"'")}#b_(ak,a0){for(let aV=0;aV<ak.length;aV++)if(ak[aV].RegisterIndex==a0)return!0;return!1}#bj(aX,a2){let aH=0;for(let aW=0;aW<aX.length;aW++)if(-1==aX[aW].RegisterIndex){for(;this.#b_(aX,aH);)aH++;if(aH>=a2)throw Error("Too many registers in use for shader");aX[aW].RegisterIndex=aH,aH++}}GetGLSL(){let e="";switch(this.#a1){case ShaderTypeVertex:e=this.#b0();break;case ShaderTypePixel:e=this.#b1();break;default:throw Error("Invalid shader type")}return e}#b2(az){for(let a3=0;a3<this.#a2.length;a3++)if(this.#a2[a3].Name==az)return this.#a2[a3];return null}#b3(){let a6="";return a6+="mat4 mul(mat4 m1, mat4 m2){ return m1 * m2; }\n",a6+="vec4 mul(vec4 v, mat4 m){ return v * m; }\n",a6+="vec4 mul(mat4 m, vec4 v){ return m * v; }\n\n",a6+="mat3 mul(mat3 m1, mat3 m2){ return m1 * m2; }\n",a6+="vec3 mul(vec3 v, mat3 m){ return v * m; }\n",a6+="vec3 mul(mat3 m, vec3 v){ return m * v; }\n\n",a6+="mat2 mul(mat2 m1, mat2 m2){ return m1 * m2; }\n",a6+="vec2 mul(vec2 v, mat2 m){ return v * m; }\n",a6+="vec2 mul(mat2 m, vec2 v){ return m * v; }\n\n",a6+="float saturate(float x) { return clamp(x, 0.0, 1.0); }\n",a6+="vec2 saturate(vec2 x) { return clamp(x, 0.0, 1.0); }\n",a6+="vec3 saturate(vec3 x) { return clamp(x, 0.0, 1.0); }\n",a6+="int saturate(int x) { return clamp(x, 0, 1); }\n\n",a6+="float lerp(float a, float b, float t) { return mix(a, b, t); }\n",a6+="vec2 lerp(vec2 a, vec2 b, float t) { return mix(a, b, t); }\n",a6+="vec2 lerp(vec2 a, vec2 b, vec2 t) { return mix(a, b, t); }\n",a6+="vec3 lerp(vec3 a, vec3 b, float t) { return mix(a, b, t); }\n",a6+="vec3 lerp(vec3 a, vec3 b, vec3 t) { return mix(a, b, t); }\n\n",a6+="void sincos(float a, out float s, out float c) { s = sin(a); c = cos(a); }\n\n",a6+="float atan2(float a, float b) { return atan(b, a); }\n\n",a6+="float pow_hlsl(float a, float b) { return pow(a, b); }\n",a6+="vec2 pow_hlsl(vec2 v, float f) { return pow(v, vec2(f)); }\n",a6+="vec3 pow_hlsl(vec3 v, float f) { return pow(v, vec3(f)); }\n",a6+="vec4 pow_hlsl(vec4 v, float f) { return pow(v, vec4(f)); }\n",a6+="\n"}#b4(){let aq="";return aq+="mat2 float2x2_tr(mat2 m) { return mat2(m); }\n",aq+="mat2 float2x2_tr(mat3 m) { return mat2(m); }\n",aq+="mat2 float2x2_tr(mat4 m) { return mat2(m); }\n",aq+="mat3 float3x3_tr(mat2 m) { return mat3(m); }\n",aq+="mat3 float3x3_tr(mat3 m) { return mat3(m); }\n",aq+="mat3 float3x3_tr(mat4 m) { return mat3(m); }\n",aq+="mat4 float4x4_tr(mat2 m) { return mat4(m); }\n",aq+="mat4 float4x4_tr(mat3 m) { return mat4(m); }\n",aq+="mat4 float4x4_tr(mat4 m) { return mat4(m); }\n",aq+="mat2 float2x2_tr(vec2 a, vec2 b) { return transpose(mat2(a,b)); }\n",aq+="mat3 float3x3_tr(vec3 a, vec3 b, vec3 c) { return transpose(mat3(a,b,c)); }\n",aq+="mat4 float4x4_tr(vec4 a, vec4 b, vec4 c, vec4 d) { return transpose(mat4(a,b,c,d)); }\n\n",aq+="\n"}#b0(){let aY="#version 300 es\n\n",a4=this.#b5();return aY+=this.#b6(a4),aY+=this.#b7(),aY+=this.#b8(),aY+=this.#b9(),aY+=this.#ca(),aY+=this.#b3(),aY+=this.#b4(),aY+=this.#cb(),aY+=this.#cc(),aY+=this.#cd(a4)}#b5(){if(null==this.#a9)throw Error("Missing main() function in shader");let a7=[];for(let a5=0;a5<this.#a9.Parameters.length;a5++){let aj=this.#a9.Parameters[a5];if(this.#bs(aj.DataTypeToken.Text)){let aZ=this.#b2(aj.DataTypeToken.Text);if(null==aZ)throw Error("Invalid data type in vertex shader input");for(let aQ=0;aQ<aZ.Members.length;aQ++)a7.push(aZ.Members[aQ])}else a7.push(aj)}return a7}#b6(aK){let aJ="";for(let a9=0;a9<aK.length;a9++)aJ+="in "+HLSL.TranslateToGLSL(aK[a9].DataTypeToken.Text)+" "+PrefixAttribute+aK[a9].NameToken.Text+";\n";return aJ+"\n"}#b7(){if(!this.#bs(this.#a9.ReturnType))return"";let ne=this.#b2(this.#a9.ReturnType),nt="";for(let nr=0;nr<ne.Members.length;nr++){let ns=ne.Members[nr];(null==ns.Semantic||"SV_POSITION"!=ns.Semantic.toUpperCase())&&(nt+="out "+HLSL.TranslateToGLSL(ns.DataTypeToken.Text),nt+=" "+PrefixVarying+ns.Semantic+";\n")}return nt+"\n"}#b9(){let ni="";for(let na=0;na<this.#a2.length;na++){let nn=this.#a2[na];ni+="struct "+HLSL.TranslateToGLSL(nn.Name)+"\n",ni+="{\n";for(let nl=0;nl<nn.Members.length;nl++){let no=nn.Members[nl];ni+="	"+HLSL.TranslateToGLSL(no.DataTypeToken.Text),ni+=" "+HLSL.TranslateToGLSL(no.NameToken.Text),null!=no.ArrayExpression&&(ni+="["+no.ArrayExpression.ToString(1,"")+"]"),ni+=";\n"}ni+="};\n\n"}return ni}#ca(){let nh="",nu="";switch(this.#a1){case ShaderTypePixel:nu=PrefixPSCBuffer;break;case ShaderTypeVertex:nu=PrefixVSCBuffer}for(let nc=0;nc<this.#a3.length;nc++){let np=this.#a3[nc];nh+="layout(std140) uniform "+HLSL.TranslateToGLSL(nu+np.Name)+"\n",nh+="{\n";for(let nf=0;nf<np.Members.length;nf++){let nT=np.Members[nf];nh+="	"+HLSL.TranslateToGLSL(nT.DataTypeToken.Text),nh+=" "+HLSL.TranslateToGLSL(nT.NameToken.Text),null!=nT.ArrayExpression&&(nh+="["+nT.ArrayExpression.ToString(1,"")+"]"),nh+=";\n"}nh+="};\n\n"}return nh}#cb(){if(0==this.#a6.length)return"";let nS="";for(let nD=0;nD<this.#a6.length;nD++){let nd=this.#a6[nD],nE;switch(nd.Texture.Type){case"Texture1D":case"Texture2D":nE="sampler2D";break;case"Texture3D":nE="sampler3D";break;case"TextureCube":nE="samplerCube";break;default:throw Error("Texture type '"+nd.Texture.Type+"' not implemented yet!")}nS+="uniform "+nE+" "+nd.CombinedName+";\n"}return nS+"\n"}#b8(){let nm="";for(let ng=0;ng<this.#a8.length;ng++)nm+=this.#a8[ng].ToString(1,"")+"\n";return nm+"\n"}#cc(){let nx="";for(let n8=0;n8<this.#a7.length;n8++)nx+=this.#a7[n8].ToString(1)+"\n\n";return nx+(this.#a9.ToString(1,"hlsl_")+"\n\n")}#cd(nR){let n_="void main()\n";n_+="{\n";for(let nI=0;nI<nR.length;nI++)null!=nR[nI].Semantic&&"SV_VERTEXID"==nR[nI].Semantic.toUpperCase()?(n_+="	uint "+nR[nI].NameToken.Text+" = ",n_+="uint(gl_VertexID);\n"):(n_+="	"+HLSL.TranslateToGLSL(nR[nI].DataTypeToken.Text)+" "+nR[nI].NameToken.Text+" = ",n_+=PrefixAttribute+nR[nI].NameToken.Text+";\n");for(let nA=0;nA<this.#a9.Parameters.length;nA++){let nC=this.#a9.Parameters[nA];if(this.#bs(nC.DataTypeToken.Text)){let nP=HLSL.TranslateToGLSL(nC.NameToken.Text);n_+="\n	"+nC.DataTypeToken.Text,n_+=" "+nP+";\n";let n$=this.#b2(nC.DataTypeToken.Text);for(let nw=0;nw<n$.Members.length;nw++){let nL=n$.Members[nw];n_+="	"+nP+"."+HLSL.TranslateToGLSL(nL.NameToken.Text)+" = ",n_+=HLSL.TranslateToGLSL(nL.NameToken.Text)+";\n"}}}n_+="\n	"+HLSL.TranslateToGLSL(this.#a9.ReturnType)+" "+PrefixVSOutput+" = hlsl_main(";for(let nM=0;nM<this.#a9.Parameters.length;nM++)n_+=HLSL.TranslateToGLSL(this.#a9.Parameters[nM].NameToken.Text),nM<this.#a9.Parameters.length-1&&(n_+=", ");if(n_+=");\n\n",null!=this.#a9.Semantic&&"SV_POSITION"==this.#a9.Semantic.toUpperCase())n_+="	gl_Position = "+PrefixVSOutput+";\n";else{let nF=null,nb=this.#b2(this.#a9.ReturnType);for(let ny=0;ny<nb.Members.length;ny++){let nv=nb.Members[ny];null!=nv.Semantic&&"SV_POSITION"==nv.Semantic.toUpperCase()?nF=nv.NameToken.Text:n_+="	"+PrefixVarying+nv.Semantic+" = "+PrefixVSOutput+"."+nv.NameToken.Text+";\n"}n_+="	gl_Position = "+PrefixVSOutput+"."+nF+";\n"}return n_+="	gl_PointSize = 1.0;\n",n_+="}\n"}#ce(){if(null==this.#a9)throw Error("Missing main() function in shader");let n1=[];for(let nN=0;nN<this.#a9.Parameters.length;nN++){let nB=this.#a9.Parameters[nN];if(this.#bs(nB.DataTypeToken.Text)){let nG=this.#b2(nB.DataTypeToken.Text);if(null==nG)throw Error("Invalid data type in pixel shader input");for(let nO=0;nO<nG.Members.length;nO++)n1.push(nG.Members[nO])}else n1.push(nB)}return n1}#cf(nU){if(0==nU.length)return"";let nk="",n0=!1;for(let nV=0;nV<this.#a9.Parameters.length;nV++){let nX=this.#a9.Parameters[nV];if(this.#bs(nX.DataTypeToken.Text)){let n2=this.#b2(nX.DataTypeToken.Text);for(let nH=0;nH<n2.Members.length;nH++){let nW=n2.Members[nH];if(null!=nW.Semantic&&"SV_POSITION"==nW.Semantic.toUpperCase()){n0=!0;continue}nk+="in "+HLSL.TranslateToGLSL(nW.DataTypeToken.Text),nk+=" "+PrefixVarying+nW.Semantic+";\n"}}else null!=nX.Semantic&&"SV_POSITION"==nX.Semantic.toUpperCase()?n0=!0:(nk+="in "+HLSL.TranslateToGLSL(nX.DataTypeToken.Text),nk+=" "+PrefixVarying+nX.Semantic+";\n")}return nk+"\n"}#cg(nz){let n3="void main()\n";n3+="{\n";for(let n6=0;n6<nz.length;n6++)n3+="	"+HLSL.TranslateToGLSL(nz[n6].DataTypeToken.Text)+" "+nz[n6].NameToken.Text+" = ","SV_POSITION"==nz[n6].Semantic.toUpperCase()?n3+="gl_FragCoord;\n":n3+=PrefixVarying+nz[n6].Semantic+";\n";for(let nq=0;nq<this.#a9.Parameters.length;nq++){let nY=this.#a9.Parameters[nq];if(this.#bs(nY.DataTypeToken.Text)){let n4=HLSL.TranslateToGLSL(nY.NameToken.Text);n3+="\n	"+nY.DataTypeToken.Text,n3+=" "+n4+";\n";let n7=this.#b2(nY.DataTypeToken.Text);for(let n5=0;n5<n7.Members.length;n5++){let nj=n7.Members[n5];n3+="	"+n4+"."+HLSL.TranslateToGLSL(nj.NameToken.Text)+" = ",n3+=HLSL.TranslateToGLSL(nj.NameToken.Text)+";\n"}}}n3+="\n	"+HLSL.TranslateToGLSL(this.#a9.ReturnType)+" "+PrefixPSOutput+" = hlsl_main(";for(let nZ=0;nZ<this.#a9.Parameters.length;nZ++)n3+=HLSL.TranslateToGLSL(this.#a9.Parameters[nZ].NameToken.Text),nZ<this.#a9.Parameters.length-1&&(n3+=", ");if(n3+=");\n\n",null!=this.#a9.Semantic&&("SV_TARGET"==this.#a9.Semantic.toUpperCase()||"SV_TARGET0"==this.#a9.Semantic.toUpperCase()))n3+="	"+PSOutputVariable+" = "+PrefixPSOutput+";\n";else{let nQ=null,nK=this.#b2(this.#a9.ReturnType);for(let nJ=0;nJ<nK.Members.length;nJ++){let n9=nK.Members[nJ];if(null!=n9.Semantic&&("SV_TARGET"==n9.Semantic.toUpperCase()||"SV_TARGET0"==n9.Semantic.toUpperCase()))nQ=n9.NameToken.Text;else throw Error("Error converting pixel shader: Only 1 render target currently supported")}n3+="	"+PSOutputVariable+" = "+PrefixPSOutput+"."+nQ+";\n"}return n3+"}\n"}#b1(){let le="#version 300 es\n\n",lt=this.#ce();return le+="precision mediump float;\n\n",le+="precision mediump sampler3D;\n\n",le+="out vec4 "+PSOutputVariable+";\n\n",le+=this.#cf(lt),le+=this.#b8(),le+=this.#b9(),le+=this.#ca(),le+=this.#b3(),le+=this.#b4(),le+=this.#cb(),le+=this.#cc(),le+=this.#cg(lt)}}class ShaderElement{}class ShaderElementCBuffer extends ShaderElement{Name;NameGL;RegisterIndex;Members;constructor(e,t,r,s=[]){super(),this.Name=e,this.NameGL=t,this.RegisterIndex=r,this.Members=s}}class ShaderElementFunction extends ShaderElement{ReturnType;Name;Semantic;Parameters;Statements;constructor(e,t,r,s,i){super(),this.ReturnType=e,this.Name=t,this.Semantic=r,this.Parameters=s,this.Statements=i}ToString(e,t=""){let r="";switch(e){default:case 0:throw Error("IMPLEMENT ME");case 1:r+=HLSL.TranslateToGLSL(this.ReturnType)+" "+HLSL.TranslateToGLSL(t+this.Name)+"(";for(let s=0;s<this.Parameters.length;s++)r+=this.Parameters[s].ToString(e,!0),s<this.Parameters.length-1&&(r+=", ");r+=")\n",r+="{\n";for(let i=0;i<this.Statements.length;i++)r+=this.Statements[i].ToString(e,"	")+"\n";r+="}"}return r}}class ShaderElementSampler extends ShaderElement{Type;Name;RegisterIndex;constructor(e,t,r){super(),this.Type=e,this.Name=t,this.RegisterIndex=r}}class ShaderElementStruct extends ShaderElement{Name;Members;constructor(e,t){super(),this.Name=e,this.Members=t}ToString(e){let t="struct "+this.Name+"\n";t+="{\n";for(let r=0;r<this.Members.length;r++)t+=this.Members[r].ToString(e,"	");return t+"}\n"}}class ShaderElementTexture extends ShaderElement{Type;Name;RegisterIndex;constructor(e,t,r){super(),this.Type=e,this.Name=t,this.RegisterIndex=r}}class ShaderElementCombinedTextureAndSampler extends ShaderElement{TextureName;SamplerName;CombinedName;Texture;Sampler;constructor(e,t,r,s){super(),this.TextureName=e,this.SamplerName=t,this.CombinedName="combined_"+e+"_"+t,this.Texture=r,this.Sampler=s}}class Statement{}class StatementBlock extends Statement{Statements;constructor(e){super(),this.Statements=e}ToString(e,t=""){let r=t+"{\n";for(let s=0;s<this.Statements.length;s++)r+=this.Statements[s].ToString(e,t+"	")+"\n";return r+(t+"}")}}class StatementCase extends Statement{CaseValueExpression;Statements;constructor(e,t){super(),this.CaseValueExpression=e,this.Statements=t}ToString(e,t=""){let r=t+"case "+this.CaseValueExpression.ToString(e)+":\n";for(let s=0;s<this.Statements.length;s++)r+=this.Statements[s].ToString(e,t+"	")+"\n";return r}}class StatementDefault extends Statement{Statements;constructor(e){super(),this.Statements=e}ToString(e,t=""){let r=t+"default:\n";for(let s=0;s<this.Statements.length;s++)r+=this.Statements[s].ToString(e,t+"	")+"\n";return r}}class StatementDoWhile extends Statement{Body;Condition;constructor(e,t){super(),this.Body=e,this.Condition=t}ToString(e,t=""){let r=t+"do\n";return r+=this.Body.ToString(e,t+"	"),r+=t+"while("+this.Condition.ToString(e)+");\n"}}class StatementExpression extends Statement{Exp;constructor(e){super(),this.Exp=e}ToString(e,t=""){return t+this.Exp.ToString(e)+";"}}class StatementFor extends Statement{InitStatement;ConditionExpression;IterateExpression;BodyStatement;constructor(e,t,r,s){super(),this.InitStatement=e,this.ConditionExpression=t,this.IterateExpression=r,this.BodyStatement=s}ToString(e,t=""){let r=t+"for(";return r+=this.InitStatement.ToString(e,"")+" ",r+=this.ConditionExpression.ToString(e)+"; ",r+=this.IterateExpression.ToString(e)+")\n",r+=this.BodyStatement.ToString(e,t+"	")}}class StatementIf extends Statement{Condition;If;Else;constructor(e,t,r){super(),this.Condition=e,this.If=t,this.Else=r}ToString(e,t=""){let r=t+"if("+this.Condition.ToString(e)+")\n";return r+=this.If.ToString(e,t+"	")+"\n",null!=this.Else&&(r+=t+"else\n",r+=this.Else.ToString(e,t+"	")+"\n"),r}}class StatementJump extends Statement{JumpToken;constructor(e){super(),this.JumpToken=e}ToString(e,t=""){return t+this.JumpToken.Text+";"}}class StatementReturn extends Statement{Expression;constructor(e){super(),this.Expression=e}ToString(e,t=""){return t+"return "+this.Expression.ToString(e)+";"}}class StatementSwitch extends Statement{SelectorExpression;Cases;constructor(e,t){super(),this.SelectorExpression=e,this.Cases=t}ToString(e,t=""){let r=t+"switch("+this.SelectorExpression.ToString(e)+")\n";r+=t+"{\n";for(let s=0;s<this.Cases.length;s++)r+=this.Cases[s].ToString(e,t+"	");return r+(t+"}")}}class StatementWhile extends Statement{Condition;Body;constructor(e,t){super(),this.Condition=e,this.Body=t}ToString(e,t=""){let r=t+"while("+this.Condition.ToString(e)+")\n";return r+this.Body.ToString(e,t+"	")}}class StatementVar extends Statement{IsConst;DataTypeToken;VarDecs;constructor(e,t,r){super(),this.IsConst=e,this.DataTypeToken=t,this.VarDecs=r}ToString(e,t=""){let r=t;for(let s=0;s<this.VarDecs.length;s++)s>0&&(r+=", "),r+=this.VarDecs[s].ToString(e,0==s);return r+";"}}class VarDec extends Statement{DataTypeToken;NameToken;ArrayExpression;DefinitionExpression;IsConst;InputModifier;InterpModifiers;Semantic;constructor(e,t,r,s,i,a=null,n=[],l=null){super(),this.IsConst=e,this.DataTypeToken=t,this.NameToken=r,this.ArrayExpression=s,this.DefinitionExpression=i,this.InputModifier=a,this.InterpModifiers=n,this.Semantic=l}ToString(e,t){let r="";if(t){this.IsConst&&(r+="const ");for(let s=0;0==e&&s<this.InterpModifiers.length;s++)r+=this.InterpModifiers[s]+" ";switch(null!=this.InputModifier&&(r+=this.InputModifier+" "),e){default:case 0:r+=this.DataTypeToken.Text+" ";break;case 1:r+=HLSL.TranslateToGLSL(this.DataTypeToken.Text)+" "}}switch(e){default:case 0:r+=this.NameToken.Text;break;case 1:r+=HLSL.TranslateToGLSL(this.NameToken.Text)}return null!=this.ArrayExpression&&(r+="["+this.ArrayExpression.ToString(e)+"]"),0==e&&null!=this.Semantic&&(r+=" : "+this.Semantic),null!=this.DefinitionExpression&&(r+=" = "+this.DefinitionExpression.ToString(e)),r}}class Expression{}class ExpArray extends Expression{ExpArray;ExpIndex;constructor(e,t){super(),this.ExpArray=e,this.ExpIndex=t}ToString(e){return this.ExpArray.ToString(e)+"["+this.ExpIndex.ToString(e)+"]"}}class ExpAssignment extends Expression{VarExp;AssignOperator;AssignExp;constructor(e,t,r){super(),this.VarExp=e,this.AssignOperator=t,this.AssignExp=r}ToString(e){return this.VarExp.ToString(e)+" "+this.AssignOperator+" "+this.AssignExp.ToString(e)}}class ExpBinary extends Expression{ExpLeft;OperatorToken;ExpRight;constructor(e,t,r){super(),this.ExpLeft=e,this.OperatorToken=t,this.ExpRight=r}ToString(e){return this.ExpLeft.ToString(e)+" "+this.OperatorToken.Text+" "+this.ExpRight.ToString(e)}}class ExpBitwise extends Expression{ExpLeft;OperatorToken;ExpRight;constructor(e,t,r){super(),this.ExpLeft=e,this.OperatorToken=t,this.ExpRight=r}ToString(e){return this.ExpLeft.ToString(e)+" "+this.OperatorToken.Text+" "+this.ExpRight.ToString(e)}}class ExpCast extends Expression{TypeToken;Exp;constructor(e,t){super(),this.TypeToken=e,this.Exp=t}ToString(e){switch(e){default:case 0:return"("+this.TypeToken.Text+")"+this.Exp.ToString(e);case 1:return HLSL.TranslateToGLSL(this.TypeToken.Text)+"("+this.Exp.ToString(e)+")"}}}class ExpFunctionCall extends Expression{FuncExp;Parameters;IsTextureSample;CombinedTextureAndSampler;constructor(e,t){super(),this.FuncExp=e,this.Parameters=t,this.IsTextureSample=!1,this.CombinedTextureAndSampler=null}ToString(e){if(1==e&&this.IsTextureSample){let t=this.FuncExp.ExpRight.VarToken.Text;if(!HLSLTextureSampleConversion.hasOwnProperty(t))throw Error("Sample function type not yet implemented!");let r=HLSLTextureSampleConversion[t]+"("+this.CombinedTextureAndSampler.CombinedName+", ",s=this.Parameters[1].ToString(e);switch(this.CombinedTextureAndSampler.Texture.Type){case"Texture1D":s="vec2("+s+", 0.5)";break;case"Texture2D":s="vec2(0.0, 1.0) + vec2(1.0, -1.0) * ("+s+")";break;case"Texture3D":s="vec3(0.0, 1.0, 0.0) + vec3(1.0, -1.0, 1.0) * ("+s+")";break;case"TextureCube":s="vec3(1.0, -1.0, 1.0) * ("+s+")";break;default:throw Error("Invalid texture type or not yet implemented")}r+=s;for(let i=2;i<this.Parameters.length;i++)r+=", "+this.Parameters[i].ToString(e);return r+")"}{let a=this.FuncExp.ToString(e);if(1==e&&this.FuncExp instanceof ExpVariable){let n=this.FuncExp.VarToken.Text;HLSLMatrixConstructorConversion.hasOwnProperty(n)&&(a=HLSLMatrixConstructorConversion[n])}a+="(";for(let l=0;l<this.Parameters.length;l++)l>0&&(a+=", "),a+=this.Parameters[l].ToString(e);return a+")"}}}class ExpGroup extends Expression{Exp;constructor(e){super(),this.Exp=e}ToString(e){return"("+this.Exp.ToString(e)+")"}}class ExpLiteral extends Expression{DataType;LiteralToken;constructor(e){super(),this.LiteralToken=e,this.DataType=HLSL.DataTypeFromLiteralToken(e)}ToString(e){return this.LiteralToken.Text}}class ExpLogical extends Expression{ExpLeft;OperatorToken;ExpRight;constructor(e,t,r){super(),this.ExpLeft=e,this.OperatorToken=t,this.ExpRight=r}ToString(e){return this.ExpLeft.ToString(e)+" "+this.OperatorToken.Text+" "+this.ExpRight.ToString(e)}}class ExpMember extends Expression{ExpLeft;ExpRight;constructor(e,t){super(),this.ExpLeft=e,this.ExpRight=t}RightmostChildIsVariable(){let e=this.ExpRight;for(;e instanceof ExpMember;)e=e.ExpRight;return e instanceof ExpVariable}ToString(e){switch(e){default:case 0:return this.ExpLeft.ToString(e)+"."+this.ExpRight.ToString(e);case 1:let t=this.ExpLeft.ToString(e),r=this.ExpRight.ToString(e);if(HLSLMatrixElementConversion.hasOwnProperty(r))return t+HLSLMatrixElementConversion[r];return t+"."+r}}}class ExpPostfix extends Expression{ExpLeft;OperatorToken;constructor(e,t){super(),this.ExpLeft=e,this.OperatorToken=t}ToString(e){return this.ExpLeft.ToString(e)+this.OperatorToken.Text}}class ExpTernary extends Expression{ExpCondition;ExpIf;ExpElse;constructor(e,t,r){super(),this.ExpCondition=e,this.ExpIf=t,this.ExpElse=r}ToString(e){return this.ExpCondition.ToString(e)+" ? "+this.ExpIf.ToString(e)+" : "+this.ExpElse.ToString(e)}}class ExpUnary extends Expression{OperatorToken;ExpRight;constructor(e,t){super(),this.OperatorToken=e,this.ExpRight=t}ToString(e){return this.OperatorToken.Text+this.ExpRight.ToString(e)}}class ExpVariable extends Expression{VarToken;constructor(e){super(),this.VarToken=e}ToString(e){switch(e){default:case 0:return this.VarToken.Text;case 1:return HLSL.TranslateToGLSL(this.VarToken.Text)}}}class ParseError extends Error{line;text;constructor(e,...t){super(...t),this.line=null==e?-1:e.Line,this.text=null==e?"":e.Text}}class ScopeStack{#ch;constructor(){this.#ch=[]}PushScope(){this.#ch.push([])}PopScope(){this.#ch.pop()}AddVarStatement(e){for(let t=0;t<e.VarDecs.length;t++)this.AddVar(e.VarDecs[t])}AddVar(e){if(0==this.#ch.length)throw Error("Cannot add variable to empty scope stack");let t=e.NameToken.Text;if(this.IsVarInCurrentScope(t))throw new ParseError(e.NameToken,"Redefinition of '"+t+"'");this.#ch[this.#ch.length-1].push(e)}IsVarInCurrentScope(e){let t=this.#ch[this.#ch.length-1];for(let r=0;r<t.length;r++)if(t[r].NameToken.Text==e)return!0;return!1}}