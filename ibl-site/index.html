<!DOCTYPE html>
<html class="h-100" data-bs-theme="dark">
<head>
	<script defer src="https://analytics.us.umami.is/script.js" data-website-id="c4512c2d-4b4a-45f2-afdf-3a2186e1e697"></script>
	<script src="/build/d3d11.js"></script>
	<!-- WebGL Debugging --><!--<script type="text/javascript" src="/build/spector.bundle.js"></script>-->

	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
	<style>

		.accordion-button:focus {
			box-shadow: none;
			border-color: rgba(0,0,0,.125);
		}

		.fixed-size-custom {
			width: 250px !important;
		}

		.left-column-min-width {
			min-width: 400px;
		}

		.canvas-container {
			position: relative;
		}

		.canvas-fill-parent {
			width: 100%;
			height: 100%;
			max-height: 100vh;
			outline: none;
		}

		.over-canvas {
			position: absolute;
			top: 0px;
			left: 0px;
			z-index: 2;
			margin: 0 auto;
		}

		.hover-pointer {
			cursor: pointer;
		}
	</style>
</head>
<body class="h-100 m-0 p-0">

	<!-- Trying out bootstrap -->
	<!-- Main "container", but skipping actual .container class to ensure edge-to-edge page! -->
	<div class="row h-100 m-0 p-0 overflow-hidden">

		<!-- Left "sidebar", scrollable-->
		<div class="col-3 h-100 overflow-y-auto left-column-min-width">

			<!-- Overall title-->
			<div class="text-center">
				<h3>Image-Based.Lighting <span class="fs-6 align-middle">Alpha!</span></h3>
			</div>
			

			<!-- Testing accordian navigation -->
			<div class="accordion" id="main-nav">

				<!-- SCENE -->
				<div class="accordion-item">
					<h2 class="accordion-header">
						<button class="accordion-button collapsed p-2 bg-gradient" type="button" data-bs-toggle="collapse" data-bs-target="#scene-accordion" aria-expanded="false" aria-controls="scene-accordion">
							<h5 class="m-0">&#127760; Model & Material</h5>
						</button>
					</h2>
					<div id="scene-accordion" class="accordion-collapse collapse">
						<div class="accordion-body p-3">

							<h6>&#128260; Model</h6>

							<!-- MODEL -->
							<div class="input-group input-group-sm mb-3">
								<!--<label for="sceneSet" class="input-group-text">&#127760; Model</label>-->
								<select id="sceneSet" class="form-select" onchange="setScene(this.value);">
									<option value="0" selected>Sphere</option>
									<option value="1">Helix</option>
									<option value="2">Cube</option>
									<option value="3">Roughness Grid</option>
									<option value="4">RGB Grid</option>
								</select>
							</div>

							<!-- MATERIAL -->
							<div id="material">
								<h6>&#127912; Material</h6>

								<!-- TEXTURES -->
								<div class="input-group input-group-sm row ms-0">
									<label for="textureSet" class="col-4 input-group-text">Texture Set</label>
									<select id="textureSet" class="col form-select px-3" onchange="setTextureSet(this.value);">
										<option value="-1">Custom (No Textures)</option>
										<option value="0" selected>Cobblestone</option>
										<option value="1">Bronze</option>
										<option value="2">Scratched Paint</option>
										<option value="3">Metal Plate</option>
										<option value="4">Slab Tiles</option>
										<option value="5">Stone Tiles</option>
										<option value="6">Diagonal Parquet</option>
									</select>
								</div>

								<!-- CUSTOM -->
								<div id="custom-material-controls" class="d-none">

									<!-- COLOR PICKER -->
									<div class="input-group input-group-sm row ms-0">
										<label for="material-color" class="col-4 input-group-text">Color Tint</label>
										<input id="material-color" type="color" class="col form-control form-control-color px-3" value="#ffffff" title="Color Tint" oninput="setMatColor(this.value);" />
									</div>

									<!-- ROUGHNESS -->
									<div class="input-group input-group-sm row ms-0">
										<label for="material-roughness" class="col-4 input-group-text">Roughness: 0.5</label>
										<input id="material-roughness" type="range" class="col form-control form-range p-3" min="0" max="1" step="0.01" value="0.5" oninput="setMatRoughness(this.value); this.previousElementSibling.innerHTML = 'Roughness: ' + this.value;" />
									</div>

									<!-- METALNESS -->
									<div class="row input-group input-group-sm ms-0">
										<label for="material-metalness" class="col-4 input-group-text">Metalness: 0</label>
										<input id="material-metalness" type="range" class="col form-control form-range p-3" min="0" max="1" step="0.01" value="0" oninput="setMatMetalness(this.value); this.previousElementSibling.innerHTML = 'Metalness: ' + this.value;" />
									</div>
								</div>
							</div>

						</div>
					</div>
				</div>

				<!-- ENVIRONMENT -->
				<div class="accordion-item">
					<h2 class="accordion-header">
						<button class="accordion-button p-2 collapsed bg-gradient" type="button" data-bs-toggle="collapse" data-bs-target="#environment-accordion" aria-expanded="false" aria-controls="environment-accordion">
							<h5 class="m-0">&#127966;&#65039; Environment</h5>
						</button>
					</h2>
					<div id="environment-accordion" class="accordion-collapse collapse">
						<div class="accordion-body p-3">

							<!-- CHOOSE ENV MAP -->
							<h6>&#128194; Select or Load Environment</h6>
							<div class="input-group input-group-sm mb-3">
								<select class="form-select" id="env-map-select" onchange="setEnvMap(this.value);">

									<option value="0">Pine Attic</option>
									<option value="1">Hilly Terrain</option>
									<option value="2">Castle Zavelstein Cellar</option>
									<option value="3">Studio Small 03</option>
									<option value="4">White Furnace</option>
									<option value="load6">&#127922; Load Six Faces</option>
									<option value="loadDDS">&#128230; Load .DDS Cube Map</option>
									<option value="loadHDR">&#127748; Load Equirectangular .HDR File</option>

								</select>
							</div>

							<!-- LOAD SIX FACES -->
							<div id="load-six-controls" class="d-none mb-3">

								<div class="input-group input-group-sm text-center">
									<label for="sixFacesXPos" class="input-group-text" style="min-width:50px;">+X</label>
									<input class="form-control" type="file" id="sixFacesXPos" />
								</div>

								<div class="input-group input-group-sm">
									<label for="sixFacesXNeg" class="input-group-text" style="min-width: 50px;">- X</label>
									<input class="form-control" type="file" id="sixFacesXNeg" />
								</div>

								<div class="input-group input-group-sm">
									<label for="sixFacesYPos" class="input-group-text" style="min-width:50px;">+Y</label>
									<input class="form-control" type="file" id="sixFacesYPos" />
								</div>

								<div class="input-group input-group-sm">
									<label for="sixFacesYNeg" class="input-group-text" style="min-width:50px;">- Y</label>
									<input class="form-control" type="file" id="sixFacesYNeg" />
								</div>

								<div class="input-group input-group-sm">
									<label for="sixFacesZPos" class="input-group-text" style="min-width:50px;">+Z</label>
									<input class="form-control" type="file" id="sixFacesZPos" />
								</div>

								<div class="input-group input-group-sm">
									<label for="sixFacesZNeg" class="input-group-text" style="min-width:50px;">- Z</label>
									<input class="form-control" type="file" id="sixFacesZNeg" />
								</div>

								<button type="button" class="btn btn-sm btn-primary w-100" onclick="loadSixFaces();">Load Six Faces</button>

							</div>

							<!-- LOAD DDS CUBE MAP -->
							<div id="load-dds-controls" class="d-none mb-3">
								<div class="input-group input-group-sm mb-3">
									<label for="ddsFile" class="input-group-text">.DDS Cube</label>
									<input id="ddsFile"  class="form-control" type="file" onchange="loadDDS();"/>
								</div>
							</div>

							<!-- LOAD HDR -->
							<div id="load-hdr-controls" class="d-none mb-3">
								<div class="input-group input-group-sm">
									<label for="hdrFile" class="input-group-text">.HDR File</label>
									<input id="hdrFile" class="form-control" type="file" onchange="loadHDR();"/>
								</div>
							</div>

							<!-- SKY MIP PREVIEW -->
							<h6>&#128269; Skybox Mip Preview</h6>

							<div class="row input-group input-group-sm ms-0 mb-3">
								<label for="mipLevelRange" class="col-3 input-group-text">Mip: 0</label>
								<input id="mipLevelRange" type="range" class="col form-control form-range p-3" min="0" max="16" value="0" oninput="setSkyMipPreview(this.value); this.previousElementSibling.innerHTML = 'Mip: ' + this.value;" />
							</div>

							<!-- LIGHTS -->
							<h6>&#128161; Additional Lights</h6>
							<div class="input-group input-group-sm">
								<!--<label for="lightSet" class="input-group-text">&#128161; Lights</label>-->
								<select id="lightSet" class="form-select" onchange="setLighting(this.value);">
									<option value="0" selected>No Lights (Sky Only)</option>
									<option value="1">One Directional Light</option>
									<option value="2">Three Directional Lights</option>
								</select>
							</div>

						</div>
					</div>
				</div>

				<!-- IBL DETAILS -->
				<div class="accordion-item">
					<h2 class="accordion-header">
						<button class="accordion-button p-2 collapsed bg-gradient" type="button" data-bs-toggle="collapse" data-bs-target="#ibl-accordion" aria-expanded="false" aria-controls="ibl-accordion">
							<h5 class="m-0">&#x1F5BC;&#xFE0F; IBL Options</h5>
						</button>
					</h2>
					<div id="ibl-accordion" class="accordion-collapse collapse">
						<div class="accordion-body p-3">

							<!-- HDR Status -->
							<h6>&#128248; Dynamic Range</h6>
							<div class="input-group input-group-sm">
								<span class="input-group-text col">Environment is HDR?</span>
								<span id="hdr-status" class="input-group-text">No</span>
							</div>

							<div id="ibl-exposure-container" class="row input-group input-group-sm ms-0 d-none">
								<label for="ibl-exposure-range" class="col-6 input-group-text">Baked IBL Exposure: 0</label>
								<input id="ibl-exposure-range" type="range" class="col form-control form-range p-3" min="-10" max="10" step="0.01" value="0" oninput="setIBLExposure(this.value); this.previousElementSibling.innerHTML = 'Baked IBL Exposure: ' + this.value;" />
							</div>
							

							<!-- RESOLUTIONS -->
							<!-- BRDF Look up table -->
							<h6 class="mt-3">&#128200; Environment BRDF Lookup Table</h6>
							<div class="input-group input-group-sm ms-0">
								<label class="input-group-text col">Size</label>

								<input id="brdf-lut-res-0" name="brdf-lut-res" type="radio" class="btn-check" value="2048" autocomplete="off" onchange="setLutSize(this.value);">
								<label for="brdf-lut-res-0" class="btn btn-outline-secondary">2048</label>

								<input id="brdf-lut-res-1" name="brdf-lut-res" type="radio" class="btn-check" value="1024" autocomplete="off" onchange="setLutSize(this.value);" checked>
								<label for="brdf-lut-res-1" class="btn btn-outline-secondary">1024</label>

								<input id="brdf-lut-res-2" name="brdf-lut-res" type="radio" class="btn-check" value="512" autocomplete="off" onchange="setLutSize(this.value);">
								<label for="brdf-lut-res-2" class="btn btn-outline-secondary">512</label>

								<input id="brdf-lut-res-3" name="brdf-lut-res" type="radio" class="btn-check" value="256" autocomplete="off" onchange="setLutSize(this.value);">
								<label for="brdf-lut-res-3" class="btn btn-outline-secondary">256</label>

								<input id="brdf-lut-res-4" name="brdf-lut-res" type="radio" class="btn-check" value="128" autocomplete="off" onchange="setLutSize(this.value);">
								<label for="brdf-lut-res-4" class="btn btn-outline-secondary">128</label>

								<input id="brdf-lut-res-5" name="brdf-lut-res" type="radio" class="btn-check" value="64" autocomplete="off" onchange="setLutSize(this.value);">
								<label for="brdf-lut-res-5" class="btn btn-outline-secondary">64</label>
							</div>

							<div class="input-group input-group-sm mb-3">
								<label for="brdf-lut-multiscatter" class="input-group-text col">Multiscattering Compensation</label>
								<div class="input-group-text">
									<input id="brdf-lut-multiscatter" class="form-check-input" type="checkbox" onchange="setMultiscatter(this.checked);"/>
								</div>
							</div>


							<!-- Irradiance -->
							<h6>&#9925; Irradiance (Diffuse) Map</h6>
							<div class="input-group input-group-sm ms-0 mb-3">
								<label class="input-group-text col">Size</label>

								<input id="irr-res-0" name="irr-res" type="radio" class="btn-check" value="2048" autocomplete="off" onchange="setIrrSize(this.value);">
								<label for="irr-res-0" class="btn btn-outline-secondary">2048</label>

								<input id="irr-res-1" name="irr-res" type="radio" class="btn-check" value="1024" autocomplete="off" onchange="setIrrSize(this.value);">
								<label for="irr-res-1" class="btn btn-outline-secondary">1024</label>

								<input id="irr-res-2" name="irr-res" type="radio" class="btn-check" value="512" autocomplete="off" onchange="setIrrSize(this.value);">
								<label for="irr-res-2" class="btn btn-outline-secondary">512</label>

								<input id="irr-res-3" name="irr-res" type="radio" class="btn-check" value="256" autocomplete="off" onchange="setIrrSize(this.value);" checked>
								<label for="irr-res-3" class="btn btn-outline-secondary">256</label>

								<input id="irr-res-4" name="irr-res" type="radio" class="btn-check" value="128" autocomplete="off" onchange="setIrrSize(this.value);">
								<label for="irr-res-4" class="btn btn-outline-secondary">128</label>

								<input id="irr-res-5" name="irr-res" type="radio" class="btn-check" value="64" autocomplete="off" onchange="setIrrSize(this.value);">
								<label for="irr-res-5" class="btn btn-outline-secondary">64</label>
							</div>

							<!-- Specular (Largest Mip) -->
							<h6>&#128302; Specular Map - Total Mip Levels: <span id="spec-mip-levels">7</span></h6>
							<div class="input-group input-group-sm ms-0 mb-1">
								<label class="input-group-text col">Size</label>

								<input id="spec-res-large-0" name="spec-res-large" type="radio" class="btn-check" value="2048" autocomplete="off" onchange="setSpecIBLSize(this.value);">
								<label for="spec-res-large-0" class="btn btn-outline-secondary">2048</label>

								<input id="spec-res-large-1" name="spec-res-large" type="radio" class="btn-check" value="1024" autocomplete="off" onchange="setSpecIBLSize(this.value);">
								<label for="spec-res-large-1" class="btn btn-outline-secondary">1024</label>

								<input id="spec-res-large-2" name="spec-res-large" type="radio" class="btn-check" value="512" autocomplete="off" onchange="setSpecIBLSize(this.value);" checked>
								<label for="spec-res-large-2" class="btn btn-outline-secondary">512</label>

								<input id="spec-res-large-3" name="spec-res-large" type="radio" class="btn-check" value="256" autocomplete="off" onchange="setSpecIBLSize(this.value);">
								<label for="spec-res-large-3" class="btn btn-outline-secondary">256</label>

								<input id="spec-res-large-4" name="spec-res-large" type="radio" class="btn-check" value="128" autocomplete="off" onchange="setSpecIBLSize(this.value);">
								<label for="spec-res-large-4" class="btn btn-outline-secondary">128</label>

								<input id="spec-res-large-5" name="spec-res-large" type="radio" class="btn-check" value="64" autocomplete="off" onchange="setSpecIBLSize(this.value);">
								<label for="spec-res-large-5" class="btn btn-outline-secondary">64</label>
							</div>

							<!-- Specular (Smallest Mip) -->
							<div class="input-group input-group-sm ms-0 mb-3">
								<label class="input-group-text col">Smallest Mip</label>

								<input id="spec-res-small-0" name="spec-res-small" type="radio" class="btn-check" value="32" autocomplete="off" onchange="setSpecIBLSmallestMip(this.value);">
								<label for="spec-res-small-0" class="btn btn-outline-secondary">32</label>

								<input id="spec-res-small-1" name="spec-res-small" type="radio" class="btn-check" value="16" autocomplete="off" onchange="setSpecIBLSmallestMip(this.value);">
								<label for="spec-res-small-1" class="btn btn-outline-secondary">16</label>

								<input id="spec-res-small-2" name="spec-res-small" type="radio" class="btn-check" value="8" autocomplete="off" onchange="setSpecIBLSmallestMip(this.value);" checked>
								<label for="spec-res-small-2" class="btn btn-outline-secondary">8</label>

								<input id="spec-res-small-3" name="spec-res-small" type="radio" class="btn-check" value="4" autocomplete="off" onchange="setSpecIBLSmallestMip(this.value);">
								<label for="spec-res-small-3" class="btn btn-outline-secondary">4</label>

								<input id="spec-res-small-4" name="spec-res-small" type="radio" class="btn-check" value="2" autocomplete="off" onchange="setSpecIBLSmallestMip(this.value);">
								<label for="spec-res-small-4" class="btn btn-outline-secondary">2</label>

								<input id="spec-res-small-5" name="spec-res-small" type="radio" class="btn-check" value="1" autocomplete="off" onchange="setSpecIBLSmallestMip(this.value);">
								<label for="spec-res-small-5" class="btn btn-outline-secondary">1</label>
							</div>

							<!-- IBL ASSET PREVIEW -->
							<h6>&#128269; Preview IBL Assets</h6>

							<div class="input-group input-group-sm">
								<label for="preview-brdf-lut" class="input-group-text col hover-pointer">Env. BRDF Lookup Table (2D)</label>
								<div class="input-group-text">
									<input id="preview-brdf-lut" class="form-check-input hover-pointer" type="checkbox" onchange="setLutPreview(this.checked);"/>
								</div>
							</div>
							<div class="input-group input-group-sm">
								<label for="preview-irr" class="input-group-text col hover-pointer">Irradiance (Cube)</label>
								<div class="input-group-text">
									<input id="preview-irr" class="form-check-input hover-pointer" type="checkbox" onchange="setIrrPreview(this.checked);" />
								</div>
							</div>
							<div class="input-group input-group-sm">
								<label for="preview-spec" class="input-group-text col hover-pointer">Specular (Cube)</label>
								<div class="input-group-text">
									<input id="preview-spec" class="form-check-input hover-pointer" type="checkbox" onchange="setSpecPreview(this.checked);" />
								</div>
							</div>

							<div class="row input-group input-group-sm ms-0 d-none" id="ibl-prev-mip-controls">
								<label for="iblPrevMipRange" class="col-2 input-group-text">Mip: 0</label>
								<input id="iblPrevMipRange" type="range" class="col form-control form-range p-3" min="0" max="16" value="0" oninput="setIblMipPreview(this.value); this.previousElementSibling.innerHTML = 'Mip: ' + this.value;" />
							</div>




						</div>
					</div>
				</div>

				<!-- SAVE -->
				<div class="accordion-item">
					<h2 class="accordion-header">
						<button class="accordion-button p-2 collapsed bg-gradient" type="button" data-bs-toggle="collapse" data-bs-target="#save-accordion" aria-expanded="false" aria-controls="save-accordion">
							<h5 class="m-0">&#128190; Save IBL Maps</h5>
						</button>
					</h2>
					<div id="save-accordion" class="accordion-collapse collapse">
						<div class="accordion-body p-3">
							<p>Save any of the generated Image-Based Lighting maps</p>
							<button class="btn btn-primary mb-1 w-100" id="buttonSaveSky" onclick="window.saveSkyToFile();" disabled>Save Skybox as DDS Cube Map</button><br />
							<button class="btn btn-primary mb-1 w-100" id="buttonSaveIrr" onclick="window.saveIrrToFile();" disabled>Save Irradiance as DDS Cube Map</button><br />
							<button class="btn btn-primary mb-1 w-100" id="buttonSaveIBL" onclick="window.saveIBLToFile();" disabled>Save IBL Specular as DDS Cube Map</button><br />
							<button class="btn btn-primary mb-1 w-100" id="buttonSaveLUT" onclick="window.saveLUTToFile();" disabled>Save BRDF Look Up Table as DDS Texture</button>
						</div>
					</div>
				</div>

				<!-- POST PROCESSING -->
				<div class="accordion-item">
					<h2 class="accordion-header">
						<button class="accordion-button p-2 collapsed bg-gradient" type="button" data-bs-toggle="collapse" data-bs-target="#post-accordion" aria-expanded="false" aria-controls="post-accordion">
							<h5 class="m-0">&#128250; Post-Processing</h5>
						</button>
					</h2>
					<div id="post-accordion" class="accordion-collapse collapse">
						<div class="accordion-body p-3">
							<p>Fine-tune the rendered image in the viewport. This does not affect the IBL maps.</p>

							<div id="tonemapping-contanier" class="d-none">
								<h6>&#127912; HDR Tonemapping</h6>

								<p>Exposure is applied prior to tonemapping.</p>
								<div class="row input-group input-group-sm ms-0">
									<label for="exposureRange" class="col-4 input-group-text">Exposure: 0</label>
									<input id="exposureRange" type="range" class="col form-control form-range p-3" min="-10" max="10" step="0.01" value="0" oninput="setTonemapExposure(this.value); this.previousElementSibling.innerHTML = 'Exposure: ' + this.value;" />
								</div>
								<div class="input-group input-group-sm">
									<label for="tonemapType" class="col-4 input-group-text">Tonemap Type</label>
									<select id="tonemapType" class="form-select" onchange="setTonemapType(this.value);">
										<option value="0" selected>None</option>
										<option value="1">Reinhard</option>
										<option value="2">Reinhard (White Point)</option>
										<option value="3">Uncharted 2</option>
										<option value="4">Aces</option>
									</select>
								</div>
								<div class="row input-group input-group-sm ms-0 d-none" id="white-point-controls">
									<label for="whitePointRange" class="col-4 input-group-text">White Point: 2</label>
									<input id="whitePointRange" type="range" class="col form-control form-range p-3" min="0" max="20" step="0.01" value="2" oninput="setWhitePoint(this.value); this.previousElementSibling.innerHTML = 'White Point: ' + this.value;" />
								</div>
							</div>

							<div id="non-hdr-reminder">
								<p>Note: Tonemapping is not available when the environment map is not HDR</p>
							</div>

						</div>
					</div>
				</div>

				<!-- SETTINGS -->
				<div class="accordion-item">
					<h2 class="accordion-header">
						<button class="accordion-button p-2 collapsed bg-gradient" type="button" data-bs-toggle="collapse" data-bs-target="#settings-accordion" aria-expanded="false" aria-controls="settings-accordion">
							<h5 class="m-0">&#9881;&#65039; Settings</h5>
						</button>
					</h2>
					<div id="settings-accordion" class="accordion-collapse collapse">
						<div class="accordion-body p-3">

							<h6>&#127909; Camera</h6>
							<div class="row input-group input-group-sm ms-0 mb-0">
								<label for="fovRange" class="col-4 input-group-text">FoV: 45</label>
								<input id="fovRange" type="range" class="col form-control form-range p-3" min="20" max="120" value="45" oninput="setFov(this.value); this.previousElementSibling.innerHTML = 'FoV: ' + this.value;" />
							</div>
							<div class="row input-group input-group-sm ms-0 mb-0">
								<div class="col-4 input-group-text">Left Mouse</div>
								<div class="col input-group-text">Orbit</div>
							</div>
							<div class="row input-group input-group-sm ms-0 mb-0">
								<div class="col-4 input-group-text">Right Mouse</div>
								<div class="col input-group-text">WASD Movement & Mouse Look</div>
							</div>
							<div class="row input-group input-group-sm ms-0 mb-0">
								<div class="col-4 input-group-text">Double Click</div>
								<div class="col input-group-text">Recenter</div>
							</div>
							<div class="row input-group input-group-sm ms-0 mb-3">
								<div class="col-4 input-group-text">Wheel</div>
								<div class="col input-group-text">Zoom</div>
							</div>

							<h6>&#127767; Color Mode</h6>
							<div class="btn-group">
								<input type="radio" class="btn-check" name="color-mode" id="color-mode-light" autocomplete="off" onchange="setColorMode('light');" />
								<label class="btn btn-outline-secondary btn-sm" for="color-mode-light">Light</label>

								<input type="radio" class="btn-check" name="color-mode" id="color-mode-dark" autocomplete="off" checked onchange="setColorMode('dark');" />
								<label class="btn btn-outline-secondary btn-sm" for="color-mode-dark">Dark</label>
							</div>


						</div>
					</div>
				</div>

				<!-- ABOUT -->
				<div class="accordion-item">
					<h2 class="accordion-header">
						<button class="accordion-button p-2 collapsed bg-gradient" type="button" data-bs-toggle="collapse" data-bs-target="#about-accordion" aria-expanded="false" aria-controls="about-accordion">
							<h5 class="m-0">&#129516; About</h5>
						</button>
					</h2>
					<div id="about-accordion" class="accordion-collapse collapse">
						<div class="accordion-body p-3">

							<div class="card mb-3">
								<h6 class="card-header">&#129518; Details</h6>
								<div class="card-body">
									<p>Copyright © 2024 Chris Cascioli</p>
									<p>IBL map generation based on <a href="https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf" target="_blank">Real Shading in Unreal Engine 4</a> by Brian Karis</p>
									<p>Multiscattering compensation (<a href="https://google.github.io/filament/Filament.html#toc4.7.2" target="_blank">overview</a> and <a href="https://google.github.io/filament/Filament.html#toc5.3.4.7" target="_blank">pre-integration changes</a>) based on <a href="https://google.github.io/filament/Filament.html" target="_blank">Filament</a> by Google.</p>
									<p>Powered by 2-3 graphics APIs in a trench coat (<a href="https://github.com/vixorien/d3d11.js" target="_blank">d3d11.js</a>)</p>
								</div>
							</div>

							<div class="card mb-3">
								<h6 class="card-header">&#127912; Materials</h6>
								<div class="card-body">
									<p>Materials from <a href="https://polyhaven.com/" target="_blank">Polyhaven.com</a>.</p>
									<table class="table">
										<thead>
											<tr>
												<th scope="col">Material</th>
												<th scope="col">Author(s)</th>
												<th scope="col">License</th>
											</tr>
										</thead>
										<tbody>
											<tr>
												<td><a href="https://polyhaven.com/a/slab_tiles target="_blank"">Slab Tiles</a></td>
												<td>Dario Barresi, Dimitrios Savva</td>
												<td><a href="https://polyhaven.com/license" target="_blank">CC0</a></td>
											</tr>
											<tr>
												<td><a href="https://polyhaven.com/a/metal_plate target="_blank"">Metal Plate</a></td>
												<td>Rob Tuytel</td>
												<td><a href="https://polyhaven.com/license" target="_blank">CC0</a></td>
											</tr>
											<tr>
												<td><a href="https://polyhaven.com/a/diagonal_parquet target="_blank"">Diagonal Parquet</a></td>
												<td>Anonymous Bob, Jandre van Heerden</td>
												<td><a href="https://polyhaven.com/license" target="_blank">CC0</a></td>
											</tr>
											<tr>
												<td><a href="https://polyhaven.com/a/stone_tiles" target="_blank">Stone Tiles</a></td>
												<td>Christopher Melani</td>
												<td><a href="https://polyhaven.com/license" target="_blank">CC0</a></td>
											</tr>
										</tbody>
									</table>

									<p>The following materials are from the original (pre-Adobe) Allegorithmic "Substance Share" site: Cobblestone, Bronze, Scratched Paint.</p>
								</div>
							</div>

							<div class="card">
								<h6 class="card-header">&#127758; Environment Maps</h6>
								<div class="card-body mb-3">
									<p>Example environments from <a href="https://polyhaven.com/" target="_blank">Polyhaven.com</a>.</p>
									<table class="table">
										<thead>
											<tr>
												<th scope="col">Environment</th>
												<th scope="col">Author(s)</th>
												<th scope="col">License</th>
											</tr>
										</thead>
										<tbody>
											<tr>
												<td><a href="https://polyhaven.com/a/pine_attic" target="_blank">Pine Attic</a></td>
												<td>Sergej Majboroda</td>
												<td><a href="https://polyhaven.com/license" target="_blank">CC0</a></td>
											</tr>
											<tr>
												<td><a href="https://polyhaven.com/a/hilly_terrain_01" target="_blank">Hilly Terrain 01</a></td>
												<td>Sergej Majboroda</td>
												<td><a href="https://polyhaven.com/license" target="_blank">CC0</a></td>
											</tr>
											<tr>
												<td><a href="https://polyhaven.com/a/castle_zavelstein_cellar" target="_blank">Castle Zavelstein Cellar</a></td>
												<td>Andreas Mischok</td>
												<td><a href="https://polyhaven.com/license" target="_blank">CC0</a></td>
											</tr>
											<tr>
												<td><a href="https://polyhaven.com/a/studio_small_03" target="_blank">Small Studio 03</a></td>
												<td>Greg Zaal</td>
												<td><a href="https://polyhaven.com/license" target="_blank">CC0</a></td>
											</tr>
										</tbody>
									</table>

								</div>
							</div>


						</div>
					</div>
				</div>

			</div>



		</div>

		<!-- Content (3D viewport) -->
		<div class="col m-0 p-0 canvas-container">
			<canvas id="viewport" tabindex="1" class="canvas-fill-parent"></canvas>

			<div id="loading-container" class="card m-3 opacity-75 invisible over-canvas">
				<div class="card-body">
					<div class="spinner-border spinner-border-sm me-2"></div>
					<span id="loading-text">Loading!</span>
				</div>
			</div>
		</div>

	</div>


	<!-- END bootstrap -->

	<!-- WebGL Debugging -->
	<!--<script>
		var spector = new SPECTOR.Spector();
		spector.displayUI();
		spector.spyCanvases();
	</script>-->

	<script type="module">
		
		import { Vector2, Vector3, Matrix4x4 } from "/build/d3dmath.js";
		import { TextureUtils } from "/build/textureUtils.js";
		import { MappedArray } from "/build/mappedArray.js";
		import { Transform } from "/build/transform.js";
		import { FPSCamera, OrbitCamera } from "/build/camera.js";
		import { Material } from "/build/material.js";
		import { Entity } from "/build/entity.js";
		import { Vertex } from "/build/vertex.js";
		import { Light } from "/build/light.js";
		import { Scene } from "/build/scene.js";
		import { Mesh } from "/build/mesh.js";
		import { Sky } from "/build/sky.js";
		import { Input, Keys, MouseButtons } from "/build/input.js";

		// D3D objects
		let d3dDevice = null;
		let d3dContext = null;
		let d3dSwapChain = null;

		// Sky / Environment
		let sky = null;
		let skyMipLevelPreview = 0;
		let previewLut = false;
		let previewIrr = false;
		let previewSpec = false;
		let iblPreviewSize = 250;
		let iblPreviewBorder = 25;
		let iblPreviewCubeCamDist = 2.3;
		let iblMipPreview = 0;
		let defaultSkyPaths = [
			"/assets/skies/pine_attic_2k.hdr",
			"/assets/skies/hilly_terrain_2k.hdr",
			"/assets/skies/castle_zavelstein_cellar_2k.hdr",
			"/assets/skies/studio_small_03_2k.hdr",
			"/assets/skies/white_furnace.dds"
		];
		let textureSets = [
			[
				"/assets/textures/cobblestone_albedo.png",
				"/assets/textures/cobblestone_normals.png",
				"/assets/textures/cobblestone_arm.png"
			],
			[
				"/assets/textures/bronze_albedo.png",
				"/assets/textures/bronze_normals.png",
				"/assets/textures/bronze_arm.png"
			],
			[
				"/assets/textures/scratched_albedo.png",
				"/assets/textures/scratched_normals.png",
				"/assets/textures/scratched_arm.png"
			],
			[
				"/assets/textures/metalplate_albedo.png",
				"/assets/textures/metalplate_normals.png",
				"/assets/textures/metalplate_arm.png"
			],
			[
				"/assets/textures/slab_albedo.png",
				"/assets/textures/slab_normals.png",
				"/assets/textures/slab_arm.png"
			],
			[
				"/assets/textures/stonetiles_albedo.png",
				"/assets/textures/stonetiles_normals.png",
				"/assets/textures/stonetiles_arm.png"
			],
			[
				"/assets/textures/wood_albedo.png",
				"/assets/textures/wood_normals.png",
				"/assets/textures/wood_arm.png"
			]
		];

		// Tone mapping
		let tonemapType = 0;
		let tonemapExposure = 0;
		let tonemapWhitePoint = 2;

		// Scene-related
		let camera = null;
		let scenes = [];
		let currentScene = 0;
		let lightingSetups = [];
		let currentLighting = 0;
		let materials = [];
		let currentMaterial = 1;
		let currentTextureSet = 0;
		let customMatRoughness = 0.5;
		let customMatMetalness = 0;
		let customMatColor = [1, 1, 1];

		const MaxLights = 64;

		// --- Window-level functions called from outside this script ---

		window.showLoading = function (text)
		{
			let load = document.getElementById("loading-container");
			load.classList.remove("invisible");

			let loadText = document.getElementById("loading-text");
			loadText.innerHTML = text;
		}

		window.hideLoading = function ()
		{
			let load = document.getElementById("loading-container");
			load.classList.add("invisible");

			let loadText = document.getElementById("loading-text");
			loadText.innerHTML = "";
		}

		window.setEnvMap = async function (val)
		{
			function hide(id) { document.getElementById(id).classList.add("d-none"); }
			function show(id) { document.getElementById(id).classList.remove("d-none"); }

			// Ensure we hide everything first
			hide("load-six-controls");
			hide("load-dds-controls");
			hide("load-hdr-controls");

			// Depending on the value, we're either using a
			// built-in env. map or allowing the user to load
			// (which means updating the UI)
			switch (val)
			{
				case "load6":
					show("load-six-controls");
					break;

				case "loadDDS":
					show("load-dds-controls");
					break;

				case "loadHDR":
					show("load-hdr-controls");
					break;

				default:

					let path = defaultSkyPaths[val];
					if (path.endsWith(".hdr"))
					{
						showLoading("Loading HDR File");
						await sky.LoadEquirectHDRFromUrl(path);
					}
					else if (path.endsWith(".dds"))
					{
						showLoading("Loading DDS File");
						await sky.LoadDDSFileFromUrl(path);
					}
					break;
			}
		}
		
		window.setLutSize = function (val)
		{
			sky.SetBRDFLookUpTableSize(val);
		}

		window.setIrrSize = function (val)
		{
			sky.SetIrradianceSize(val);
		}

		window.setSpecIBLSize = function (val)
		{
			sky.SetSpecularIBLSize(val);
			document.getElementById("spec-mip-levels").innerHTML = sky.SpecularIBLMipsTotal;
		}

		window.setSpecIBLSmallestMip = function (val)
		{
			sky.SetSpecularIBLSmallestMipSize(val);
			document.getElementById("spec-mip-levels").innerHTML = sky.SpecularIBLMipsTotal;
		}

		window.setWhitePoint = function (val)
		{
			tonemapWhitePoint = val;
		}

		window.setMatRoughness = function (val)
		{
			customMatRoughness = val;
		}

		window.setMatMetalness = function (val)
		{
			customMatMetalness = val;
		}

		window.setMatColor = function (val)
		{
			let r = parseInt(val.substring(1, 3), 16) / 255.0;
			let g = parseInt(val.substring(3, 5), 16) / 255.0;
			let b = parseInt(val.substring(5, 7), 16) / 255.0;

			customMatColor = [r, g, b];
		}

		window.setTextureSet = async function (val)
		{
			// Which material are we using?
			currentMaterial = val == -1 ? 0 : 1; // 0 -> custom (no textures), 1 -> textured

			// Swapping actual texture?
			if (val >= 0 && val != currentTextureSet)
			{
				showLoading("Loading Material");
				currentTextureSet = val;

				// Save references to current textures
				// - Need to release AFTER loading new ones
				// - Currently a chrome warning about framebuffer feedback loop if we release first!
				let t = [
					materials[currentMaterial].GetPSTextureSRV(0),
					materials[currentMaterial].GetPSTextureSRV(1),
					materials[currentMaterial].GetPSTextureSRV(2)
				];

				// Load new textures
				materials[currentMaterial].SetPSTextureSRV(0, await TextureUtils.LoadTexture2D(d3dDevice, d3dContext, textureSets[currentTextureSet][0]));
				materials[currentMaterial].SetPSTextureSRV(1, await TextureUtils.LoadTexture2D(d3dDevice, d3dContext, textureSets[currentTextureSet][1]));
				materials[currentMaterial].SetPSTextureSRV(2, await TextureUtils.LoadTexture2D(d3dDevice, d3dContext, textureSets[currentTextureSet][2]));

				// Release old textures
				t[0].Release();
				t[1].Release();
				t[2].Release();

				hideLoading();
			}

			// Show or hide the custom controls if necessary
			let element = document.getElementById("custom-material-controls");
			if (val == -1)
				element.classList.remove("d-none");
			else
				element.classList.add("d-none");

		}

		window.setFov = function (fov)
		{
			// Convert to radians first
			camera.SetFov(fov * Math.PI / 180);
		}

		window.setColorMode = function (mode)
		{
			document.documentElement.setAttribute("data-bs-theme", mode);
		}

		window.setLutPreview = function (val)
		{
			previewLut = val;
		}

		window.setIrrPreview = function (val)
		{
			previewIrr = val;
		}

		window.setSpecPreview = function (val)
		{
			previewSpec = val;

			let el = document.getElementById("ibl-prev-mip-controls");
			if (val == true)
				el.classList.remove("d-none");
			else
				el.classList.add("d-none");
		}

		window.setIblMipPreview = function (val)
		{
			iblMipPreview = val;
		}

		window.setScene = function (val)
		{
			currentScene = val;
		}

		window.setLighting = function (val)
		{
			currentLighting = val;
		}

		window.setTonemapType = function (val)
		{
			tonemapType = val;

			let wp = document.getElementById("white-point-controls");

			// Show if tonemap is Reinhard White Point or Uncharted 2
			if (val == 2 || val == 3)
				wp.classList.remove("d-none");
			else
				wp.classList.add("d-none");
		}

		window.setTonemapExposure = function (val)
		{
			tonemapExposure = val;
		}

		window.setSkyMipPreview = function (val)
		{
			skyMipLevelPreview = val;
		}

		window.setMultiscatter = function (val)
		{
			sky.SetMultiscatterCompensation(val);
		}

		window.setIBLExposure = function (val)
		{
			sky.SetHDRExposure(val);
		}

		window.loadSixFaces = async function ()
		{
			showLoading("Loading Six Faces");

			let inputs = [
				document.getElementById("sixFacesXPos"),
				document.getElementById("sixFacesXNeg"),
				document.getElementById("sixFacesYPos"),
				document.getElementById("sixFacesYNeg"),
				document.getElementById("sixFacesZPos"),
				document.getElementById("sixFacesZNeg")
			];

			await sky.LoadSixFacesLocal(inputs);
		}

		window.loadHDR = async function ()
		{
			showLoading("Loading HDR File");
			await sky.LoadEquirectHDRLocal(document.getElementById("hdrFile"));
		}

		window.loadDDS = async function ()
		{
			showLoading("Loading DDS File");
			await sky.LoadDDSLocal(document.getElementById("ddsFile"));
		}

		window.saveSkyToFile = function ()
		{
			let [w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels] = TextureUtils.ReadPixelDataFromSRV(d3dDevice, d3dContext, sky.SkyCubeSRV);
			TextureUtils.WriteDDSFile("sky_cube.dds", w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels);
		}

		window.saveIrrToFile = function ()
		{
			let [w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels] = TextureUtils.ReadPixelDataFromSRV(d3dDevice, d3dContext, sky.IrradianceCubeSRV);
			TextureUtils.WriteDDSFile("ibl_irradiance_cube.dds", w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels);
		}

		window.saveIBLToFile = function ()
		{
			let [w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels] = TextureUtils.ReadPixelDataFromSRV(d3dDevice, d3dContext, sky.SpecularIBLCubeSRV);
			TextureUtils.WriteDDSFile("ibl_specular_cube.dds", w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels);
		}

		window.saveLUTToFile = function ()
		{
			let [w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels] = TextureUtils.ReadPixelDataFromSRV(d3dDevice, d3dContext, sky.BRDFLookUpTableSRV);
			TextureUtils.WriteDDSFile("brdf_look_up_table.dds", w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels);
		}


		// Grab canvas html element
		let viewportElement = document.getElementById("viewport");

		// Input manager setup
		let input = new Input(viewportElement);

		// Init the API
		const swapChainDesc = new DXGI_SWAP_CHAIN_DESC(
			viewportElement.clientWidth,
			viewportElement.clientHeight,
			DXGI_FORMAT_R8G8B8A8_UNORM);

		[d3dDevice, d3dContext, d3dSwapChain] =
			D3D11CreateDeviceAndSwapChain(viewportElement, 0, swapChainDesc);

		// Set up initial viewport
		let viewport = new D3D11_VIEWPORT(0, 0, viewportElement.clientWidth, viewportElement.clientHeight, 0, 1);
		d3dContext.RSSetViewports([viewport]);

		// Make an RTV of the back buffer
		let backBuffer = d3dSwapChain.GetBuffer();
		let rtv = d3dDevice.CreateRenderTargetView(backBuffer, null);
		backBuffer.Release();

		// Create a depth buffer
		let depthDesc = new D3D11_TEXTURE2D_DESC(
			viewportElement.clientWidth,
			viewportElement.clientHeight,
			1,
			1,
			DXGI_FORMAT_D24_UNORM_S8_UINT,
			new DXGI_SAMPLE_DESC(1, 0),
			D3D11_USAGE_DEFAULT,
			D3D11_BIND_DEPTH_STENCIL,
			0,
			0);
		let depthBuffer = d3dDevice.CreateTexture2D(depthDesc, null);

		// Default DSV
		let depthDSV = d3dDevice.CreateDepthStencilView(depthBuffer, null);
		depthBuffer.Release();

		// Set the default render targets
		d3dContext.OMSetRenderTargets([rtv], depthDSV);

		// Ensure we're set for triangles
		d3dContext.IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

		// Create an input layout
		let inputElements = [];
		inputElements[0] = new D3D11_INPUT_ELEMENT_DESC("POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0);
		inputElements[1] = new D3D11_INPUT_ELEMENT_DESC("TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 3 * Float32Array.BYTES_PER_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0);
		inputElements[2] = new D3D11_INPUT_ELEMENT_DESC("NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 5 * Float32Array.BYTES_PER_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0);
		inputElements[3] = new D3D11_INPUT_ELEMENT_DESC("TANGENT", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 8 * Float32Array.BYTES_PER_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0);
		let inputLayout = d3dDevice.CreateInputLayout(inputElements);
		d3dContext.IASetInputLayout(inputLayout);

		// Create an aniso sampler
		let sampDesc = new D3D11_SAMPLER_DESC(
			D3D11_FILTER_ANISOTROPIC,
			D3D11_TEXTURE_ADDRESS_WRAP,
			D3D11_TEXTURE_ADDRESS_WRAP,
			D3D11_TEXTURE_ADDRESS_WRAP,
			0,
			16,
			0,
			0,
			0,
			D3D11_FLOAT32_MAX);
		let anisoSampler = d3dDevice.CreateSamplerState(sampDesc);

		// Make a clamp anisoSampler, too
		sampDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
		sampDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
		sampDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
		let clampSampler = d3dDevice.CreateSamplerState(sampDesc);

		// And a pointer anisoSampler
		sampDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_POINT;
		let pointSampler = d3dDevice.CreateSamplerState(sampDesc);


		// Create several solid textures
		let blackSRV = TextureUtils.CreateSolidTexture2D(d3dDevice, 2, 2, 0, 0, 0, 255);
		let whiteSRV = TextureUtils.CreateSolidTexture2D(d3dDevice, 2, 2, 255, 255, 255, 255);
		let blueSRV = TextureUtils.CreateSolidTexture2D(d3dDevice, 2, 2, 0, 0, 192, 255);
		let greenSRV = TextureUtils.CreateSolidTexture2D(d3dDevice, 2, 2, 0, 128, 0, 255);
		let redSRV = TextureUtils.CreateSolidTexture2D(d3dDevice, 2, 2, 255, 0, 0, 255);
		let flatNormalsSRV = TextureUtils.CreateSolidTexture2D(d3dDevice, 2, 2, 127, 127, 255, 255);

		// Arrays of greyscale ARM textures
		let arm0SRVs = [];
		let arm1SRVs = [];
		for (let i = 0; i < 11; i++)
		{
			let r = Math.floor((i / 10.0) * 255);
			arm0SRVs.push(TextureUtils.CreateSolidTexture2D(d3dDevice, 2, 2, 255, r, 0, 255));
			arm1SRVs.push(TextureUtils.CreateSolidTexture2D(d3dDevice, 2, 2, 255, r, 255, 255));
		}

		// Camera
		camera = new OrbitCamera(15, viewportElement.clientWidth / viewportElement.clientHeight);

		// === ASSET LOADING ===

		// --- Meshes ---
		showLoading("Loading meshes");
		let sphereMesh = await Mesh.LoadFromFile(d3dDevice, "/assets/meshes/sphere_blender.obj");
		let helixMesh = await Mesh.LoadFromFile(d3dDevice, "/assets/meshes/helix.obj");
		let cubeMesh = await Mesh.LoadFromFile(d3dDevice, "/assets/meshes/cube.obj");

		// --- Shaders ---
		showLoading("Loading shaders");
		let ps = d3dDevice.CreatePixelShader(await HLSL.LoadTextFromURL("/assets/shaders/PBR_PS.hlsl"));
		let vs = d3dDevice.CreateVertexShader(await HLSL.LoadTextFromURL("/assets/shaders/PBR_VS.hlsl"));
		//let solidPS = d3dDevice.CreatePixelShader(await HLSL.LoadTextFromURL("/assets/shaders/SolidColorPS.hlsl"));
		let mipReducePS = d3dDevice.CreatePixelShader(await HLSL.LoadTextFromURL("/assets/shaders/MipReducePS.hlsl"));
		let skyVS = d3dDevice.CreateVertexShader(await HLSL.LoadTextFromURL("/assets/shaders/SkyVS.hlsl"));
		let skyPS = d3dDevice.CreatePixelShader(await HLSL.LoadTextFromURL("/assets/shaders/SkyPS.hlsl"));
		let tonemapPS = d3dDevice.CreatePixelShader(await HLSL.LoadTextFromURL("/assets/shaders/TonemapPS.hlsl"));
		//let postprocPS = d3dDevice.CreatePixelShader(await HLSL.LoadTextFromURL("/assets/shaders/BlurPS.hlsl"));
		let quadVS = d3dDevice.CreateVertexShader(await HLSL.LoadTextFromURL("/assets/shaders/QuadVS.hlsl"));
		let fullscreenVS = d3dDevice.CreateVertexShader(await HLSL.LoadTextFromURL("/assets/shaders/FullscreenVS.hlsl"));
		let simpleTexturePS = d3dDevice.CreatePixelShader(await HLSL.LoadTextFromURL("/assets/shaders/SimpleTexturePS.hlsl"));
		let cubePreviewPS = d3dDevice.CreatePixelShader(await HLSL.LoadTextFromURL("/assets/shaders/CubePreviewPS.hlsl"));
		let cubePreviewVS = d3dDevice.CreateVertexShader(await HLSL.LoadTextFromURL("/assets/shaders/CubePreviewVS.hlsl"));
		let cubeFacePreviewPS = d3dDevice.CreatePixelShader(await HLSL.LoadTextFromURL("/assets/shaders/CubeFacePreviewPS.hlsl"));
		let equirectToCubePS = d3dDevice.CreatePixelShader(await HLSL.LoadTextFromURL("/assets/shaders/EquirectToCubePS.hlsl"));
		let brdfLutPS = d3dDevice.CreatePixelShader(await HLSL.LoadTextFromURL("/assets/shaders/IBLBrdfLookUpTablePS.hlsl"));
		let iblIrradiancePS = d3dDevice.CreatePixelShader(await HLSL.LoadTextFromURL("/assets/shaders/IBLIrradianceMapPS.hlsl"));
		let iblSpecularPS = d3dDevice.CreatePixelShader(await HLSL.LoadTextFromURL("/assets/shaders/IBLSpecularConvolutionPS.hlsl"));

		
		// --- Materials ---
		showLoading("Loading Materials");

		// Set up texture sets
		let matCustom = new Material(vs, ps, new Vector3(1, 1, 1));
		matCustom.SetPSTextureSRV(0, whiteSRV);
		matCustom.SetPSTextureSRV(1, flatNormalsSRV);
		matCustom.SetPSTextureSRV(2, whiteSRV);
		matCustom.SetPSSamplerState(0, anisoSampler);
		matCustom.SetPSSamplerState(1, clampSampler);

		let matTextured = new Material(vs, ps, new Vector3(1, 1, 1));
		matTextured.SetPSTextureSRV(0, await TextureUtils.LoadTexture2D(d3dDevice, d3dContext, textureSets[currentTextureSet][0]));
		matTextured.SetPSTextureSRV(1, await TextureUtils.LoadTexture2D(d3dDevice, d3dContext, textureSets[currentTextureSet][1]));
		matTextured.SetPSTextureSRV(2, await TextureUtils.LoadTexture2D(d3dDevice, d3dContext, textureSets[currentTextureSet][2]));
		matTextured.SetPSSamplerState(0, anisoSampler);
		matTextured.SetPSSamplerState(1, clampSampler);

		// Save the two materials
		materials.push(matCustom);
		materials.push(matTextured);

		// -------------- Entity setup -------------------
		// --- SPHERE SCENE ---
		let sphereEntity = new Entity(
			sphereMesh,
			matCustom);
		sphereEntity.Transform.ScaleUniform(7);

		scenes.push([sphereEntity]);

		// --- HELIX SCENE ---
		let helixEntity = new Entity(
			helixMesh,
			matCustom);
		helixEntity.Transform.ScaleUniform(3);

		scenes.push([helixEntity]);

		// --- CUBE SCENE ---
		let cubeEntity = new Entity(
			cubeMesh,
			matCustom);
		cubeEntity.Transform.ScaleUniform(4);

		scenes.push([cubeEntity]);

		// --- ROUGHNESS SPHERES ---
		let roughRowTextures = [
			// Albedo,	normals,        ARM array
			[whiteSRV, flatNormalsSRV, arm1SRVs], // Metal
			[whiteSRV, flatNormalsSRV, arm0SRVs], // White plastic
			[blackSRV, flatNormalsSRV, arm0SRVs]  // Black plastic
		];

		let spacing = 1.1;
		let startY = roughRowTextures.length / 2;
		let roughScene = [];
		for (let row = 0; row < roughRowTextures.length; row++)
		{
			for (let col = 0; col < 11; col++)
			{
				let m = new Material(vs, ps, new Vector3(1, 1, 1));
				m.SetPSTextureSRV(0, roughRowTextures[row][0]); // Albedo
				m.SetPSTextureSRV(1, roughRowTextures[row][1]); // Normals
				m.SetPSTextureSRV(2, roughRowTextures[row][2][col]); // ARM array
				m.SetPSSamplerState(0, anisoSampler);
				m.SetPSSamplerState(1, clampSampler);

				let e = new Entity(sphereMesh, m);
				e.Transform.SetPosition((col - 5) * spacing, startY - row * spacing, 0);
				e.Transform.SetScaleUniform(1);

				roughScene.push(e);
			}
		}
		scenes.push(roughScene);


		// --- RGB SPHERES ---
		let rgbRowTextures = [
			// Albedo,	normals,       ARM array
			[whiteSRV, flatNormalsSRV, arm0SRVs],  // White plastic
			[redSRV,   flatNormalsSRV, arm0SRVs],  // Red plastic
			[greenSRV, flatNormalsSRV, arm0SRVs],  // Green plastic
			[blueSRV,  flatNormalsSRV, arm0SRVs],  // Blue plastic
			[blackSRV, flatNormalsSRV, arm0SRVs]   // Black plastic
		];

		startY = rgbRowTextures.length / 2;
		let rgbScene = [];
		for (let row = 0; row < rgbRowTextures.length; row++)
		{
			for (let col = 0; col < 11; col++)
			{
				let m = new Material(vs, ps, new Vector3(1, 1, 1));
				m.SetPSTextureSRV(0, rgbRowTextures[row][0]); // Albedo
				m.SetPSTextureSRV(1, rgbRowTextures[row][1]); // Normals
				m.SetPSTextureSRV(2, rgbRowTextures[row][2][col]); // ARM
				m.SetPSSamplerState(0, anisoSampler);
				m.SetPSSamplerState(1, clampSampler);

				let e = new Entity(sphereMesh, m);
				e.Transform.SetPosition((col - 5) * spacing, startY - row * spacing, 0);
				e.Transform.SetScaleUniform(1);

				rgbScene.push(e);
			}
		}
		scenes.push(rgbScene);


		// ----------- Lighting setups ---------------

		// --- No lights ---
		lightingSetups.push([]); // Empty array

		// --- One Dir Light ---
		lightingSetups.push([
			new Light(Light.TypeDirectional, Vector3.One, 1.0, Vector3.Normalize(new Vector3(1, -1, 1)))
		]);

		// --- Three Dir Lights ---
		lightingSetups.push([
			new Light(Light.TypeDirectional, Vector3.One, 1.0, Vector3.Normalize(new Vector3(1, -1, 1))),
			new Light(Light.TypeDirectional, Vector3.One, 1.0, Vector3.Normalize(new Vector3(-1, -0.1, -0.1))),
			new Light(Light.TypeDirectional, Vector3.One, 0.3, Vector3.Normalize(new Vector3(0, 1, -0.5)))
		]);

		// --------------- Sky ------------------

		showLoading("Loading Initial Environment Map");

		sky = new Sky(d3dDevice, d3dContext,
			skyVS, skyPS, cubeMesh,
			DXGI_FORMAT_R16G16_FLOAT, 1024, brdfLutPS,
			DXGI_FORMAT_R32G32B32A32_FLOAT, 256, iblIrradiancePS,
			DXGI_FORMAT_R32G32B32A32_FLOAT, 512, 3, iblSpecularPS,
			equirectToCubePS, mipReducePS, fullscreenVS,
			true, 128);

		sky.addEventListener("skydirty", (e) => { document.getElementById("buttonSaveSky").disabled = true; });
		sky.addEventListener("lutdirty", (e) => { document.getElementById("buttonSaveLUT").disabled = true; });
		sky.addEventListener("irrdirty", (e) => { document.getElementById("buttonSaveIrr").disabled = true; });
		sky.addEventListener("specdirty", (e) => { document.getElementById("buttonSaveIBL").disabled = true; });

		sky.addEventListener("lutclean", (e) => { document.getElementById("buttonSaveLUT").disabled = false; });
		sky.addEventListener("irrclean", (e) => { document.getElementById("buttonSaveIrr").disabled = false; });
		sky.addEventListener("specclean", (e) => { document.getElementById("buttonSaveIBL").disabled = false; });
		sky.addEventListener("skyclean", (e) =>
		{
			document.getElementById("buttonSaveSky").disabled = false;

			let hdrStatus = document.getElementById("hdr-status");
			let iblExp = document.getElementById("ibl-exposure-container");
			let tonemap = document.getElementById("tonemapping-contanier");
			let nonHDR = document.getElementById("non-hdr-reminder");
			if (sky.IsHDR)
			{
				hdrStatus.innerHTML = "Yes";
				iblExp.classList.remove("d-none");
				tonemap.classList.remove("d-none");
				nonHDR.classList.add("d-none");
			}
			else
			{
				hdrStatus.innerHTML = "No";
				iblExp.classList.add("d-none");
				tonemap.classList.add("d-none");
				nonHDR.classList.remove("d-none");
			}
		});

		await sky.LoadEquirectHDRFromUrl(defaultSkyPaths[0]);

		// --- General D3D Resources ---
		showLoading("Creating Other GPU Resources");

		// Create constant buffers
		let cbDesc = new D3D11_BUFFER_DESC(
			0, // Will be filled in below
			D3D11_USAGE_DYNAMIC,
			D3D11_BIND_CONSTANT_BUFFER,
			D3D11_CPU_ACCESS_WRITE,
			0, 0);

		// VS Per Frame = 2 matrices (view & proj)
		cbDesc.ByteWidth = 16 * 2 * Float32Array.BYTES_PER_ELEMENT;
		let vsPerFrameCB = d3dDevice.CreateBuffer(cbDesc, null);
		let vsPerFrameData = new MappedArray(16 * 2);
		vsPerFrameData.PushMapping("view", 16);
		vsPerFrameData.PushMapping("proj", 16);

		// VS Per Object = 1 matrix (world)
		cbDesc.ByteWidth = 16 * Float32Array.BYTES_PER_ELEMENT;
		let vsPerObjectCB = d3dDevice.CreateBuffer(cbDesc, null);
		let vsPerObjectData = new MappedArray(16);
		vsPerObjectData.PushMapping("world", 16);

		// PS Per Frame = 8 floats + MAX lights
		cbDesc.ByteWidth =
			8 * Float32Array.BYTES_PER_ELEMENT +
			MaxLights * Light.SizeInBytes;
		let psPerFrameCB = d3dDevice.CreateBuffer(cbDesc, null);
		let psPerFrameData = new MappedArray(cbDesc.ByteWidth / Float32Array.BYTES_PER_ELEMENT);
		psPerFrameData.PushMapping("cameraPos", 3);
		psPerFrameData.PushMapping("pad", 1);
		psPerFrameData.PushMapping("iblSpecMips", 1);
		psPerFrameData.PushMapping("lightCount", 1);
		psPerFrameData.PushMapping("envIsHDR", 1);
		psPerFrameData.PushMapping("multiscatter", 1);
		psPerFrameData.PushMapping("lights", MaxLights * Light.SizeInFloats);

		// PS Per Object = 8 floats (RGB color tint + roughness + metalness + float3 padding)
		cbDesc.ByteWidth = 8 * Float32Array.BYTES_PER_ELEMENT;
		let psPerObjectCB = d3dDevice.CreateBuffer(cbDesc, null);
		let psPerObjectData = new MappedArray(8);
		psPerObjectData.PushMapping("tint", 3);
		psPerObjectData.PushMapping("pad", 1);
		psPerObjectData.PushMapping("roughness", 1);
		psPerObjectData.PushMapping("metalness", 1);

		// Set initial values
		psPerObjectData.SetData("roughness", 1);
		psPerObjectData.SetData("metalness", 1);

		// PS IBL prev data - for both cube preview and cube face preview
		cbDesc.ByteWidth = 4 * Float32Array.BYTES_PER_ELEMENT;
		let psIBLPrevCB = d3dDevice.CreateBuffer(cbDesc, null);
		let psIBLPrevData = new MappedArray(4);
		psIBLPrevData.PushMapping("mipLevel", 1);
		psIBLPrevData.PushMapping("faceIndex", 1);

		// Cbuffer for solid color
		let solidCBDesc = new D3D11_BUFFER_DESC(
			4 * Float32Array.BYTES_PER_ELEMENT,
			D3D11_USAGE_DYNAMIC,
			D3D11_BIND_CONSTANT_BUFFER,
			D3D11_CPU_ACCESS_WRITE,
			0, 0);
		let solidCB = d3dDevice.CreateBuffer(solidCBDesc, null);
		let solidData = new Float32Array(4);
		solidData.set([1, 1, 1], 0);
		d3dContext.UpdateSubresource(solidCB, 0, null, solidData, 0, 0);

		// Cbuffer for quad UI
		let quadCBDesc = new D3D11_BUFFER_DESC(
			8 * Float32Array.BYTES_PER_ELEMENT,
			D3D11_USAGE_DYNAMIC,
			D3D11_BIND_CONSTANT_BUFFER,
			D3D11_CPU_ACCESS_WRITE,
			0, 0);
		let quadCB = d3dDevice.CreateBuffer(quadCBDesc, null);
		let quadData = new Float32Array(8);

		// Post process resources
		let floatFiltering = d3dDevice.CheckFeatureSupport(D3D11_JS_FEATURE_FLOAT_TEXTURE_FILTER_SUPPORT);
		let ppFormat = floatFiltering == null ? DXGI_FORMAT_R16G16B16A16_FLOAT : DXGI_FORMAT_R32G32B32A32_FLOAT;
		let ppTexDesc = new D3D11_TEXTURE2D_DESC(
			viewportElement.width,
			viewportElement.height,
			1,
			1,
			ppFormat,
			new DXGI_SAMPLE_DESC(1, 0),
			D3D11_USAGE_DEFAULT,
			D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE,
			0,
			0);
		let ppTexture = d3dDevice.CreateTexture2D(ppTexDesc, [null]);
		let ppSRV = d3dDevice.CreateShaderResourceView(ppTexture, null);
		let ppRTV = d3dDevice.CreateRenderTargetView(ppTexture, null);
		ppTexture.Release();

		// Post process constant buffer
		let ppCBDesc = new D3D11_BUFFER_DESC(
			Float32Array.BYTES_PER_ELEMENT * 4,
			D3D11_USAGE_DYNAMIC,
			D3D11_BIND_CONSTANT_BUFFER,
			D3D11_CPU_ACCESS_WRITE,
			0, 0);
		let ppCB = d3dDevice.CreateBuffer(ppCBDesc, null);
		let ppData = new Float32Array(4);

		// Done loading
		hideLoading();
		
		function update(deltaTime, totalTime)
		{
			if (input.GetDoubleClick())
				camera.ResetFocusPosition();

			camera.Update(input, deltaTime);

			// Handle cursor for canvas (None = grab; Left = grabbing; Right = move)
			if (input.IsMouseDown(MouseButtons.Left))
				viewportElement.style.cursor = "grabbing";
			else if (input.IsMouseDown(MouseButtons.Middle))
				viewportElement.style.cursor = "move";
			else if (input.IsMouseDown(MouseButtons.Right))
				viewportElement.style.cursor = "url('/assets/cursors/wasd.png') 16 16, move";
			else
				viewportElement.style.cursor = "grab";

			// Check for any progressive IBL updates
			sky.Update();

			// Set up loading messages based on order of IBL map creation
			if (!sky.BRDFLookUpTableReady)
				showLoading("Generating environment BRDF look up table");
			else if (!sky.IrradianceReady)
				showLoading("Generating environment irradiance map");
			else if (!sky.SpecularIBLReady)
				showLoading("Generating environment specular convolution map");
			else
				hideLoading();
		}

		function checkForResize()
		{
			// Has the window changed size?
			if (viewportElement.width != viewportElement.clientWidth ||
				viewportElement.height != viewportElement.clientHeight)
			{
				// Need to resize, so first release all references
				rtv.Release(); // Back buffer
				depthDSV.Release(); // Depth buffer

				// Ask the swap chain to resize and update the canvas
				viewportElement.width = viewportElement.clientWidth;
				viewportElement.height = viewportElement.clientHeight;
				d3dSwapChain.ResizeBuffers(viewportElement.clientWidth, viewportElement.clientHeight);

				// Make new RTV
				let bb = d3dSwapChain.GetBuffer();
				rtv = d3dDevice.CreateRenderTargetView(bb, null);
				bb.Release();

				// Make new depth buffer
				let depthDesc = new D3D11_TEXTURE2D_DESC(
					viewportElement.clientWidth,
					viewportElement.clientHeight,
					1,
					1,
					DXGI_FORMAT_D24_UNORM_S8_UINT,
					new DXGI_SAMPLE_DESC(1, 0),
					D3D11_USAGE_DEFAULT,
					D3D11_BIND_DEPTH_STENCIL,
					0,
					0);
				let depthBuffer = d3dDevice.CreateTexture2D(depthDesc, null);

				// Default DSV
				depthDSV = d3dDevice.CreateDepthStencilView(depthBuffer, null);
				depthBuffer.Release();

				// Set the new views
				d3dContext.OMSetRenderTargets([rtv], depthDSV);

				// Update aspect ratio and camera
				camera.AspectRatio = viewportElement.clientWidth / viewportElement.clientHeight;

				// Update rendering viewport, too
				viewport.Width = viewportElement.clientWidth;
				viewport.Height = viewportElement.clientHeight;
				d3dContext.RSSetViewports([viewport]);

				// Create new post processing resource, too
				ppSRV.Release();
				ppRTV.Release();
				let ppTexDesc = new D3D11_TEXTURE2D_DESC(
					viewportElement.width,
					viewportElement.height,
					1,
					1,
					DXGI_FORMAT_R32G32B32A32_FLOAT,
					new DXGI_SAMPLE_DESC(1, 0),
					D3D11_USAGE_DEFAULT,
					D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE,
					0,
					0);
				let ppTexture = d3dDevice.CreateTexture2D(ppTexDesc, [null]);
				ppSRV = d3dDevice.CreateShaderResourceView(ppTexture, null);
				ppRTV = d3dDevice.CreateRenderTargetView(ppTexture, null);
				ppTexture.Release();
			}
		}

		function drawPreviewCube(x, y, size, srv, mip = 0, clearDepth = true)
		{
			if (clearDepth)
			{
				d3dContext.ClearDepthStencilView(depthDSV, D3D11_CLEAR_DEPTH, 1, 0);
			}

			// Viewport
			let offset = 10;
			let [oldVP] = d3dContext.RSGetViewports();
			let vpCorner = new D3D11_VIEWPORT(
				x, y,
				size, size,
				0, 1);
			d3dContext.RSSetViewports([vpCorner]);

			// Set up shaders
			d3dContext.VSSetShader(cubePreviewVS);
			d3dContext.PSSetShader(cubePreviewPS);

			// Set VS constant buffers for main draw
			d3dContext.VSSetConstantBuffers(0, [vsPerFrameCB]);

			// Set per-frame data and update CB
			vsPerFrameData.SetData("view", Matrix4x4.ViewPositionLH(
				Vector3.Multiply(camera.Forward, -iblPreviewCubeCamDist),
				Vector3.Zero,
				Vector3.UnitY
			));
			vsPerFrameData.SetData("proj", Matrix4x4.PerspectiveFovLH(Math.PI / 4, 1, 0.1, 100));
			d3dContext.UpdateSubresource(vsPerFrameCB, 0, null, vsPerFrameData, 0, 0);

			// Pixel data
			psIBLPrevData.SetData("mipLevel", [mip]);
			d3dContext.UpdateSubresource(psIBLPrevCB, 0, null, psIBLPrevData, 0, 0);
			d3dContext.PSSetConstantBuffers(0, [psIBLPrevCB]);

			// Texture
			d3dContext.PSSetShaderResources(0, [srv]);
			d3dContext.PSSetSamplers(0, [pointSampler]);

			// Draw
			d3dContext.IASetVertexBuffers(0, [cubeMesh.VertexBuffer], [Vertex.GetStrideInBytes()], [0]);
			d3dContext.IASetIndexBuffer(cubeMesh.IndexBuffer, DXGI_FORMAT_R16_UINT);
			d3dContext.DrawIndexed(cubeMesh.IndexCount, 0);

			// Reset state
			d3dContext.RSSetViewports([oldVP]);
		}

		function drawTextureQuad(x, y, width, height, srv)
		{
			quadData.set([
				x, y, // Position in pixels
				width, height, // Size in pixels
				viewportElement.clientWidth, viewportElement.clientHeight // Window size
			]);
			d3dContext.UpdateSubresource(quadCB, 0, null, quadData, 0, 0);

			d3dContext.VSSetShader(quadVS);
			d3dContext.VSSetConstantBuffers(0, [quadCB]);

			d3dContext.PSSetShader(simpleTexturePS);
			d3dContext.PSSetShaderResources(0, [srv]);
			d3dContext.PSSetSamplers(0, [clampSampler]);

			d3dContext.Draw(6, 0);
		}

		function drawCubeFaceQuad(x, y, width, height, srv, face, mip)
		{
			quadData.set([
				x, y, // Position in pixels
				width, height, // Size in pixels
				viewportElement.clientWidth, viewportElement.clientHeight // Window size
			]);
			d3dContext.UpdateSubresource(quadCB, 0, null, quadData, 0, 0);

			d3dContext.VSSetShader(quadVS);
			d3dContext.VSSetConstantBuffers(0, [quadCB]);

			d3dContext.PSSetShader(cubeFacePreviewPS);
			d3dContext.PSSetShaderResources(0, [srv]);
			d3dContext.PSSetSamplers(0, [pointSampler]);

			// Set up PS cbuffer
			psIBLPrevData.SetData("mipLevel", [mip]);
			psIBLPrevData.SetData("faceIndex", [face]);
			d3dContext.UpdateSubresource(psIBLPrevCB, 0, null, psIBLPrevData, 0, 0);
			d3dContext.PSSetConstantBuffers(0, [psIBLPrevCB]);

			d3dContext.Draw(6, 0);
		}

		function drawEntity(e)
		{
			// Set shaders
			d3dContext.VSSetShader(e.Material.VertexShader);
			d3dContext.PSSetShader(e.Material.PixelShader);

			// Update vertex data
			vsPerObjectData.SetData("world", e.Transform.WorldMatrix);
			d3dContext.UpdateSubresource(vsPerObjectCB, 0, null, vsPerObjectData, 0, 0);

			// Which material?
			let mat = e.Material;
			let customMat = false;
			if (currentScene == 0 || currentScene == 1 || currentScene == 2)
			{
				// Use proper material
				mat = materials[currentMaterial];
				customMat = true;
			}

			// Set up material
			mat.PrepareMaterial(d3dContext);
			psPerObjectData.SetData("tint", customMat && currentMaterial == 0 ? customMatColor : mat.Color);
			psPerObjectData.SetData("roughness", customMat && currentMaterial == 0 ? [customMatRoughness] : [1]);
			psPerObjectData.SetData("metalness", customMat && currentMaterial == 0 ? [customMatMetalness] : [1]);
			d3dContext.UpdateSubresource(psPerObjectCB, 0, null, psPerObjectData, 0, 0);

			// Set up IBL
			d3dContext.PSSetShaderResources(4, [
				sky.BRDFLookUpTableSRV, sky.IrradianceCubeSRV, sky.SpecularIBLCubeSRV
			]);
			d3dContext.PSSetSamplers(0, [anisoSampler, clampSampler]);

			// Draw
			d3dContext.IASetVertexBuffers(0, [e.Mesh.VertexBuffer], [Vertex.GetStrideInBytes()], [0]);
			d3dContext.IASetIndexBuffer(e.Mesh.IndexBuffer, DXGI_FORMAT_R16_UINT);
			d3dContext.DrawIndexed(e.Mesh.IndexCount, 0);
		}


		function draw(deltaTime, totalTime)
		{
			checkForResize();

			// Set up tone mapping if necessary
			if (sky.IsHDR)
			{
				d3dContext.OMSetRenderTargets([ppRTV], depthDSV);
			}

			// Set VS constant buffers for main draw
			d3dContext.VSSetConstantBuffers(0, [vsPerFrameCB, vsPerObjectCB]);

			// Set per-frame data and update CB
			vsPerFrameData.SetData("view", camera.ViewMatrix);
			vsPerFrameData.SetData("proj", camera.ProjectionMatrix);
			d3dContext.UpdateSubresource(vsPerFrameCB, 0, null, vsPerFrameData, 0, 0);

			// Clear the frame
			let black = [0, 0, 0, 1];
			let cornflowerBlue = [0.39, 0.58, 0.93, 1];
			d3dContext.ClearRenderTargetView(rtv, black);
			d3dContext.ClearDepthStencilView(depthDSV, D3D11_CLEAR_DEPTH, 1.0, 0);

			// Pipeline for next several draws
			d3dContext.VSSetShader(vs);
			d3dContext.PSSetShader(ps);
			d3dContext.PSSetConstantBuffers(0, [psPerFrameCB, psPerObjectCB]);

			// Set per-frame PS data and update CB
			psPerFrameData.SetData("cameraPos", camera.Position);
			psPerFrameData.SetData("iblSpecMips", [sky.SpecularIBLMipsTotal]);
			psPerFrameData.SetData("lightCount", [lightingSetups[currentLighting].length]);
			psPerFrameData.SetData("envIsHDR", [sky.IsHDR ? 1 : 0]);
			psPerFrameData.SetData("multiscatter", [sky.MultiscatterCompensation ? 1 : 0]);
			for (let i = 0; i < lightingSetups[currentLighting].length; i++)
				psPerFrameData.SetData("lights", lightingSetups[currentLighting][i], i * Light.SizeInFloats);
			d3dContext.UpdateSubresource(psPerFrameCB, 0, null, psPerFrameData, 0, 0);

			// Main scene draw
			{
				for (let i = 0; i < scenes[currentScene].length; i++)
				{
					drawEntity(scenes[currentScene][i]);
				}
			}

			// Skybox
			{
				sky.Draw(camera.ViewMatrix, camera.ProjectionMatrix, skyMipLevelPreview);
			}

			// Preview cubes for irradiance and/or specular
			let irrOffset = previewLut == true ? iblPreviewSize + iblPreviewBorder * 2 : iblPreviewBorder;
			let specOffset = irrOffset + (previewIrr == true ? iblPreviewSize : 0);
			if (previewIrr)
			{
				drawPreviewCube(
					viewportElement.clientWidth - iblPreviewSize - iblPreviewBorder,
					irrOffset,
					iblPreviewSize,
					sky.IrradianceCubeSRV,
					iblMipPreview);
			}

			if (previewSpec)
			{
				drawPreviewCube(
					viewportElement.clientWidth - iblPreviewSize - iblPreviewBorder,
					specOffset,
					iblPreviewSize,
					sky.SpecularIBLCubeSRV,
					iblMipPreview);
			}


			// Finalize post processing if necessary
			if (sky.IsHDR)
			{
				d3dContext.OMSetRenderTargets([rtv], null);
				d3dContext.VSSetShader(fullscreenVS);
				d3dContext.PSSetShader(tonemapPS);
				d3dContext.PSSetShaderResources(0, [ppSRV]);
				d3dContext.PSSetSamplers(0, [pointSampler]);
				d3dContext.PSSetConstantBuffers(0, [ppCB]);
				ppData.set([
					tonemapType,
					tonemapExposure,
					tonemapWhitePoint
				], 0);
				d3dContext.UpdateSubresource(ppCB, 0, null, ppData, 0, 0);
				d3dContext.Draw(3, 0);
			}

			// Env BRDF Lookup Table preview - Always on top
			if (previewLut)
			{
				drawTextureQuad(
					viewportElement.clientWidth - iblPreviewSize - iblPreviewBorder,
					iblPreviewBorder,
					iblPreviewSize,
					iblPreviewSize, 
					sky.BRDFLookUpTableSRV);
			}

			// === IBL Loading Previews ===
			let loadingPreviewY = document.getElementById("loading-container").getBoundingClientRect().bottom + iblPreviewBorder;
			if (!sky.BRDFLookUpTableReady == 1)
			{
				drawTextureQuad(
					iblPreviewBorder,
					loadingPreviewY,
					iblPreviewSize,
					iblPreviewSize,
					sky.BRDFLookUpTableSRV);
			}
			else if (!sky.IrradianceReady)
			{
				drawCubeFaceQuad(
					iblPreviewBorder,
					loadingPreviewY,
					iblPreviewSize,
					iblPreviewSize,
					sky.IrradianceCubeSRV,
					sky.IrradianceFaceUpdate,
					0);
			}
			else if (!sky.SpecularIBLReady)
			{
				drawCubeFaceQuad(
					iblPreviewBorder,
					loadingPreviewY,
					iblPreviewSize,
					iblPreviewSize,
					sky.SpecularIBLCubeSRV,
					sky.SpecularFaceUpdate,
					sky.SpecularMipUpdate);
			}

			// Flush the frame
			d3dSwapChain.Present();

			d3dContext.OMSetRenderTargets([rtv], depthDSV);
		}

		let startTime = -1;
		let prevTime = 0;
		function frameloop(time)
		{
			// First frame check
			if (startTime == -1)
			{
				startTime = time;
				prevTime = time;
			}

			let totalTime = (time - startTime) / 1000;
			let deltaTime = (time - prevTime) / 1000;

			update(deltaTime, totalTime);
			draw(deltaTime, totalTime);

			// End of frame work
			window.requestAnimationFrame(frameloop);
			input.EndOfFrame();

			prevTime = time;
		}

		window.requestAnimationFrame(frameloop);

	</script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
</body>
</html>

