<!DOCTYPE html>
<html>
<head>
	<script src="../src/d3d11.js"></script>

</head>
<body style="background-color:#000;">
	<h1 style="color:#fff;">D3D11.js Test</h1>

	<canvas id="viewport" width="800" height="600"></canvas>

	<script>
		class Vector2 extends Float32Array
		{
			get X() { return this[0]; }
			get Y() { return this[1]; }

			set X(x) { this[0] = x; }
			set Y(y) { this[1] = y; }

			constructor(x = 0, y = 0)
			{
				super(2);
				this[0] = x;
				this[1] = y;
			}
		}

		class Vector3 extends Float32Array
		{
			get X() { return this[0]; }
			get Y() { return this[1]; }
			get Z() { return this[2]; }

			set X(x) { this[0] = x; }
			set Y(y) { this[1] = y; }
			set Z(z) { this[2] = z; }

			constructor(x = 0, y = 0, z = 0)
			{
				super(3);
				this[0] = x;
				this[1] = y;
				this[2] = z;
			}
		}

		class Vertex
		{
			Position;
			UV;
			Normal;

			constructor(pos, uv, norm)
			{
				this.Position = pos;
				this.UV = uv;
				this.Normal = norm;
			}
		}

		async function loadOBJFile(device, url)
		{
			const resp = await fetch(url);
			const fileText = await resp.text();

			var positions = [];
			var normals = [];
			var uvs = [];
			var vertices = [];
			var indices = [];
			
			var lines = fileText.split("\n");
			for (var i = 0; i < lines.length; i++)
			{
				// Trim and verify
				lines[i] = lines[i].trim();
				if (lines[i].length == 0)
					continue;
				
				// Check the type of line
				if (lines[i].charAt(0) == 'v' && lines[i].charAt(1) == 'n')
				{
					// vn x y z
					var normLine = lines[i].split(' ');
					normals.push(new Vector3(
						parseFloat(normLine[1]),
						parseFloat(normLine[2]),
						parseFloat(normLine[3])));
				}
				else if (lines[i].charAt(0) == 'v' && lines[i].charAt(1) == 't')
				{
					// vt u v
					var uvLine = lines[i].split(' ');
					uvs.push(new Vector2(
						parseFloat(uvLine[1]),
						parseFloat(uvLine[2])));
				}
				else if (lines[i].charAt(0) == 'v')
				{
					// v x y z
					var posLine = lines[i].split(' ');
					positions.push(new Vector3(
						parseFloat(posLine[1]),
						parseFloat(posLine[2]),
						parseFloat(posLine[3])));
				}
				else if (lines[i].charAt(0) == 'f')
				{
					// f 1/2/3 1/2/3 1/2/3
					//  - or -
					// f 1/2/3 1/2/3 1/2/3 1/2/3
					var faceLine = lines[i].split(' ');
					
					// Assume at least 3 verts per face
					for (var f = 1; f <= 3; f++)
					{
						var data = faceLine[f].split('/');
						var p = parseInt(data[0]);
						var u = parseInt(data[1]);
						var n = parseInt(data[2]);

						var vert = new Vertex(
							positions[p - 1],
							uvs[u - 1],
							normals[n - 1]);

						// Convert to left handed
						vert.Position.Z *= -1.0; // Invert Z pos
						vert.Normal.Z *= -1.0; // Invert Z normal
						vert.UV.Y = 1.0 - vert.UV.Y; // Flip UV

						// Add to array
						vertices.push(vert);
					}

					// Add indices (0, 2, 1)
					var ind = indices.length;
					indices.push(ind + 0);
					indices.push(ind + 2);
					indices.push(ind + 1);

					// A fourth face? (So 5 total elements after split)
					if (faceLine.length == 5)
					{
						var data = faceLine[f].split('/');
						var p = parseInt(data[0]);
						var u = parseInt(data[1]);
						var n = parseInt(data[2]);

						var vert = new Vertex(
							positions[p - 1],
							uvs[u - 1],
							normals[n - 1]);

						// Convert to left handed
						vert.Position.Z *= -1.0; // Invert Z pos
						vert.Normal.Z *= -1.0; // Invert Z normal
						vert.UV.Y = 1.0 - vert.UV.Y; // Flip UV

						// Add to array
						vertices.push(vert);

						// Add another whole face (0, 3, 2)
						indices.push(ind + 0);
						indices.push(ind + 3);
						indices.push(ind + 2);
					}
				}
			}

			// Copy data to float array
			var floatsPerVert = 3 + 2 + 3;
			var vbData = new Float32Array(vertices.length * floatsPerVert);
			for (var v = 0; v < vertices.length; v++)
			{
				vbData.set(vertices[v].Position, v * floatsPerVert + 0);
				vbData.set(vertices[v].UV, v * floatsPerVert + 3);
				vbData.set(vertices[v].Normal, v * floatsPerVert + 5);
			}

			// Create buffer
			var vbDesc = new D3D11_BUFFER_DESC(
				Float32Array.BYTES_PER_ELEMENT * 7 * vertices.length,
				D3D11_USAGE_IMMUTABLE,
				D3D11_BIND_VERTEX_BUFFER,
				0, 0, 0);
			var vb = device.CreateBuffer(vbDesc, vbData);


			var ibData = new Int16Array(indices);
			var ibDesc = new D3D11_BUFFER_DESC(
				Int16Array.BYTES_PER_ELEMENT * indices.length,
				D3D11_USAGE_IMMUTABLE,
				D3D11_BIND_VERTEX_BUFFER,
				0, 0, 0);
			var ib = device.CreateBuffer(ibDesc, ibData);

			return [vb, ib];
		}


		var cubeOBJ = `
			v -0.500000 -0.500000 0.500000
			v 0.500000 -0.500000 0.500000
			v -0.500000 0.500000 0.500000
			v 0.500000 0.500000 0.500000
			v -0.500000 0.500000 -0.500000
			v 0.500000 0.500000 -0.500000
			v -0.500000 -0.500000 -0.500000
			v 0.500000 -0.500000 -0.500000
			vt 1.000000 0.000000
			vt 1.000000 1.000000
			vt 0.000000 1.000000
			vt 0.000000 0.000000
			vt 1.000000 0.000000
			vt 1.000000 1.000000
			vt 0.000000 1.000000
			vt 0.000000 0.000000
			vt 1.000000 0.000000
			vt 1.000000 1.000000
			vt 0.000000 1.000000
			vt 0.000000 0.000000
			vt 1.000000 0.000000
			vt 1.000000 1.000000
			vt 0.000000 1.000000
			vt 0.000000 0.000000
			vt 0.000000 0.000000
			vt 1.000000 0.000000
			vt 1.000000 1.000000
			vt 0.000000 1.000000
			vt 0.000000 0.000000
			vt 1.000000 0.000000
			vt 1.000000 1.000000
			vt 0.000000 1.000000
			vn 0.000000 0.000000 1.000000
			vn 0.000000 0.000000 1.000000
			vn 0.000000 0.000000 1.000000
			vn 0.000000 0.000000 1.000000
			vn 0.000000 1.000000 0.000000
			vn 0.000000 1.000000 0.000000
			vn 0.000000 1.000000 0.000000
			vn 0.000000 1.000000 0.000000
			vn 0.000000 0.000000 -1.000000
			vn 0.000000 0.000000 -1.000000
			vn 0.000000 0.000000 -1.000000
			vn 0.000000 0.000000 -1.000000
			vn 0.000000 -1.000000 0.000000
			vn 0.000000 -1.000000 0.000000
			vn 0.000000 -1.000000 0.000000
			vn 0.000000 -1.000000 0.000000
			vn 1.000000 0.000000 0.000000
			vn 1.000000 0.000000 0.000000
			vn 1.000000 0.000000 0.000000
			vn 1.000000 0.000000 0.000000
			vn -1.000000 0.000000 0.000000
			vn -1.000000 0.000000 0.000000
			vn -1.000000 0.000000 0.000000
			vn -1.000000 0.000000 0.000000
			f 1/1/1 2/2/2 3/4/3
			f 3/4/3 2/2/2 4/3/4
			f 3/5/5 4/6/6 5/8/7
			f 5/8/7 4/6/6 6/7/8
			f 5/9/9 6/10/10 7/12/11
			f 7/12/11 6/10/10 8/11/12
			f 7/13/13 8/14/14 1/16/15
			f 1/16/15 8/14/14 2/15/16
			f 2/17/17 8/18/18 4/20/19
			f 4/20/19 8/18/18 6/19/20
			f 7/21/21 1/22/22 5/24/23
			f 5/24/23 1/22/22 3/23/24`;

		// Shaders
		var hlslVS = `
			struct VSInput
			{
				float3 position;
				float4 color;
			};

			struct VertexToPixel
			{
				float4 position : SV_POSITION;
				float4 color	: COLOR;
			};

			cbuffer vsData : register(b0)
			{
				float offset;
			}

			VertexToPixel main(VSInput input)
			{
				VertexToPixel output;
				input.position.x += offset;
				output.position = float4(input.position, 1);
				output.color = input.color;
				return output;
			}
		`;

		var hlslPS = `
			struct VertexToPixel
			{
				float4 position : SV_POSITION;
				float4 color	: COLOR;
			};

			cbuffer psData : register(b0)
			{
				float3 tint;
			}

			float4 main(VertexToPixel input) : SV_TARGET
			{
				return float4(input.color.rgb * tint, 1);
			}
		`;

		var hlslPS_SolidColor = `
			float4 main() : SV_TARGET
			{
				return float4(0,0,0,1);
			}
		`;

		// Some quick vars
		var float32Size = Float32Array.BYTES_PER_ELEMENT;
	
		// Init the API
		var device = D3D11CreateDevice(document.querySelector("#viewport"));
		var context = device.GetImmediateContext();
		var swapChain = DXGICreateSwapChain(device);

		// Make an RTV of the back buffer
		var rtv = device.CreateRenderTargetView(swapChain.GetBuffer());

		var cubeBuffs = loadOBJFile(device, "cube.obj");
		

		// Create a vertex buffer
		var vertCount = 4;
		var vertSize = 7;
		var floatSize = Float32Array.BYTES_PER_ELEMENT;
		var vbDesc = new D3D11_BUFFER_DESC(
			vertCount * vertSize * floatSize,
			D3D11_USAGE_IMMUTABLE,
			D3D11_BIND_VERTEX_BUFFER,
			0, 0, 0);
		var vertices = new Float32Array([
			0, 0.5, 0,     1,0,0,1,
			0.5, -0.5, 0,  0,1,0,1,
			-0.5, -0.5, 0, 0,0,1,1,
			-0.5, 0.5, 0,  1,1,1,1]);
		
		var vb = device.CreateBuffer(vbDesc, vertices);
		var vbStride = float32Size * 7;
		var vbOffset = 0;
		context.IASetVertexBuffers(0, [vb], [vbStride], [vbOffset]);


		// Create index buffer
		var indexCount = 4;
		var uintSize = Uint16Array.BYTES_PER_ELEMENT;
		var ibDesc = new D3D11_BUFFER_DESC(
			indexCount * uintSize,
			D3D11_USAGE_IMMUTABLE,
			D3D11_BIND_INDEX_BUFFER,
			0, 0, 0);
		var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);

		var ib = device.CreateBuffer(ibDesc, indices);
		context.IASetIndexBuffer(ib, DXGI_FORMAT_R16_UINT, 0);


		// Create constant buffer
		var elementCount = 1;
		var vsCBDesc = new D3D11_BUFFER_DESC(
			elementCount * floatSize,
			D3D11_USAGE_DEFAULT, // Note: This is generally dynamic in C++, but with no Map/Unmap in WebGL, we've got to use UpdateSubresource
			D3D11_BIND_CONSTANT_BUFFER,
			0, 0, 0);
		var vsCB = device.CreateBuffer(vsCBDesc, null);

		// Example of a "byte buffer"
		//var vsData = new ArrayBuffer(elementCount * floatSize);
		//new DataView(vsData).setFloat32(0, 0.25);

		// Set up the initial VS CB data
		var vsData = new Float32Array(1);
		vsData[0] = 0.25;
		context.UpdateSubresource(vsCB, 0, null, vsData, 0, 0);

		// Cbuffer for pixel shader
		var psCBDesc = new D3D11_BUFFER_DESC(
			3 * floatSize,
			D3D11_USAGE_DEFAULT, // Note: This is generally dynamic in C++, but with no Map/Unmap in WebGL, we've got to use UpdateSubresource
			D3D11_BIND_CONSTANT_BUFFER,
			0, 0, 0);
		var psCB = device.CreateBuffer(psCBDesc, null);

		// Set up initial PS CB data
		var psData = new Float32Array(3);
		psData[0] = 1.0;
		psData[1] = 0.5;
		psData[2] = 0.5;
		context.UpdateSubresource(psCB, 0, null, psData, 0, 0);

		// Set constant buffers
		context.VSSetConstantBuffers(0, [vsCB]);
		context.PSSetConstantBuffers(0, [psCB]);

		// Create an input layout
		var inputElements = [];
		inputElements[0] = new D3D11_INPUT_ELEMENT_DESC("POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0); 
		inputElements[1] = new D3D11_INPUT_ELEMENT_DESC("COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 3 * float32Size, D3D11_INPUT_PER_VERTEX_DATA, 0);
		var inputLayout = device.CreateInputLayout(inputElements);
		context.IASetInputLayout(inputLayout);

		// Create shaders
		var vs = device.CreateVertexShader(hlslVS);
		var ps = device.CreatePixelShader(hlslPS);
		var psSolid = device.CreatePixelShader(hlslPS_SolidColor);

		// Viewport testing
		//var vp = new D3D11_VIEWPORT(200, 200, 500, 500, 0, 1);
		//context.RSSetViewports(vp);

		// Create a sampler
		var sampDesc = new D3D11_SAMPLER_DESC(
			D3D11_FILTER_MIN_MAG_MIP_LINEAR,
			D3D11_TEXTURE_ADDRESS_WRAP,
			D3D11_TEXTURE_ADDRESS_WRAP,
			D3D11_TEXTURE_ADDRESS_WRAP,
			0,
			16,
			D3D11_COMPARISON_NEVER,
			[1, 1, 1, 1],
			0,
			D3D11_FLOAT32_MAX);
		var sampler = device.CreateSamplerState(sampDesc);

		function frameloop(time)
		{
			// Clear the RTV
			var cornflowerBlue = [0.39, 0.58, 0.93, 1];
			context.ClearRenderTargetView(rtv, cornflowerBlue);

			// Update data
			vsData[0] += 0.001;
			context.UpdateSubresource(vsCB, 0, null, vsData, 0, 0);

			// Set the common vertex shader
			context.VSSetShader(vs);

			// Draw triangles
			context.IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
			context.PSSetShader(ps);
			context.DrawIndexed(6, 0, 0);

			// Draw solid lines over the triangles
			context.IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP);
			context.PSSetShader(psSolid);
			context.DrawIndexed(6, 0, 0);

			// Flush the frame
			swapChain.Present();

			//window.requestAnimationFrame(frameloop);
		}

		window.requestAnimationFrame(frameloop);

		var hlslCodeTest =
`struct Test
{
	float3 pos : SEMANTIC;
	centroid float other;
};

struct VS_Output
{
	float4 pos : SV_POSITION;
	float2 uv : TEXCOORD;
};

cbuffer ExternalData : register(b5)
{
	Test test;  // Comments, yo!
	float3 wow;
	float pad;
}

cbuffer AnotherCBuffer
{
	float4 color;
}

float2 anotherGlobal;
float4 globalAmbient;

Texture2D albedo : register(t0);
Texture2D normalMap : register(t1);
SamplerState samp : register(s0);

/*
TextureCube sky : register(t1);
float test(){return 1;}
*/

float4 NoParams()
{
	float x = sin(5.0f);
	float y = 0;
	if(true)
	{
		y = cos(99);
	}
	return float4(x,y,1.f,1.0f);
}

float GetRed(float4 color)
{
	for(int i = 0; i < 100; i++)
	{
		color.b += 1;
	}

	if(color.b > 5)
		color.g = 1;

	return color.r;
}

VS_Output main(float3 posIn : POSITION, float2 uvIn : TEXCOORD)
{
	float x = posIn[0];
/*
// single inside multi
*/

	return float4(posIn, 1.0f);
}
`;

		var t = new HLSL(hlslCodeTest, ShaderTypeVertex);
		//console.log(t.GetGLSL());
	</script>
</body>
</html>

