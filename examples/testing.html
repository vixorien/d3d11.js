<!DOCTYPE html>
<html>
<head>
	<script src="../src/d3d11.js"></script>
	<script src="../src/hlsl.js"></script>

</head>
<body style="background-color:#000;">
	<h1 style="color:#fff;">D3D11.js Test</h1>

	<canvas id="viewport" width="800" height="600"></canvas>

	<script>

		// Some quick vars
		var float32Size = Float32Array.BYTES_PER_ELEMENT;
	
		// Init the API
		var device = D3D11CreateDevice(document.querySelector("#viewport"));
		var context = device.GetImmediateContext();
		var swapChain = DXGICreateSwapChain(device);

		// Make an RTV of the back buffer
		var rtv = device.CreateRenderTargetView(swapChain.GetBuffer());

		// Clear the RTV
		var cornflowerBlue = [0.39, 0.58, 0.93, 1];
		context.ClearRenderTargetView(rtv, cornflowerBlue);

		// Create a vertex buffer
		var vertCount = 4;
		var vertSize = 7;
		var floatSize = 4;
		var vbDesc = new D3D11_BUFFER_DESC(
			vertCount * vertSize * floatSize,
			D3D11_USAGE_IMMUTABLE,
			D3D11_BIND_VERTEX_BUFFER,
			0, 0, 0);
		var vertices = new Float32Array([
			0, 0.5, 0,     1,0,0,1,
			0.5, -0.5, 0,  0,1,0,1,
			-0.5, -0.5, 0, 0,0,1,1,
			-0.5, 0.5, 0,  1,1,1,1]);
		
		var vb = device.CreateBuffer(vbDesc, vertices);
		var vbStride = float32Size * 7;
		var vbOffset = 0;
		context.IASetVertexBuffers(0, [vb], [vbStride], [vbOffset]);


		// Create index buffer
		var indexCount = 4;
		var uintSize = Uint16Array.BYTES_PER_ELEMENT;
		var ibDesc = new D3D11_BUFFER_DESC(
			indexCount * uintSize,
			D3D11_USAGE_IMMUTABLE,
			D3D11_BIND_INDEX_BUFFER,
			0, 0, 0);
		var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);

		var ib = device.CreateBuffer(ibDesc, indices);
		context.IASetIndexBuffer(ib, DXGI_FORMAT_R16_UINT, 0);

		// Create an input layout
		var inputElements = [];
		inputElements[0] = new D3D11_INPUT_ELEMENT_DESC("POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0); 
		inputElements[1] = new D3D11_INPUT_ELEMENT_DESC("COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 3 * float32Size, D3D11_INPUT_PER_VERTEX_DATA, 0);
		var inputLayout = device.CreateInputLayout(inputElements);
		context.IASetInputLayout(inputLayout);


		// TESTING ------------------------------------------------
		function compileShader(gl, shaderCode, type)
		{
			var shader = gl.createShader(type);
			gl.shaderSource(shader, shaderCode);
			gl.compileShader(shader);
			var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
			if (!success)
			{
				alert("ERROR compiling shader: " + gl.getShaderInfoLog(shader));
			}

			return shader;
		}

		function createProgram(gl, vs, ps)
		{
			var program = gl.createProgram();
			gl.attachShader(program, vs);
			gl.attachShader(program, ps);
			gl.linkProgram(program);
			gl.validateProgram(program);
			var success = gl.getProgramParameter(program, gl.LINK_STATUS);
			if (!success)
			{
				alert("ERROR linking shaders: " + gl.getProgramInfoLog(program));
			}
			return program;
		}

		var gl = device.GetAdapter();

		// Convert HLSL to GLSL
		var hlslVS = `
			struct VSInput
			{
				float3 position;
				float4 color;
			};

			struct VSOutput
			{
				float4 position : SV_POSITION;
				float4 color	: COLOR;
			};

			VSOutput main(VSInput input)
			{
				VSOutput output;
				output.position = float4(input.position, 1);
				output.color = input.color;
				return output;
			}
		`;
		var vsToGLSL = new HLSLtoGLSL(hlslVS, ShaderTypeVertex);
		console.log(vsToGLSL.GetGLSL());
		var testVS = compileShader(gl, vsToGLSL.GetGLSL(), gl.VERTEX_SHADER);

		// Test GLSL shaders
		var vsCode = "attribute vec3 a_position; attribute vec4 a_color; varying vec4 v_color; void main() {\n v_color = a_color; gl_Position = vec4(a_position, 1.0); }";
		var psCode = "precision mediump float; varying vec4 v_color; void main() { gl_FragColor = v_color; }";

		var vs = compileShader(gl, vsCode, gl.VERTEX_SHADER);
		var ps = compileShader(gl, psCode, gl.FRAGMENT_SHADER);

		var prog = createProgram(gl, vs, ps);

		gl.useProgram(prog);

		var vp = new D3D11_VIEWPORT(200, 200, 500, 500, 0, 1);
		//context.RSSetViewports(1, [vp]);

		context.IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

		//context.Draw(3, 0);
		context.DrawIndexed(6, 0, 0);

		var hlslCodeTest =
`struct Test
{
	float3 pos : SEMANTIC;
	centroid float other;
};

struct VS_Output
{
	float4 pos : SV_POSITION;
	float2 uv : TEXCOORD;
};

cbuffer ExternalData : register(b0)
{
	Test test;  // Comments, yo!
	float3 wow;
	float pad;
}

cbuffer AnotherCBuffer
{
	float4 color;
}

float2 anotherGlobal;
float4 globalAmbient;

Texture2D albedo : register(t0);
Texture2D normalMap : register(t1);
SamplerState samp : register(s0);

/*
TextureCube sky : register(t1);
float test(){return 1;}
*/

float4 NoParams()
{
	float x = sin(5.0f);
	float y = 0;
	if(true)
	{
		y = cos(99);
	}
	return float4(x,y,1.f,1.0f);
}

float GetRed(float4 color)
{
	for(int i = 0; i < 100; i++)
	{
		color.b += 1;
	}

	if(color.b > 5)
		color.g = 1;

	return color.r;
}

VS_Output main(float3 posIn : POSITION, float2 uvIn : TEXCOORD)
{
	float x = posIn[0];
/*
// single inside multi
*/

	return float4(posIn, 1.0f);
}
`;

		var t = new HLSLtoGLSL(hlslCodeTest, ShaderTypeVertex);
		console.log(t.GetGLSL());
	</script>
</body>
</html>

