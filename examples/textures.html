<!DOCTYPE html>
<html class="h-100">
<head>
	<script src="../build/d3d11.js"></script>
	<script src="../build/input.js"></script>

	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
	<style>

		.fixed-size-custom {
			width:250px !important;
		}

		.canvas-fill-parent {
			width: 100%;
			height: 100%;
			max-height: 100vh;
			outline:none;
		}
	</style>
</head>
<body class="h-100 m-0 p-0">
	
	<!-- Trying out bootstrap -->

	<!-- Main "container", but skipping actual .container class to ensure edge-to-edge page! -->
	<div class="row h-100 m-0 p-0 overflow-hidden">

		<!-- Left "sidebar", scrollable-->
		<div class="col-3 h-100 overflow-y-auto">

			<!-- Overall title-->
			<h1>Cube Maps</h1>

			<!-- Testing tabs -->
			<ul class="nav nav-pills" id="navbar" role="tablist">
				<li class="nav-item" role="presentation">
					<button class="nav-link active" id="tabScene" data-bs-toggle="pill" data-bs-target="#scene" type="button" role="tab">Scene</button>
				</li>

				<li class="nav-item" role="presentation">
					<button class="nav-link" id="tabEnvironment" data-bs-toggle="pill" data-bs-target="#environment" type="button" role="tab">Environment</button>
				</li>

				<li class="nav-item" role="presentation">
					<button class="nav-link" id="tabControls" data-bs-toggle="pill" data-bs-target="#controls" type="button" role="tab">Controls</button>
				</li>
			</ul>

			<!-- Tab content -->
			<div class="tab-content">

				<!-- Scene tab pane -->
				<div class="tab-pane pt-3 active" id="scene" role="tabpanel" tabindex="0">

					<!-- Card: Scene -->
					<div class="card mb-3">
						<div class="card-body">
							<h5 class="card-title">Scene Selection</h5>

							<label for="sceneSet" class="form-label">Scenes</label>
							<select id="sceneSet" class="form-select" onchange="">
								<option value="0" selected>Sphere</option>
								<option value="1">Cube</option>
								<option value="2">Helix</option>
								<option value="3">Roughness Grid</option>
							</select>
						</div>
					</div>

					<!-- Card: Lighting -->
					<div class="card mb-3">
						<div class="card-body">
							<h5 class="card-title">Lights</h5>

							<label for="lightSet" class="form-label">Lights</label>
							<select id="lightSet" class="form-select" onchange="">
								<option value="0" selected>Three directional light</option>
								<option value="1">Eight rotating lights</option>
							</select>
						</div>
					</div>

				</div> 
				<!-- END Scene tab pane -->

				<!-- Environment tab pane -->
				<div class="tab-pane pt-3" id="environment" role="tabpanel" tabindex="0">

					<!-- CARD: Tonemapping -->
					<div class="card mb-3">
						<div class="card-body">
							<h5 class="card-title">Tonemapping</h5>
							<p>Change the mesh(es), lighting, environment map, etc.</p>

							<label for="mipLevelRange" class="form-label">Sky Mip Level: 0</label>
							<input type="range" class="form-range" min="0" max="16" value="0" id="mipLevelRange" oninput="setSkyMipPreview(this.value); this.previousElementSibling.innerHTML = 'Sky Mip Level: ' + this.value;" />

							<label for="exposureRange" class="form-label">Exposure Adjust (HDR only): 0</label>
							<input type="range" class="form-range" min="-10" max="10" step="0.001" value="0" id="exposureRange" oninput="setExposure(this.value); this.previousElementSibling.innerHTML = 'Exposure Adjust (HDR only): ' + this.value;" />

							<label for="tonemapType" class="form-label">Tonemap Type (HDR Only)</label>
							<select id="tonemapType" class="form-select" onchange="setTonemapType(this.value);">
								<option value="0" selected>None (Linear)</option>
								<option value="1">Reinhard</option>
								<option value="2">Reinhard (White Point)</option>
								<option value="3">Exposure</option>
								<option value="4">Uncharted 2</option>
								<option value="5">Aces</option>
							</select>
						</div>
					</div>

					<!-- CARD: Loading -->
					<div class="card mb-3">
						<div class="card-body">
							<h5 class="card-title">Load Environment</h5>
							<p>Load a new environment map in one of several ways.</p>
						</div>

						<div class="accordion m-1" id="loadAccordion">

							<!-- SIX FACES -->
							<div class="accordion-item">
								<h2 class="accordion-header">
									<button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne">
										Six Individual Faces
									</button>
								</h2>
								<div id="collapseOne" class="accordion-collapse collapse" data-bs-parent="#loadAccordion">
									<div class="accordion-body">

										<div class="input-group text-center">
											<label for="sixFacesXPos" class="input-group-text" style="min-width:50px;">+X</label>
											<input class="form-control" type="file" id="sixFacesXPos" />
										</div>

										<div class="input-group">
											<label for="sixFacesXNeg" class="input-group-text" style="min-width: 50px;">- X</label>
											<input class="form-control" type="file" id="sixFacesXNeg" />
										</div>

										<div class="input-group">
											<label for="sixFacesYPos" class="input-group-text" style="min-width:50px;">+Y</label>
											<input class="form-control" type="file" id="sixFacesYPos" />
										</div>

										<div class="input-group">
											<label for="sixFacesYNeg" class="input-group-text" style="min-width:50px;">- Y</label>
											<input class="form-control" type="file" id="sixFacesYNeg" />
										</div>

										<div class="input-group">
											<label for="sixFacesZPos" class="input-group-text" style="min-width:50px;">+Z</label>
											<input class="form-control" type="file" id="sixFacesZPos" />
										</div>

										<div class="input-group">
											<label for="sixFacesZNeg" class="input-group-text" style="min-width:50px;">- Z</label>
											<input class="form-control" type="file" id="sixFacesZNeg" />
										</div>

										<button type="button" class="btn btn-primary mt-2" onclick="loadSixFaces()">Load</button>

									</div>
								</div>
							</div>

							<!-- DDS CUBE MAP -->
							<div class="accordion-item">
								<h2 class="accordion-header">
									<button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
										DDS Cube Map (Not yet implemented)
									</button>
								</h2>
								<div id="collapseTwo" class="accordion-collapse collapse" data-bs-parent="#loadAccordion">
									<div class="accordion-body">
										Stuff here
									</div>
								</div>
							</div>

							<!-- HDR FILE -->
							<div class="accordion-item">
								<h2 class="accordion-header">
									<button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
										HDR File
									</button>
								</h2>
								<div id="collapseThree" class="accordion-collapse collapse" data-bs-parent="#loadAccordion">
									<div class="accordion-body">

										<div class="input-group">
											<label for="hdrFile" class="input-group-text">HDR</label>
											<input class="form-control" type="file" id="hdrFile" />
										</div>

										<button type="button" class="btn btn-primary mt-2" onclick="loadHDR()">Load</button>

										<div class="mt-2">
											<label for="hdrExposure" class="form-label">Exposure Adjust: 0</label>
											<input type="range" class="form-range" min="-10" max="10" step="0.001" value="0" id="hdrExposure" oninput="setHDRExposure(this.value); this.previousElementSibling.innerHTML = 'Exposure Adjust: ' + this.value;" />
										</div>

									</div>
								</div>
							</div>
						</div>
					</div>
					<!-- END Card: Loading-->

					<!-- Card: Save IBL Maps -->
					<div class="card mb-3">
						<div class="card-body">
							<h5 class="card-title">Save IBL Maps</h5>
							<p>Save any of the generated Image-Based Lighting maps</p>
							<button class="btn btn-primary mb-1" disabled>Save Skybox as DDS Cube Map</button><br />
							<button class="btn btn-primary mb-1" disabled>Save IBL Specular as DDS Cube Map</button><br />
							<button class="btn btn-primary mb-1" disabled>Save Irradiance as DDS Cube Map</button><br />
							<button class="btn btn-primary mb-1" disabled>Save BRDF Look Up Table as DDS Texture</button>
						</div>
					</div>
					<!-- END Card: Save IBL Maps -->

				</div> 
				<!-- END Environment tab pane -->

				<!-- Controls tab pane -->
				<div class="tab-pane pt-3" id="controls" role="tabpanel" tabindex="0">

					<!-- CARD: Controls -->
					<div class="card mb-3">
						<div class="card-body">
							<h5 class="card-title">Controls</h5>
							<p>Left-click & drag</p>
							<p>WASD movement</p>
						</div>
					</div>

				</div> 
				<!-- END Controls tab pane -->

			</div>

			
		</div>

		<!-- Content (3D viewport) -->
		<div class="col m-0 p-0">
			<canvas id="viewport" tabindex="1" class="canvas-fill-parent"></canvas>
		</div>

	</div>
	

	<!-- END bootstrap -->
	<script type="module">

		import { MaterialPBR } from "../build/material.js";
		import { Transform } from "../build/transform.js";
		import { Entity } from "../build/entity.js";
		import { TextureUtils } from "../build/textureUtils.js";
		import { Vector2, Vector3, Matrix4x4 } from "../build/d3dmath.js";
		import { Vertex } from "../build/vertex.js";
		import { Mesh } from "../build/mesh.js";
		import { Sky } from "../build/sky.js";

		// Global vars we can use in window functions
		let globalSky = null;
		let globalHDRExposure = 0;
		let globalSkyMipLevelPreview = 0;
		let globalTonemapType = 0;
		let globalTonemapExposure = 0;
		let globalDevice = null;
		let globalContext = null;

		window.setTonemapType = function(val)
		{
			globalTonemapType = val;
		}

		window.setExposure = function (val)
		{
			globalTonemapExposure = val;
		}

		window.setSkyMipPreview = function (val)
		{
			globalSkyMipLevelPreview = val;
		}

		window.setHDRExposure = function (val)
		{
			// Adjust exposure and re-create all PBR assets
			globalHDRExposure = val;
			globalSky.SetHDRExposure(val);
		}

		window.loadSixFaces = async function ()
		{
			// Collect all input elements
			let inputs = [
				document.getElementById("sixFacesXPos"),
				document.getElementById("sixFacesXNeg"),
				document.getElementById("sixFacesYPos"),
				document.getElementById("sixFacesYNeg"),
				document.getElementById("sixFacesZPos"),
				document.getElementById("sixFacesZNeg")
			];

			// Validate files
			for (let i = 0; i < 6; i++)
			{
				// Ensure file has been set
				if (inputs[i].files.length == 0)
				{
					alert("Missing one or more files for skybox load");
					return;
				}

				// Check extension
				let filename = inputs[i].files[0].name;
				let extension = filename.slice(filename.lastIndexOf('.'));
				if (extension != ".jpg" && extension != ".jpeg" && extension != ".png")
				{
					alert("One or more files for skybox load have invalid extensions");
					return;
				}
			}

			// Files validated - Perform the load(s)
			let fileURLs = [];
			for (let i = 0; i < 6; i++)
			{
				let cubeDataArray = await readLocalFile(inputs[i].files[0]);
				fileURLs[i] = new Blob([cubeDataArray]);
			}

			// All loaded - Attempt to load as a cube map (assuming NOT hdr)
			globalSky.LoadCubeMap(await loadTextureCube(globalDevice, globalContext, fileURLs, true, true), false);
		}
		

		window.readLocalFile = async function(file)
		{
			return new Promise((resolve, reject) =>
			{
				let fr = new FileReader();
				fr.onerror = reject;
				fr.onload = function ()
				{
					resolve(fr.result);
				}
				fr.readAsArrayBuffer(file);
			});
		}

		window.getLineFromArrayBuffer = function(arrayBuffer, startPos)
		{
			// Create a character view into the array buffer
			let charArray = new Uint8Array(arrayBuffer, startPos);

			// Track where we are
			let offset = 0;
			let line = "";
			let char = "";
			do
			{
				// Append character from array buffer
				char = String.fromCharCode(charArray[offset]);
				line += char;

				// Move forward
				offset++;
			}
			while (offset < charArray.length && char != "\n");

			return line;
		}

		
		window.loadHDR = async function()
		{
			let fileInput = document.getElementById("hdrFile");
			let [width, height, data] = await TextureUtils.LoadHDRFileLocal(fileInput);

			globalSky.LoadEquirectHDR(width, height, data, globalHDRExposure);
		}


		window.loadTextureCube = async function(device, context, faceURLs, filesAreLocal, generateMips)
		{
			let faceTextures = [];
			let size = -1;
			let mips = 1;
			for (let i = 0; i < faceURLs.length; i++)
			{
				// Fetch and grab the binary data, then turn into an image
				const resp = filesAreLocal ? faceURLs[i] : await fetch(faceURLs[i]);
				const imageBlob = filesAreLocal ? resp : await resp.blob();
				const bitmap = await createImageBitmap(imageBlob, { imageOrientation: "flipY" });

				// Set size and mips on first bitmap
				if (size == -1)
				{
					size = bitmap.width;

					if (generateMips)
					{
						mips = Math.floor(Math.log2(size)) + 1;
					}
				}

				// Validate bitmap aspect ratio
				if (bitmap.width != bitmap.height)
				{
					console.log("Error: Texture cube faces must be square");
					return;
				}

				// Validate size matches
				if (size != bitmap.width)
				{
					console.log("Error: Texture cube faces must all be the same size");
				}

				// Add to array of initial data
				faceTextures.push(bitmap);

				// Note: Must also add nulls for other mips of this face
				for (let i = 1; generateMips && i < mips; i++)
					faceTextures.push(null); // No data for this mip yet!
			}

			// Set up the texture cube
			let desc = new D3D11_TEXTURE2D_DESC(
				faceTextures[0].width,
				faceTextures[0].height,
				mips,
				6, // 6 faces (as array elements)
				DXGI_FORMAT_R8G8B8A8_UNORM,
				new DXGI_SAMPLE_DESC(1, 0),
				D3D11_USAGE_DEFAULT,
				D3D11_BIND_SHADER_RESOURCE | (generateMips ? D3D11_BIND_RENDER_TARGET : 0),
				0,
				D3D11_RESOURCE_MISC_TEXTURECUBE | (generateMips ? D3D11_RESOURCE_MISC_GENERATE_MIPS : 0));
			let texture = device.CreateTexture2D(desc, faceTextures);

			let srv = device.CreateShaderResourceView(texture, null);

			// Generate mip maps for the enviroment map for later IBL steps
			if (generateMips)
			{
				context.GenerateMips(srv);
			}

			// Release the texture
			texture.Release();
			return srv;
		}

		async function loadText(url)
		{
			const resp = await fetch(url);
			const text = await resp.text();
			return text;
		}

		async function main()
		{
			let postprocessing = true;

			let viewportElement = document.getElementById("viewport");
			let input = new Input(viewportElement);

			// Some quick vars
			let float32Size = Float32Array.BYTES_PER_ELEMENT;

			// Init the API
			const swapChainDesc = new DXGI_SWAP_CHAIN_DESC(
				viewportElement.clientWidth,
				viewportElement.clientHeight,
				DXGI_FORMAT_R8G8B8A8_UNORM);

			let [device, context, swapChain] =
				D3D11CreateDeviceAndSwapChain(viewportElement, 0, swapChainDesc);                
			globalDevice = device;
			globalContext = context;

			// Set up initial viewport
			let viewport = new D3D11_VIEWPORT(0, 0, viewportElement.clientWidth, viewportElement.clientHeight, 0, 1);
			context.RSSetViewports([viewport]);

			// Make an RTV of the back buffer
			let backBuffer = swapChain.GetBuffer();
			let rtv = device.CreateRenderTargetView(backBuffer, null);
			backBuffer.Release();

			// Create a depth buffer
			let depthDesc = new D3D11_TEXTURE2D_DESC(
				viewportElement.clientWidth,
				viewportElement.clientHeight,
				1,
				1,
				DXGI_FORMAT_D24_UNORM_S8_UINT,
				new DXGI_SAMPLE_DESC(1, 0),
				D3D11_USAGE_DEFAULT,
				D3D11_BIND_DEPTH_STENCIL,
				0,
				0);
			let depthBuffer = device.CreateTexture2D(depthDesc, null);

			// Default DSV
			let depthDSV = device.CreateDepthStencilView(depthBuffer, null);
			depthBuffer.Release();

			// Set the targets
			context.OMSetRenderTargets([rtv], depthDSV);

			// Attempt to load an image
			let albedoSRV = await TextureUtils.LoadTexture2D(device, context, "../assets/textures/cobblestone_albedo.png");
			let normalSRV = await TextureUtils.LoadTexture2D(device, context, "../assets/textures/cobblestone_normals.png");
			let metalSRV = await TextureUtils.LoadTexture2D(device, context, "../assets/textures/cobblestone_metal.png");
			let roughSRV = await TextureUtils.LoadTexture2D(device, context, "../assets/textures/cobblestone_roughness.png");
			context.PSSetShaderResources(0, [albedoSRV, normalSRV, metalSRV, roughSRV]);

			// Create several solid textures
			let blackSRV = TextureUtils.CreateSolidTexture2D(device, 2, 2, 0, 0, 0, 255);
			let whiteSRV = TextureUtils.CreateSolidTexture2D(device, 2, 2, 255, 255, 255, 255);
			let blueSRV  = TextureUtils.CreateSolidTexture2D(device, 2, 2, 0, 0, 192, 255);
			let greenSRV = TextureUtils.CreateSolidTexture2D(device, 2, 2, 0, 128, 0, 255);
			let redSRV   = TextureUtils.CreateSolidTexture2D(device, 2, 2, 255, 0, 0, 255);
			let flatNormalsSRV = TextureUtils.CreateSolidTexture2D(device, 2, 2, 127, 127, 255, 255);

			// Array of greyscale roughness textures
			let solidRoughSRVs = [];
			for (let i = 0; i < 11; i++)
			{
				let r = Math.floor((i / 10.0) * 255);
				solidRoughSRVs.push(TextureUtils.CreateSolidTexture2D(device, 2, 2, r, r, r, 255));
			}

			// Load a cube map
			let skySRV = await loadTextureCube(
				device,
				context,
				[
					"../assets/skies/cloudsblue/right.png",
					"../assets/skies/cloudsblue/left.png",
					"../assets/skies/cloudsblue/up.png",
					"../assets/skies/cloudsblue/down.png",
					"../assets/skies/cloudsblue/front.png",
					"../assets/skies/cloudsblue/back.png"
				],
				false,
				true
			);
			context.PSSetShaderResources(4, [skySRV]);

			// Create/release test
			//let crateSRV = await loadTexture2D(device, context, "../assets/textures/crate.png");
			//crateSRV.Release();


			// Create a sampler
			let sampDesc = new D3D11_SAMPLER_DESC(
				D3D11_FILTER_ANISOTROPIC,
				D3D11_TEXTURE_ADDRESS_WRAP,
				D3D11_TEXTURE_ADDRESS_WRAP,
				D3D11_TEXTURE_ADDRESS_WRAP,
				0,
				16,
				0,
				0,
				0,
				D3D11_FLOAT32_MAX);
			let sampler = device.CreateSamplerState(sampDesc);

			// Make a clamp sampler, too
			sampDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
			sampDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
			sampDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
			let clampSampler = device.CreateSamplerState(sampDesc);

			context.PSSetSamplers(0, [sampler, clampSampler]);


			// Create a rasterizer state for the sky
			let skyRastDesc = new D3D11_RASTERIZER_DESC(
				D3D11_FILL_SOLID,
				D3D11_CULL_FRONT);
			let skyRastState = device.CreateRasterizerState(skyRastDesc);

			// Create a depth/stencil state for the sky
			let skyDepthDesc = new D3D11_DEPTH_STENCIL_DESC(
				true,
				D3D11_DEPTH_WRITE_MASK_ALL,
				D3D11_COMPARISON_LESS_EQUAL);
			let skyDepthState = device.CreateDepthStencilState(skyDepthDesc);

			// Attempt to load a mesh
			let sphereMesh = await Mesh.LoadFromFile(device, "../assets/meshes/sphere.obj");
			let helixMesh = await Mesh.LoadFromFile(device, "../assets/meshes/helix.obj");
			let cubeMesh = await Mesh.LoadFromFile(device, "../assets/meshes/cube.obj");

			let currentMesh = sphereMesh;
			let currentScale = 7;
			// Sphere = 7
			// Helix = 3
			// Cube = 4.5

			// Create constant buffer
			let elementCount = 16 * 3; // 3 matrices
			let vsCBDesc = new D3D11_BUFFER_DESC(
				elementCount * Float32Array.BYTES_PER_ELEMENT,
				D3D11_USAGE_DYNAMIC,
				D3D11_BIND_CONSTANT_BUFFER,
				D3D11_CPU_ACCESS_WRITE,
				0, 0);
			let vsCB = device.CreateBuffer(vsCBDesc, null);


			let aspectRatio = viewportElement.clientWidth / viewportElement.clientHeight;

			// Camera
			let cameraPosition = new Vector3(0, 0, -10);
			let cameraRotation = new Vector2(0, 0);
			let camDir = new Vector3(0, 0, 1);

			// Set up the initial VS CB data
			let wMat = Matrix4x4.RotationY(0);
			let vMat = Matrix4x4.ViewDirectionLH(cameraPosition, camDir, Vector3.UnitY);
			let pMat = Matrix4x4.PerspectiveFovLH(Math.PI / 4.0, aspectRatio, 0.01, 100);

			let vsData = new Float32Array(elementCount);
			vsData.set(wMat, 0);
			vsData.set(vMat, 16);
			vsData.set(pMat, 32);
			context.UpdateSubresource(vsCB, 0, null, vsData, 0, 0);

			// Cbuffer for pixel shader
			let lightCount = 8 + 3; // 8 point, 3 dir
			let lightSizeInFloats = 16;
			let elementsBeforeLights = 12; // 3 vectors worth
			let psElementCount = elementsBeforeLights + lightSizeInFloats * lightCount; // Two vectors, plus one for IBL, and N lights
			let psCBDesc = new D3D11_BUFFER_DESC(
				psElementCount * Float32Array.BYTES_PER_ELEMENT,
				D3D11_USAGE_DYNAMIC,
				D3D11_BIND_CONSTANT_BUFFER,
				D3D11_CPU_ACCESS_WRITE,
				0, 0);
			let psCB = device.CreateBuffer(psCBDesc, null);

			// Set up initial PS CB data
			let lightColors = [];
			for (let i = 0; i < 8; i++)
			{
				// Pick one to be bright
				let bright = Math.random() * 3;
				let r = bright < 1 ? 1 : Math.random();
				let g = bright >= 1 && bright < 2 ? 1 : Math.random();
				let b = bright >= 2 ? 1 : Math.random();
				lightColors.push([r, g, b]);
			}
			let psData = new Float32Array(psElementCount);
			psData.set(cameraPosition, 0); // Camera pos
			psData.set([1, 1, 1], 4); // Tint
			psData.set([lightCount], 9); // Light count
			for (let i = 0; i < 8; i++)
			{
				psData.set(
					[
						1, // type - 0:dir, 1:point
						1, // intensity
						6, // range
						0, // Pad
						Math.random() * 10 - 5, Math.random() * 10 - 5, Math.random() * 10 - 5, 0, // pos + pad
						0, 0, 0, 0, // direction + pad
						lightColors[i][0], lightColors[i][1], lightColors[i][2], 0 //color + pad
					],
					elementsBeforeLights + i * 16);
			}

			// Add the three dir lights after point lights
			let dirs = [];
			dirs.push([1, -1, 1]);
			dirs.push([-1, 0, 0]);
			dirs.push([0, 1, -0.5]);
			for (let i = 8; i < 11; i++)
			{
				psData.set(
					[
						0, // type - 0:dir, 1:point
						Math.random() * 0.5 + 0.5, // intensity
						0, // range
						0, // Pad
						0, 0, 0, 0, // pos + pad
						dirs[i - 8][0], dirs[i - 8][1], dirs[i - 8][2], 0, // direction + pad
						1, 1, 1, 0 //color + pad
					],
					elementsBeforeLights + i * 16);
			}
			context.UpdateSubresource(psCB, 0, null, psData, 0, 0);


			// Cbuffer for solid color
			let solidCBDesc = new D3D11_BUFFER_DESC(
				4 * Float32Array.BYTES_PER_ELEMENT,
				D3D11_USAGE_DYNAMIC,
				D3D11_BIND_CONSTANT_BUFFER,
				D3D11_CPU_ACCESS_WRITE,
				0, 0);
			let solidCB = device.CreateBuffer(solidCBDesc, null);
			let solidData = new Float32Array(4);
			solidData.set([1, 1, 1], 0);
			context.UpdateSubresource(solidCB, 0, null, solidData, 0, 0);


			// Cbuffer for quad UI
			let quadCBDesc = new D3D11_BUFFER_DESC(
				8 * Float32Array.BYTES_PER_ELEMENT,
				D3D11_USAGE_DYNAMIC,
				D3D11_BIND_CONSTANT_BUFFER,
				D3D11_CPU_ACCESS_WRITE,
				0, 0);
			let quadCB = device.CreateBuffer(quadCBDesc, null);
			let quadData = new Float32Array(8);



			// Create an input layout
			let inputElements = [];
			inputElements[0] = new D3D11_INPUT_ELEMENT_DESC("POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0);
			inputElements[1] = new D3D11_INPUT_ELEMENT_DESC("TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 3 * float32Size, D3D11_INPUT_PER_VERTEX_DATA, 0);
			inputElements[2] = new D3D11_INPUT_ELEMENT_DESC("NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 5 * float32Size, D3D11_INPUT_PER_VERTEX_DATA, 0);
			inputElements[3] = new D3D11_INPUT_ELEMENT_DESC("TANGENT", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 8 * float32Size, D3D11_INPUT_PER_VERTEX_DATA, 0);
			let inputLayout = device.CreateInputLayout(inputElements);
			context.IASetInputLayout(inputLayout);

			// Create shaders
			let ps = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/PBR_PS.hlsl"));
			let vs = device.CreateVertexShader(await HLSL.LoadTextFromURL("../assets/shaders/PBR_VS.hlsl"));
			let solidPS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/SolidColorPS.hlsl"));
			let skyVS = device.CreateVertexShader(await HLSL.LoadTextFromURL("../assets/shaders/SkyVS.hlsl"));
			let skyPS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/SkyPS.hlsl"));
			let tonemapPS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/TonemapPS.hlsl"));
			let postprocPS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/BlurPS.hlsl"));
			let quadVS = device.CreateVertexShader(await HLSL.LoadTextFromURL("../assets/shaders/QuadVS.hlsl"));
			let fullscreenVS = device.CreateVertexShader(await HLSL.LoadTextFromURL("../assets/shaders/FullscreenVS.hlsl"));
			let simpleTexturePS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/SimpleTexturePS.hlsl"));

			let equirectToCubePS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/EquirectToCubePS.hlsl"));

			// Shaders for IBL
			let brdfLutPS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/IBLBrdfLookUpTablePS.hlsl"));
			let iblIrradiancePS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/IBLIrradianceMapPS.hlsl"));
			let iblSpecularPS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/IBLSpecularConvolutionPS.hlsl"));


			// Create the sky object
			globalSky = new Sky(device, context,
				skyVS, skyPS, cubeMesh,
				DXGI_FORMAT_R16G16_FLOAT, 1024, brdfLutPS,
				DXGI_FORMAT_R32G32B32A32_FLOAT, 64, iblIrradiancePS,
				DXGI_FORMAT_R32G32B32A32_FLOAT, 512, 3, iblSpecularPS,
				equirectToCubePS, fullscreenVS,
				true, 128);
			globalSky.LoadCubeMap(skySRV, false);


			// Entity setup
			let mat = new MaterialPBR(
				vs, ps, new Vector3(1, 1, 1),
				albedoSRV,
				normalSRV,
				metalSRV,
				roughSRV); 
			let entity = new Entity(
				sphereMesh,
				mat);
			entity.Transform.ScaleUniform(7);




			// Texture saving test
			let ddsTest = false;
			if (ddsTest)
			{
				let [w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels] = TextureUtils.ReadPixelDataFromSRV(device, context, irrSRV);
				TextureUtils.WriteDDSFile("irr.dds", w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels);
			}

			// Test for scissor
			let scissorRastState = device.CreateRasterizerState(new D3D11_RASTERIZER_DESC(D3D11_FILL_SOLID, D3D11_CULL_BACK, false, 0, 0, 0, true, true));

			// Reset the render target
			context.OMSetRenderTargets([rtv], depthDSV);

			context.VSSetShader(vs);
			context.PSSetShader(ps);

			// Post process resources
			let ppTexDesc = new D3D11_TEXTURE2D_DESC(
				viewportElement.width,
				viewportElement.height,
				1,
				1,
				DXGI_FORMAT_R32G32B32A32_FLOAT,
				new DXGI_SAMPLE_DESC(1, 0),
				D3D11_USAGE_DEFAULT,
				D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE,
				0,
				0);
			let ppTexture = device.CreateTexture2D(ppTexDesc, [null]);
			let ppSRV = device.CreateShaderResourceView(ppTexture, null);
			let ppRTV = device.CreateRenderTargetView(ppTexture, null);
			ppTexture.Release();

			// Post process constant buffer
			let ppCBDesc = new D3D11_BUFFER_DESC(
				Float32Array.BYTES_PER_ELEMENT * 4,
				D3D11_USAGE_DYNAMIC,
				D3D11_BIND_CONSTANT_BUFFER,
				D3D11_CPU_ACCESS_WRITE,
				0, 0);
			let ppCB = device.CreateBuffer(ppCBDesc, null);
			let ppData = new Float32Array(4);

			// Ensure we're set for triangles
			context.IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

		
			// Perform a readback
			// Need to actually copy to a staging resource!
			//let readback = new Uint8Array(256*256*4);
			//let lutResource = lutSRV.GetResource();
			//device.ReadFromSubresource(readback, lutResource, 0, null);
			//lutResource.Release();
			//
			//console.log(readback);


			// 1D texture test
			//let width1D = 256;
			//let data1D = new Uint8Array(width1D * 4);
			//for (let i = 0; i < width1D * 4;)
			//{
			//	let v = Math.floor(i / 4) / width1D * 255;
			//	data1D[i++] = v;
			//	data1D[i++] = v;
			//	data1D[i++] = v;
			//	data1D[i++] = 1;
			//}

			//let desc1D = new D3D11_TEXTURE1D_DESC(
			//	width1D,
			//	1,
			//	1,
			//	DXGI_FORMAT_R8G8B8A8_UNORM,
			//	D3D11_USAGE_IMMUTABLE,
			//	D3D11_BIND_SHADER_RESOURCE,
			//	0, 0);

			//let texture1D = device.CreateTexture1D(desc1D, [data1D]);
			//let srv1D = device.CreateShaderResourceView(texture1D, null);
			//texture1D.Release();

			// 3D texture test
			//let width3D = 32;
			//let totalBytes = width3D * width3D * width3D * 4;
			//let data3D = new Uint8Array(totalBytes);
			//let byteCount = 0;
			//for (let z = 0; z < width3D; z++)
			//{
			//	for (let y = 0; y < width3D; y++)
			//	{
			//		for (let x = 0; x < width3D; x++)
			//		{
			//			data3D[byteCount++] = x / width3D * 255;
			//			data3D[byteCount++] = y / width3D * 255;
			//			data3D[byteCount++] = z / width3D * 255;
			//			data3D[byteCount++] = 1;
			//		}
			//	}
			//}

			//let desc3D = new D3D11_TEXTURE3D_DESC(
			//	width3D,
			//	width3D,
			//	width3D,
			//	1,
			//	DXGI_FORMAT_R8G8B8A8_UNORM,
			//	D3D11_USAGE_IMMUTABLE,
			//	D3D11_BIND_SHADER_RESOURCE,
			//	0, 0);

			//let texture3D = device.CreateTexture3D(desc3D, [data3D]);
			//let srv3D = device.CreateShaderResourceView(texture3D, null);
			//texture3D.Release();

			// Test scissor rect
			//let sciDesc = new D3D11_RASTERIZER_DESC(
			//	D3D11_FILL_SOLID,
			//	D3D11_CULL_NONE,
			//	false, 0, 0, 0, true,
			//	true); // Scissor
			//let sciRS = device.CreateRasterizerState(sciDesc);
			//let sciRect = new D3D11_RECT(100, 100, 300, 150);



			function update(time)
			{
				// Update
				let speed = 0.2;
				if (input.IsKeyDown(Keys.Shift)) speed *= 5;
				if (input.IsMouseDown(MouseButtons.Right)) speed *= 0.15;

				let cameraMoveRelative = new Vector3();
				let cameraMoveAbsolute = new Vector3();
				let anyMove = false;
				if (input.IsKeyDown(Keys.A)) { anyMove = true; cameraMoveRelative.x -= speed; }
				if (input.IsKeyDown(Keys.D)) { anyMove = true; cameraMoveRelative.x += speed; }
				if (input.IsKeyDown(Keys.W)) { anyMove = true; cameraMoveRelative.z += speed; }
				if (input.IsKeyDown(Keys.S)) { anyMove = true; cameraMoveRelative.z -= speed; }
				if (input.IsKeyDown(Keys.Space)) { anyMove = true; cameraMoveAbsolute.y += speed; }
				if (input.IsKeyDown(Keys.X)) { anyMove = true; cameraMoveAbsolute.y -= speed; }

				if (input.IsMouseDown(MouseButtons.Left) || input.IsMouseDown(MouseButtons.Right))
				{
					cameraRotation.x += input.GetMouseDeltaY() * 0.001;
					cameraRotation.y += input.GetMouseDeltaX() * 0.001;

					camDir.x = Math.sin(cameraRotation.y);
					camDir.z = Math.cos(cameraRotation.y);

					camDir.y = -Math.sin(cameraRotation.x);
				}

				if (anyMove)
				{
					// Relative movement based on rotation
					let moveRelative = Vector3.Rotate(cameraMoveRelative, cameraRotation.x, cameraRotation.y, 0);
					cameraPosition = Vector3.Add(cameraPosition, moveRelative);

					// Absolute movement
					cameraPosition = Vector3.Add(cameraPosition, cameraMoveAbsolute);
				}

				// Check for any progressive IBL updates
				globalSky.Update();

			}

			function checkForResize()
			{
				// Has the window changed size?
				if (viewportElement.width != viewportElement.clientWidth ||
					viewportElement.height != viewportElement.clientHeight)
				{
					// Need to resize, so first release all references
					rtv.Release(); // Back buffer
					depthDSV.Release(); // Depth buffer

					// Ask the swap chain to resize and update the canvas
					viewportElement.width = viewportElement.clientWidth;
					viewportElement.height = viewportElement.clientHeight;
					swapChain.ResizeBuffers(viewportElement.clientWidth, viewportElement.clientHeight);

					// Make new RTV
					let bb = swapChain.GetBuffer();
					rtv = device.CreateRenderTargetView(bb, null);
					bb.Release();

					// Make new depth buffer
					let depthDesc = new D3D11_TEXTURE2D_DESC(
						viewportElement.clientWidth,
						viewportElement.clientHeight,
						1,
						1,
						DXGI_FORMAT_D24_UNORM_S8_UINT,
						new DXGI_SAMPLE_DESC(1, 0),
						D3D11_USAGE_DEFAULT,
						D3D11_BIND_DEPTH_STENCIL,
						0,
						0);
					let depthBuffer = device.CreateTexture2D(depthDesc, null);

					// Default DSV
					depthDSV = device.CreateDepthStencilView(depthBuffer, null);
					depthBuffer.Release();

					// Set the new views
					context.OMSetRenderTargets([rtv], depthDSV);

					// Update aspect ratio and camera
					aspectRatio = viewportElement.clientWidth / viewportElement.clientHeight;
					pMat = Matrix4x4.PerspectiveFovLH(Math.PI / 4.0, aspectRatio, 0.01, 100);
					vsData.set(pMat, 32);

					// Update rendering viewport, too
					viewport.Width = viewportElement.clientWidth;
					viewport.Height = viewportElement.clientHeight;
					context.RSSetViewports([viewport]);

					// Create new post processing resource, too
					ppSRV.Release();
					ppRTV.Release();
					let ppTexDesc = new D3D11_TEXTURE2D_DESC(
						viewportElement.width,
						viewportElement.height,
						1,
						1,
						DXGI_FORMAT_R32G32B32A32_FLOAT,
						new DXGI_SAMPLE_DESC(1, 0),
						D3D11_USAGE_DEFAULT,
						D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE,
						0,
						0);
					let ppTexture = device.CreateTexture2D(ppTexDesc, [null]);
					ppSRV = device.CreateShaderResourceView(ppTexture, null);
					ppRTV = device.CreateRenderTargetView(ppTexture, null);
					ppTexture.Release();
				}
			}


			function draw(time)
			{
				checkForResize();

				// Set up tone mapping if necessary
				if (globalSky.IsHDR())
				{
					context.OMSetRenderTargets([ppRTV], depthDSV);
				}

				vMat = Matrix4x4.ViewDirectionLH(
					cameraPosition,
					camDir, //new Vector3(0, 0, 1),
					Vector3.UnitY);

				vsData.set(vMat, 16);

				// Set constant buffers for main draw
				context.VSSetConstantBuffers(0, [vsCB]);
				context.PSSetConstantBuffers(0, [psCB]);

				// Clear the frame
				let black = [0, 0, 0, 1];
				let cornflowerBlue = [0.39, 0.58, 0.93, 1];
				context.ClearRenderTargetView(rtv, black);
				context.ClearDepthStencilView(depthDSV, D3D11_CLEAR_DEPTH, 1.0, 0);

				// Light sphere draws
				{
					// Swap to sphere buffers
					context.VSSetShader(vs);
					context.PSSetShader(solidPS);
					context.PSSetConstantBuffers(0, [solidCB]);
					context.IASetVertexBuffers(0, [sphereMesh.VertexBuffer], [Vertex.GetStrideInBytes()], [0]);
					context.IASetIndexBuffer(sphereMesh.IndexBuffer, DXGI_FORMAT_R16_UINT, 0);

					for (let i = 0; i < 8; i++)
					{
						let offset = (i / 4) * Math.PI * 2;
						let s = Math.sin(time * 0.0005 + offset);
						let c = Math.cos(time * 0.0005 + offset);

						let lightPos = [3 * s, i < 4 ? -3 : 3, 3 * c];

						wMat = Matrix4x4.Translation(lightPos[0], lightPos[1], lightPos[2]);
						vsData.set(wMat, 0);
						context.UpdateSubresource(vsCB, 0, null, vsData, 0, 0);

						// Update PS data for later (12 initial, 16 per light, 4 floats deep)
						psData.set(lightPos, elementsBeforeLights + i * 16 + 4);

						// Update data for this draw
						solidData.set(lightColors[i], 0);
						context.UpdateSubresource(solidCB, 0, null, solidData, 0, 0);

						// Draw sphere
						context.DrawIndexed(sphereMesh.IndexCount, 0, 0);
					}
				}

				// Pipeline for next several draws
				context.VSSetShader(vs);
				context.PSSetShader(ps);
				context.PSSetConstantBuffers(0, [psCB]);

				function DrawEntity(e)
				{
					// Set shaders
					context.VSSetShader(e.Material.VertexShader);
					context.PSSetShader(e.Material.PixelShader);

					// Update vertex data
					vsData.set(e.Transform.WorldMatrix, 0);
					context.UpdateSubresource(vsCB, 0, null, vsData, 0, 0);

					// Update pixel data
					psData.set(cameraPosition, 0);
					psData.set([globalSky.SpecularIBLMipsTotal], 8);
					psData.set([lightCount], 9);  // Set light count (all lights)
					psData.set([globalSky.IsHDR ? 1 : 0], 10); // Set HDR switch
					context.UpdateSubresource(psCB, 0, null, psData, 0, 0);

					// Textures
					context.PSSetShaderResources(0, [
						e.Material.AlbedoSRV,
						e.Material.NormalSRV,
						e.Material.MetalSRV,
						e.Material.RoughSRV,
						globalSky.BRDFLookUpTableSRV, globalSky.IrradianceCubeSRV, globalSky.SpecularIBLCubeSRV
					]);

					// Draw
					context.IASetVertexBuffers(0, [e.Mesh.VertexBuffer], [Vertex.GetStrideInBytes()], [0]);
					context.IASetIndexBuffer(e.Mesh.IndexBuffer, DXGI_FORMAT_R16_UINT, 0);
					context.DrawIndexed(e.Mesh.IndexCount, 0, 0);
				}

				// Main shape draw
				{
					DrawEntity(entity);
					//// Update vertex data
					//let rot = new Matrix4x4();
					//Matrix4x4.FillIdentity(rot);//Matrix4x4.RotationY(time * -0.00025);

					//let sc = Matrix4x4.ScaleUniform(currentScale);
					//wMat = Matrix4x4.Multiply(sc, rot);
					//vsData.set(wMat, 0);
					//context.UpdateSubresource(vsCB, 0, null, vsData, 0, 0);

					//// Update pixel data (set above while lights are moving)
					//psData.set(cameraPosition, 0);
					//psData.set([globalSky.SpecularIBLMipsTotal], 8);
					//psData.set([lightCount], 9);  // Set light count (all lights)
					//psData.set([globalSky.IsHDR ? 1 : 0], 10); // Set HDR switch
					//context.UpdateSubresource(psCB, 0, null, psData, 0, 0);

					//// Textures
					//context.PSSetShaderResources(0, [
					//	albedoSRV, normalSRV, metalSRV, roughSRV,
					//	globalSky.BRDFLookUpTableSRV, globalSky.IrradianceCubeSRV, globalSky.SpecularIBLCubeSRV
					//]);

					//// Draw
					//context.IASetVertexBuffers(0, [currentMesh.VertexBuffer], [Vertex.GetStrideInBytes()], [0]);
					//context.IASetIndexBuffer(currentMesh.IndexBuffer, DXGI_FORMAT_R16_UINT, 0);
					//context.DrawIndexed(currentMesh.IndexCount, 0, 0);
				}

				// Roughness spheres
				{
					let scale = 2;
					let y = 7;
					let spacing = 2.2;
					let sc = Matrix4x4.ScaleUniform(scale);
					let tr = Matrix4x4.Identity();

					// Turn off lights
					psData.set([9], 9); // Zero light count
					context.UpdateSubresource(psCB, 0, null, psData, 0, 0);

					// Set up the overall pipeline for spheres
					context.IASetVertexBuffers(0, [sphereMesh.VertexBuffer], [Vertex.GetStrideInBytes()], [0]);
					context.IASetIndexBuffer(sphereMesh.IndexBuffer, DXGI_FORMAT_R16_UINT, 0);


					let rowMats = [
						// Albedo,	normals,        metals
						[blackSRV,  flatNormalsSRV, blackSRV],
						[whiteSRV,  flatNormalsSRV, blackSRV],
						[redSRV,    flatNormalsSRV, blackSRV],
						[greenSRV,  flatNormalsSRV, blackSRV],
						[blueSRV,   flatNormalsSRV, blackSRV],
						[whiteSRV,  flatNormalsSRV,	whiteSRV]
					];

					for (let row = 0; row < rowMats.length; row++)
					{
						for (let i = 0; i < 11; i++)
						{
							// Per object data
							Matrix4x4.FillTranslation(tr, (i - 5) * spacing, y + row * spacing, 0);
							wMat = Matrix4x4.Multiply(tr, sc);
							vsData.set(wMat, 0);
							context.UpdateSubresource(vsCB, 0, null, vsData, 0, 0);

							// Set textures for this sphere
							context.PSSetShaderResources(0, [
								rowMats[row][0], rowMats[row][1], rowMats[row][2], solidRoughSRVs[i],
								globalSky.BRDFLookUpTableSRV, globalSky.IrradianceCubeSRV, globalSky.SpecularIBLCubeSRV
							]);

							// Draw one sphere
							context.DrawIndexed(sphereMesh.IndexCount, 0, 0);
						}
					}
				}

				// Skybox
				{
					globalSky.Draw(vMat, pMat, globalSkyMipLevelPreview);
				}

				// Finalize post processing if necessary
				if (globalSky.IsHDR())
				{
					context.OMSetRenderTargets([rtv], null);
					context.VSSetShader(fullscreenVS);
					context.PSSetShader(tonemapPS);
					context.PSSetShaderResources(0, [ppSRV]);
					context.PSSetConstantBuffers(0, [ppCB]);
					ppData.set([
						globalTonemapType, // Tonemap type
						globalTonemapExposure // Exposure
					], 0);
					context.UpdateSubresource(ppCB, 0, null, ppData, 0, 0);
					context.Draw(3, 0);
				}

				// Draw "UI"
				//{
				//	quadData.set([
				//		100, 100, // Position in pixels
				//		100, 100, // Size in pixels
				//		viewportElement.clientWidth, viewportElement.clientHeight // Window size
				//	]);
				//	context.UpdateSubresource(quadCB, 0, null, quadData, 0, 0);

				//	context.VSSetShader(quadVS);
				//	context.VSSetConstantBuffers(0, [quadCB]);

				//	context.PSSetShader(simpleTexturePS);
				//	context.PSSetShaderResources(0, [globalSky.GetEquirectSRV()]);

				//	context.Draw(6, 0);
				//}

				// Flush the frame
				swapChain.Present();

				context.OMSetRenderTargets([rtv], depthDSV);
			}

			function frameloop(time)
			{
				update(time);
				draw(time);

				// End of frame work
				window.requestAnimationFrame(frameloop);
				input.EndOfFrame();
			}

			window.requestAnimationFrame(frameloop);

		}


		main();
	</script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
</body>
</html>

