<!DOCTYPE html>
<html class="h-100">
<head>
	<script src="../build/d3d11.js"></script>
	<script src="../build/d3dmath.js"></script>
	<script src="../build/input.js"></script>

	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
	<style>

	/*	html {
			height: 100%;
		}

		body {
			margin: 0;
			height: 100%;
			font-family: Arial;
			background-color: white;
		}

		#pageContainer {
			display: flex;
			flex-direction: row;
			height: 100%;
		}

		#controlsContainer {
			margin: 10px;
			flex: 0 0 auto;
			height: 100%;
			align-items: stretch;
		}

		#canvasContainer {
			flex: 1 0 0;
			background-color: dimgrey;
		}

		#viewport {
			width: 100%;
			height: 100%;
		}

		#load_six_faces {
			visibility: visible;
		}

		#load_dds {
			visibility: hidden;
		}

		#load_hdr {
			visibility: hidden;
		}*/

		.fixed-size-custom {
			width:250px !important;
		}

		.canvas-fill-parent {
			width: 100%;
			height: 100%;
			max-height: 100vh;
		}
	</style>
</head>
<body class="h-100 m-0 p-0">
	
	<!-- Trying out bootstrap -->

	<!-- Main "container", but skipping actual .container class to ensure edge-to-edge page! -->
	<div class="row h-100 m-0 p-0 overflow-hidden">

		<!-- Left "sidebar", scrollable-->
		<div class="col-3 h-100 overflow-y-auto">

			<!-- Overall title-->
			<h1>Cube Maps</h1>

			<!-- Section for scene -->
			<div class="card mb-3">
				<div class="card-body">
					<h5 class="card-title">Scene</h5>
					<p>Change the mesh(es), lighting, environment map, etc.</p>
				</div>
			</div>

			<!-- Section for controls -->
			<div class="card mb-3">
				<div class="card-body">
					<h5 class="card-title">Controls</h5>
					<p>Left-click & drag</p>
					<p>WASD movement</p>
				</div>
			</div>

			<!-- Section for Loading -->

			<div class="card mb-3">
				<div class="card-body">
					<h5 class="card-title">Load Environment</h5>
					<p>Load a new environment map in one of several ways.</p>
				</div>

				<div class="accordion m-1" id="loadAccordion">

					<!-- SIX FACES -->
					<div class="accordion-item">
						<h2 class="accordion-header">
							<button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne">
								Six Individual Faces
							</button>
						</h2>
						<div id="collapseOne" class="accordion-collapse collapse" data-bs-parent="#loadAccordion">
							<div class="accordion-body">

								<div class="input-group text-center">
									<label for="sixFacesXPos" class="input-group-text" style="min-width:50px;">+X</label>
									<input class="form-control" type="file" id="sixFacesXPos" />
								</div>

								<div class="input-group">
									<label for="sixFacesXNeg" class="input-group-text" style="min-width: 50px;">- X</label>
									<input class="form-control" type="file" id="sixFacesXNeg" />
								</div>

								<div class="input-group">
									<label for="sixFacesYPos" class="input-group-text" style="min-width:50px;">+Y</label>
									<input class="form-control" type="file" id="sixFacesYPos" />
								</div>

								<div class="input-group">
									<label for="sixFacesYNeg" class="input-group-text" style="min-width:50px;">- Y</label>
									<input class="form-control" type="file" id="sixFacesYNeg" />
								</div>

								<div class="input-group">
									<label for="sixFacesZPos" class="input-group-text" style="min-width:50px;">+Z</label>
									<input class="form-control" type="file" id="sixFacesZPos" />
								</div>

								<div class="input-group">
									<label for="sixFacesZNeg" class="input-group-text" style="min-width:50px;">- Z</label>
									<input class="form-control" type="file" id="sixFacesZNeg" />
								</div>

								<button type="button" class="btn btn-primary mt-2" onclick="loadSixFaces()">Load</button>

							</div>
						</div>
					</div>

					<!-- DDS CUBE MAP -->
					<div class="accordion-item">
						<h2 class="accordion-header">
							<button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
								DDS Cube Map (Not yet implemented)
							</button>
						</h2>
						<div id="collapseTwo" class="accordion-collapse collapse" data-bs-parent="#loadAccordion">
							<div class="accordion-body">
								Stuff here
							</div>
						</div>
					</div>

					<!-- HDR FILE -->
					<div class="accordion-item">
						<h2 class="accordion-header">
							<button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
								HDR File (Not yet implemented)
							</button>
						</h2>
						<div id="collapseThree" class="accordion-collapse collapse" data-bs-parent="#loadAccordion">
							<div class="accordion-body">

								<div class="input-group">
									<label for="hdrFile" class="input-group-text">HDR</label>
									<input class="form-control" type="file" id="hdrFile" />
								</div>

								<button type="button" class="btn btn-primary mt-2" onclick="loadHDR()">Load</button>

							</div>
						</div>
					</div>
				</div>
			</div>

			<!-- Section for saving -->
			<div class="card mb-3">
				<div class="card-body">
					<h5 class="card-title">Save IBL Maps</h5>
					<p>Save any of the generated Image-Based Lighting maps</p>
					<button class="btn btn-primary mb-1">Save Convolved Spec Map as DDS</button><br />
					<button class="btn btn-primary mb-1">Save Irradiance Map as DDS</button><br />
					<button class="btn btn-primary mb-1">Save LUT as PNG</button>
				</div>
			</div>

		</div>

		<!-- Content (3D viewport) -->
		<div class="col m-0 p-0">
			<canvas id="viewport" class="canvas-fill-parent"></canvas>
		</div>

	</div>
	

	<!-- END bootstrap -->
	<script>
		let globalSkySRV = null;
		let globalIrrSRV = null;
		let globalIBLSpecSRV = null;

		let globalIBLSampler = null;
		let globalIrrPS = null;
		let globalIBLSpecPS = null;
		let globalFullscreenVS = null;

		async function loadSixFaces()
		{
			// Collect all input elements
			let inputs = [
				document.getElementById("sixFacesXPos"),
				document.getElementById("sixFacesXNeg"),
				document.getElementById("sixFacesYPos"),
				document.getElementById("sixFacesYNeg"),
				document.getElementById("sixFacesZPos"),
				document.getElementById("sixFacesZNeg")
			];

			// Validate files
			for (let i = 0; i < 6; i++)
			{
				// Ensure file has been set
				if (inputs[i].files.length == 0)
				{
					alert("Missing one or more files for skybox load");
					return;
				}

				// Check extension
				let filename = inputs[i].files[0].name;
				let extension = filename.slice(filename.lastIndexOf('.'));
				if (extension != ".jpg" && extension != ".jpeg" && extension != ".png")
				{
					alert("One or more files for skybox load have invalid extensions");
					return;
				}
			}

			// Files validated - Perform the load(s)
			let fileURLs = [];
			for (let i = 0; i < 6; i++)
			{
				let cubeDataArray = await readLocalFile(inputs[i].files[0]);
				fileURLs[i] = new Blob([cubeDataArray]);
			}

			// All loaded - Attempt to load as a cube map
			globalSkySRV = await loadTextureCube(globalDevice, globalContext, fileURLs, true);

			globalIrrSRV.Release();
			globalIrrSRV = createIrradianceMap(globalDevice, globalContext, 64, globalSkySRV, globalIBLSampler, globalIrrPS, globalFullscreenVS);

			globalIBLSpecSRV.Release();
			globalIBLSpecSRV = createIBLSpecularMap(globalDevice, globalContext, 256, 3, globalSkySRV, globalIBLSampler, globalIBLSpecPS, globalFullscreenVS);
		}

		async function readLocalFile(file)
		{
			return new Promise((resolve, reject) =>
			{
				let fr = new FileReader();
				fr.onerror = reject;
				fr.onload = function ()
				{
					resolve(fr.result);
				}
				fr.readAsArrayBuffer(file);
			});
		}

		function getLineFromArrayBuffer(arrayBuffer, startPos)
		{
			// Create a character view into the array buffer
			let charArray = new Uint8Array(arrayBuffer, startPos);

			// Track where we are
			let offset = 0;
			let line = "";
			let char = "";
			do
			{
				// Append character from array buffer
				char = String.fromCharCode(charArray[offset]);
				line += char;

				// Move forward
				offset++;
			}
			while (offset < charArray.length && char != "\n");

			return line;
		}

		// Reads an HDR file
		// Based on: http://www.cs.virginia.edu/~jcw5q/apps/imageview/src/libimageviewer/hdr.c
		// Also see: https://paulbourke.net/dataformats/pic/
		async function loadHDR()
		{
			let fileInput = document.getElementById("hdrFile");

			// Ensure file has been set
			if (fileInput.files.length == 0)
			{
				alert("Missing HDR file");
				return;
			}

			// Check extension
			let filename = fileInput.files[0].name;
			let extension = filename.slice(filename.lastIndexOf('.'));
			if (extension != ".hdr")
			{
				alert("Invalid file extension for HDR file");
				return;
			}

			let data = await readLocalFile(fileInput.files[0]);

			// Handle signature
			let decoder = new TextDecoder();

			const headerSig = "#?RADIANCE";
			const headerFormat = "FORMAT=";
			const headerExposure = "EXPOSURE=";
			const headerFormatRGB = "32-bit_rle_rgbe";
			const headerFormatXYZ = "32-bit_rle_xyze";
			const formatRGB = "RGB";
			const formatXYZ = "XYZ";

			// Use typed array as a view into the data, and decode as a string
			let sig = decoder.decode(new Int8Array(data, 0, headerSig.length));
			if (sig != headerSig)
			{
				alert("Required HDR header signature not found");
				return;
			}

			// File details from header
			let format = null;
			let exposure = 1;
			let flipX = false;
			let flipY = false;
			let width = -1;
			let height = -1;

			// Loop and find format string
			let offset = headerSig.length + 1; // Account for initial new line
			let line = "";

			do
			{
				// Grab line (untrimmed so we can offset properly)
				line = getLineFromArrayBuffer(data, offset);
				offset += line.length;

				// Trim before checking
				line = line.trim();

				// Check for various header elements
				if (line.startsWith(headerFormat))
				{
					let formatFromHeader = line.substring(headerFormat.length); // Skip "FORMAT="

					// Validate format and save
					if (formatFromHeader == headerFormatRGB)
						format = formatRGB;
					else if (formatFromHeader == headerFormatXYZ)
						format = formatXYZ;
					else
					{
						alert("Invalid HDR format specified in header: " + formatFromHeader);
						return;
					}
				}
				else if (line.startsWith(headerExposure))
				{
					let expFromHeader = Number(line.substring(headerExposure.length)); // Skip "EXPOSURE="

					// Validate number
					if (isNan(expFromHeader))
					{
						alert("Invalid HDR exposure specified in header");
						return;
					}

					// Ignore zero
					if (expFromHeader != 0)
					{
						exposure = expFromHeader;
					}
				}
			}
			while (line != "");

			// We've found a blank line, so the next thing should be the resolution string
			let resString = getLineFromArrayBuffer(data, offset);
			offset += resString.length;
			
			// Parse resolution string into resolution elements (re)
			let re = resString.trim().split(" ");
			if (re.length != 4)
			{
				alert("Invalid resolution details in HDR file");
				return;
			}

			// Check first resolution element
			switch (re[0])
			{
				case "+X": width = Number(re[1]); break;
				case "-X": width = Number(re[1]); flipX = true; break;
				case "+Y": height = Number(re[1]); break;
				case "-Y": height = Number(re[1]); flipY = true; break;
				default:
					alert("Invalid resolution details in HDR file")
					return;
			}

			// Check next resolution element
			switch (re[2])
			{
				case "+X": width = Number(re[3]); break;
				case "-X": width = Number(re[3]); flipX = true; break;
				case "+Y": height = Number(re[3]); break;
				case "-Y": height = Number(re[3]); flipY = true; break;
				default:
					alert("Invalid resolution details in HDR file")
					return;
			}

			// Validate that we got both width and height
			if (width <= 0 || height <= 0)
			{
				alert("Invalid width or height details in HDR file");
				return;
			}

			// Offset is now where the actual data begins!
			let source = new Uint8Array(data, offset);
			let sourceIndex = 0;

			// We'll be storing results as R32G32B32A32 float pixels
			let dest = new Uint32Array(width * height * 4);
			let destIndex = 0;

			// Loop through scanlines
			for (let s = 0; s < height; s++)
			{
				// Grab the first "pixel" of this line, which is encoding info
				let encoding = new Uint8Array(source, sourceIndex, 4);
				sourceIndex += 4;

				// First pixel is encoding information
				let scanlineStart = destIndex;
				if (encoding[0] == 2 && encoding[1] == 2 && encoding[2] < 128) // New RLE ---
				{
					// Components handled separately
					for (let c = 0; c < 4; c++)
					{
						// Offset to this component in the scanline
						let compOffset = scanlineStart + c;

						// Loop through destination pixels
						for (let destPixel = 0; destPixel < width;)
						{
							let run = source[sourceIndex];
							sourceIndex++;

							// Check the first component of this pixel
							if (run <= 128)
							{
								// No run; contiguous single-component data
								for (let r = 0; r < run; r++)
								{
									dest[compOffset + r * 4] = source[sourceIndex];
									sourceIndex++;
								}
							}
							else
							{
								// Run!  Adjust value
								run -= 128; // Or (run &= 127)?

								// Grab the value for this run
								let val = source[sourceIndex];
								sourceIndex++;

								for (let r = 0; r < run; r++)
								{
									dest[compOffset + r * 4] = val;
								}
							}

							// Apply this run to the destination pixel on this scanline
							destPixel += run;
						}
					}
				}
				else // Old RLE ---
				{
					// First set of data is actually the first pixel, so back up
					sourceIndex -= 4;

					// Loop through pixels of this scanline
					let shift = 0;
					for (let destIndex = 0; destIndex < width * 4;)
					{
						// Grab this pixel
						let pixel = new Uint8Array(source, sourceIndex, 4);
						sourceIndex += 4;

						// Check this pixel for RLE span
						// Note: Starting with the first pixel from above!
						if (pixel[0] == 1 && pixel[1] == 1 && pixel[2] == 1)
						{
							// RLE span!  Get the length
							let spanLength = pixel[3] << shift;

							for (let i = 0; i < spanLength; i++)
							{
								// Converting from int to float here!
								dest[destIndex + 0] = pixel[0];
								dest[destIndex + 1] = pixel[1];
								dest[destIndex + 2] = pixel[2];
								dest[destIndex + 3] = pixel[3];
								destIndex += 4;
							}

							shift += 8; // Next RLE is shifted (? Is this correct?)
						}
						else
						{
							// Not an RLE span, just a regular pixel
							// Converting from int to float here!
							dest[destIndex + 0] = pixel[0];
							dest[destIndex + 1] = pixel[1];
							dest[destIndex + 2] = pixel[2];
							dest[destIndex + 3] = pixel[3];
							destIndex += 4; // One more destination pixel down

							shift = 0; // Reset bit shift after RLE
						}
					}
				}

			}

			// Got the data, now to convert it
			// Based on "Real Pixels" by Greg Ward in Graphics Gems II
			//let invExposure = 1 / exposure;
			//for (let i = 0; i < dest.length; i += 4)
			//{
			//	let mul = invExposure * Math.pow(2, dest[i + 3] - 128);// 4th component is exponent

			//	dest[i + 0] = (dest[i + 0] + 0.5) * mul;
			//	dest[i + 1] = (dest[i + 1] + 0.5) * mul;
			//	dest[i + 2] = (dest[i + 2] + 0.5) * mul;
			//	dest[i + 3] = 1;
			//}

			console.log(dest);

			// Finish up
			return dest;

	

	//// Convert data to final IEEE floats
	//// Based on "Real Pixels" by Greg Ward in Graphics Gems II
	//float* pixels = new float[(*width) * (*height) * 4];
	//for (unsigned int i = 0; i < (*width) * (*height); i++)
	//{
	//	unsigned char exponent = data[i * 4 + 3];
	//	if (exponent == 0)
	//	{
	//		pixels[i * 4 + 0] = 0.0f;
	//		pixels[i * 4 + 1] = 0.0f;
	//		pixels[i * 4 + 2] = 0.0f;
	//		pixels[i * 4 + 3] = 1.0f;
	//	}
	//	else
	//	{
	//		float v = ldexp(1.0f / 256.0f, (int)(exponent - 128));
	//		pixels[i * 4 + 0] = (data[i * 4 + 0] + 0.5f) * v;
	//		pixels[i * 4 + 1] = (data[i * 4 + 1] + 0.5f) * v;
	//		pixels[i * 4 + 2] = (data[i * 4 + 2] + 0.5f) * v;
	//		pixels[i * 4 + 3] = 1.0f;
	//	}
	//}

		}


		class Vertex
		{
			Position;
			UV;
			Normal;
			Tangent;

			constructor(pos, uv, norm, tang = new Vector3(0, 0, 0))
			{
				this.Position = pos.slice();
				this.UV = uv.slice();
				this.Normal = norm.slice();
				this.Tangent = tang.slice();
			}

			static GetStride()
			{
				return Float32Array.BYTES_PER_ELEMENT * (3 + 2 + 3 + 3);
			}
		}

		async function loadOBJFile(device, url)
		{
			const resp = await fetch(url);
			const fileText = await resp.text();

			let positions = [];
			let normals = [];
			let uvs = [];
			let vertices = [];
			let indices = [];

			let lines = fileText.split("\n");
			for (let i = 0; i < lines.length; i++)
			{
				// Trim and verify
				lines[i] = lines[i].trim();
				if (lines[i].length == 0)
					continue;

				// Check the type of line
				if (lines[i].charAt(0) == 'v' && lines[i].charAt(1) == 'n')
				{
					// vn x y z
					let normLine = lines[i].split(' ');
					normals.push(new Vector3(
						parseFloat(normLine[1]),
						parseFloat(normLine[2]),
						parseFloat(normLine[3])));
				}
				else if (lines[i].charAt(0) == 'v' && lines[i].charAt(1) == 't')
				{
					// vt u v
					let uvLine = lines[i].split(' ');
					uvs.push(new Vector2(
						parseFloat(uvLine[1]),
						parseFloat(uvLine[2])));
				}
				else if (lines[i].charAt(0) == 'v')
				{
					// v x y z
					let posLine = lines[i].split(' ');
					positions.push(new Vector3(
						parseFloat(posLine[1]),
						parseFloat(posLine[2]),
						parseFloat(posLine[3])));
				}
				else if (lines[i].charAt(0) == 'f')
				{
					// f 1/2/3 1/2/3 1/2/3
					//  - or -
					// f 1/2/3 1/2/3 1/2/3 1/2/3
					let faceLine = lines[i].split(' ');

					// Assume at least 3 verts per face
					for (let f = 1; f <= 3; f++)
					{
						let data = faceLine[f].split('/');
						let p = parseInt(data[0]);
						let u = parseInt(data[1]);
						let n = parseInt(data[2]);

						let vert = new Vertex(
							positions[p - 1],
							uvs[u - 1],
							normals[n - 1]);

						// Convert to left handed
						vert.Position.z *= -1.0; // Invert Z pos
						vert.Normal.z *= -1.0; // Invert Z normal
						vert.UV.y = 1.0 - vert.UV.y; // Flip UV

						// Add to array
						vertices.push(vert);
					}

					// Add indices (0, 2, 1)
					let ind = indices.length;
					indices.push(ind + 0);
					indices.push(ind + 2);
					indices.push(ind + 1);

					// A fourth face? (So 5 total elements after split)
					if (faceLine.length == 5)
					{
						let data = faceLine[4].split('/');
						let p = parseInt(data[0]);
						let u = parseInt(data[1]);
						let n = parseInt(data[2]);

						let vert = new Vertex(
							positions[p - 1],
							uvs[u - 1],
							normals[n - 1]);

						// Convert to left handed
						vert.Position.z *= -1.0; // Invert Z pos
						vert.Normal.z *= -1.0; // Invert Z normal
						vert.UV.y = 1.0 - vert.UV.y; // Flip UV

						// Add to array
						vertices.push(vert);

						// Add another whole face (0, 3, 2)
						indices.push(ind + 0);
						indices.push(ind + 3);
						indices.push(ind + 2);
					}
				}
			}

			// Calculate tangents
			for (let i = 0; i < indices.length;)
			{
				// Grab indices and vertices of first triangle
				let i1 = indices[i++];
				let i2 = indices[i++];
				let i3 = indices[i++];
				let v1 = vertices[i1];
				let v2 = vertices[i2];
				let v3 = vertices[i3];

				// Calculate vectors relative to triangle positions
				let x1 = v2.Position.x - v1.Position.x;
				let y1 = v2.Position.y - v1.Position.y;
				let z1 = v2.Position.z - v1.Position.z;

				let x2 = v3.Position.x - v1.Position.x;
				let y2 = v3.Position.y - v1.Position.y;
				let z2 = v3.Position.z - v1.Position.z;

				// Do the same for vectors relative to triangle uv's
				let s1 = v2.UV.x - v1.UV.x;
				let t1 = v2.UV.y - v1.UV.y;

				let s2 = v3.UV.x - v1.UV.x;
				let t2 = v3.UV.y - v1.UV.y;

				// Create vectors for tangent calculation
				let r = 1.0 / (s1 * t2 - s2 * t1);

				let tx = (t2 * x1 - t1 * x2) * r;
				let ty = (t2 * y1 - t1 * y2) * r;
				let tz = (t2 * z1 - t1 * z2) * r;

				// Adjust tangents of each vert of the triangle
				v1.Tangent.x += tx;
				v1.Tangent.y += ty;
				v1.Tangent.z += tz;

				v2.Tangent.x += tx;
				v2.Tangent.y += ty;
				v2.Tangent.z += tz;

				v3.Tangent.x += tx;
				v3.Tangent.y += ty;
				v3.Tangent.z += tz;
			}

			// Orthonormalize
			for (let i = 0; i < vertices.length; i++)
			{
				let n = vertices[i].Normal;
				let t = vertices[i].Tangent;

				vertices[i].Tangent = Vector3.Normalize(
					Vector3.Subtract(t, Vector3.Multiply(n, Vector3.Dot(n, t)))
				);
			}


			// Copy data to float array
			let floatsPerVert = 3 + 2 + 3 + 3;
			let vbData = new Float32Array(vertices.length * floatsPerVert);
			for (let v = 0; v < vertices.length; v++)
			{
				vbData.set(vertices[v].Position, v * floatsPerVert + 0);
				vbData.set(vertices[v].UV, v * floatsPerVert + 3);
				vbData.set(vertices[v].Normal, v * floatsPerVert + 5);
				vbData.set(vertices[v].Tangent, v * floatsPerVert + 8);
			}

			// Create vertex buffer
			let ibData = new Int16Array(indices);
			let vbDesc = new D3D11_BUFFER_DESC(
				Vertex.GetStride() * vertices.length,
				D3D11_USAGE_IMMUTABLE,
				D3D11_BIND_VERTEX_BUFFER,
				0, 0, 0);
			let vb = device.CreateBuffer(vbDesc, vbData);

			// Create index buffer
			let ibDesc = new D3D11_BUFFER_DESC(
				Int16Array.BYTES_PER_ELEMENT * indices.length,
				D3D11_USAGE_IMMUTABLE,
				D3D11_BIND_INDEX_BUFFER,
				0, 0, 0);
			let ib = device.CreateBuffer(ibDesc, ibData);

			return [vb, ib, indices.length];
		}

		async function loadTexture2D(device, context, url)
		{
			// Fetch and grab the binary data, then turn into an image
			const resp = await fetch(url);
			const imageBlob = await resp.blob();
			const bitmap = await createImageBitmap(imageBlob, { imageOrientation: "flipY" });

			// Set up the texture
			let desc = new D3D11_TEXTURE2D_DESC(
				bitmap.width,
				bitmap.height,
				0, // 0 means full mip chain
				1,
				DXGI_FORMAT_R8G8B8A8_UNORM,
				new DXGI_SAMPLE_DESC(1, 0),
				D3D11_USAGE_DEFAULT,
				D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET,
				0,
				D3D11_RESOURCE_MISC_GENERATE_MIPS);
			let texture = device.CreateTexture2D(desc, [bitmap]);

			let srv = device.CreateShaderResourceView(texture, null);
			context.GenerateMips(srv);

			// Release the texture resource since the view has it
			texture.Release();
			bitmap.close(); // Release the browser resource, too
			return srv;
		}

		async function loadTextureCube(device, context, faceURLs, filesAreLocal)
		{
			let faceTextures = [];
			let size = -1;
			for (let i = 0; i < faceURLs.length; i++)
			{
				// Fetch and grab the binary data, then turn into an image
				const resp = filesAreLocal ? faceURLs[i] : await fetch(faceURLs[i]);
				const imageBlob = filesAreLocal ? resp : await resp.blob();
				const bitmap = await createImageBitmap(imageBlob, { imageOrientation: "flipY" });

				// Set size on first bitmap
				if (size == -1)
					size = bitmap.width;

				// Validate bitmap aspect ratio
				if (bitmap.width != bitmap.height)
				{
					console.log("Error: Texture cube faces must be square");
					return;
				}

				// Validate size matches
				if (size != bitmap.width)
				{
					console.log("Error: Texture cube faces must all be the same size");
				}

				faceTextures.push(bitmap);
			}

			// Set up the texture cube
			let desc = new D3D11_TEXTURE2D_DESC(
				faceTextures[0].width,
				faceTextures[0].height,
				1, // No mips
				6, // 6 faces (as array elements)
				DXGI_FORMAT_R8G8B8A8_UNORM,
				new DXGI_SAMPLE_DESC(1, 0),
				D3D11_USAGE_DEFAULT,
				D3D11_BIND_SHADER_RESOURCE,
				0,
				D3D11_RESOURCE_MISC_TEXTURECUBE);
			let texture = device.CreateTexture2D(desc, faceTextures);

			let srv = device.CreateShaderResourceView(texture, null);

			// Release the texture
			texture.Release();
			return srv;
		}

		async function loadText(url)
		{
			const resp = await fetch(url);
			const text = await resp.text();
			return text;
		}

		function createSolidTexture(device, width, height, initialData)
		{
			let desc = new D3D11_TEXTURE2D_DESC(
				width, height,
				1, // No mips
				1, // No array
				DXGI_FORMAT_R8G8B8A8_UNORM,
				new DXGI_SAMPLE_DESC(1, 0),
				D3D11_USAGE_DEFAULT,
				D3D11_BIND_SHADER_RESOURCE,
				0,
				0);
			let texture = device.CreateTexture2D(desc, [initialData]);

			let srv = device.CreateShaderResourceView(texture, null);

			texture.Release();
			return srv;
		}

		function createBrdfLookUpTable(device, context, size, ps, vs)
		{
			let lutDesc = new D3D11_TEXTURE2D_DESC(
				size,
				size,
				1,
				1,
				DXGI_FORMAT_R8G8B8A8_UNORM, //DXGI_FORMAT_R32G32B32A32_FLOAT <-- No errors, but results are always black!
				new DXGI_SAMPLE_DESC(1, 0),
				D3D11_USAGE_DEFAULT,
				D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET,
				0,
				0);
			let lutTexture = device.CreateTexture2D(lutDesc, null);
			let lutSRV = device.CreateShaderResourceView(lutTexture, null);

			// RTV
			let rtv = device.CreateRenderTargetView(lutTexture, null);
			context.OMSetRenderTargets([rtv], null);

			// Set up viewport
			let oldVP = context.RSGetViewports();
			let vp = new D3D11_VIEWPORT(0, 0, size, size, 0, 1);
			context.RSSetViewports(vp);

			// Draw
			context.PSSetShader(ps);
			context.VSSetShader(vs);
			context.Draw(3, 0);
			context.Flush();

			// Finish up before returning the view
			context.RSSetViewports(oldVP);
			lutTexture.Release();
			rtv.Release();
			return lutSRV;
		}


		function createIrradianceMap(device, context, mapSize, skySRV, sampler, ps, vs)
		{
			// Create an empty texture cube for irradiance
			let cubeDesc = new D3D11_TEXTURE2D_DESC(
				mapSize,
				mapSize,
				1, // No mips
				6, // 6 faces (as array elements)
				DXGI_FORMAT_R8G8B8A8_UNORM,
				new DXGI_SAMPLE_DESC(1, 0),
				D3D11_USAGE_DEFAULT,
				D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET,
				0,
				D3D11_RESOURCE_MISC_TEXTURECUBE);
			let irrTexture = device.CreateTexture2D(cubeDesc, null);
			let irrSRV = device.CreateShaderResourceView(irrTexture, null);

			// Constant buffer for per-face data (index)
			let cbDesc = new D3D11_BUFFER_DESC(
				Float32Array.BYTES_PER_ELEMENT * 4,
				D3D11_USAGE_DYNAMIC,
				D3D11_BIND_CONSTANT_BUFFER,
				D3D11_CPU_ACCESS_WRITE,
				0, 0);
			let cb = device.CreateBuffer(cbDesc, null);
			let cbData = new Float32Array(4);

			// Set up viewport
			let oldVP = context.RSGetViewports();
			let vp = new D3D11_VIEWPORT(0, 0, mapSize, mapSize, 0, 1);
			context.RSSetViewports(vp);

			// Process each face
			context.VSSetShader(vs);
			context.PSSetShader(ps);
			context.PSSetConstantBuffers(0, [cb]);
			context.PSSetShaderResources(0, [skySRV]);
			context.PSSetSamplers(0, [sampler]);
			for (let face = 0; face < 6; face++)
			{
				// RTV for this face
				let faceRTVDesc = new D3D11_RENDER_TARGET_VIEW_DESC(
					DXGI_FORMAT_R8G8B8A8_UNORM,
					D3D11_RTV_DIMENSION_TEXTURE2DARRAY,
					0,
					face,
					1);
				let faceRTV = device.CreateRenderTargetView(irrTexture, faceRTVDesc);

				// Set cb data
				cbData.set([face], 0);
				context.UpdateSubresource(cb, 0, null, cbData, 0, 0);

				// Draw and flush to ensure we're done
				context.OMSetRenderTargets([faceRTV], null);
				context.Draw(3, 0);
				context.Flush();

				faceRTV.Release();
			}

			// Release and clean up
			cb.Release();
			irrTexture.Release();
			context.RSSetViewports(oldVP);
			return irrSRV;
		}

		function createIBLSpecularMap(device, context, mapSize, iblSpecMipsToSkip, skySRV, sampler, ps, vs)
		{
			let usePreviousMipForNextMip = true;

			// How many mips do we need?
			let totalMips = Math.max(Math.log2(mapSize) + 1 - iblSpecMipsToSkip, 1); // Add 1 for 1x1

			// Create an empty texture cube for specular
			let cubeDesc = new D3D11_TEXTURE2D_DESC(
				mapSize,
				mapSize,
				totalMips,
				6, // 6 faces (as array elements)
				DXGI_FORMAT_R8G8B8A8_UNORM,
				new DXGI_SAMPLE_DESC(1, 0),
				D3D11_USAGE_DEFAULT,
				D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET,
				0,
				D3D11_RESOURCE_MISC_TEXTURECUBE);
			let specTexture = device.CreateTexture2D(cubeDesc, null);
			let specSRV = device.CreateShaderResourceView(specTexture, null);

			// Constant buffer for per-face data
			let cbDesc = new D3D11_BUFFER_DESC(
				Float32Array.BYTES_PER_ELEMENT * 4,
				D3D11_USAGE_DYNAMIC,
				D3D11_BIND_CONSTANT_BUFFER,
				D3D11_CPU_ACCESS_WRITE,
				0, 0);
			let cb = device.CreateBuffer(cbDesc, null);
			let cbData = new Float32Array(4);

			// Set up viewport
			let oldVP = context.RSGetViewports();

			// Prepare overall pipeline
			context.VSSetShader(vs);
			context.PSSetShader(ps);
			context.PSSetConstantBuffers(0, [cb]);
			//context.PSSetShaderResources(0, [skySRV]); // Handled below since we may created new SRVs per mip
			context.PSSetSamplers(0, [sampler]);

			let srvForMip = skySRV;

			// Process each mip
			for (let mip = 0; mip < totalMips; mip++)
			{
				// Set the viewport for this mip size
				let mipSize = Math.pow(2, totalMips + iblSpecMipsToSkip - 1 - mip);

				let vp = new D3D11_VIEWPORT(0, 0, mipSize, mipSize, 0, 1);
				context.RSSetViewports(vp);

				// After the first mip, we need to use the previous for sampling
				if (mip > 0 && usePreviousMipForNextMip)
				{
					let mipSRVDesc = new D3D11_SHADER_RESOURCE_VIEW_DESC(
						DXGI_FORMAT_R8G8B8A8_UNORM,
						D3D11_SRV_DIMENSION_TEXTURECUBE,
						mip - 1,
						1,
						0,
						1);
					srvForMip = device.CreateShaderResourceView(specTexture, mipSRVDesc);
				}

				// Process each face
				for (let face = 0; face < 6; face++)
				{
					// RTV for this face
					let faceRTVDesc = new D3D11_RENDER_TARGET_VIEW_DESC(
						DXGI_FORMAT_R8G8B8A8_UNORM,
						D3D11_RTV_DIMENSION_TEXTURE2DARRAY,
						mip,
						face,
						1);
					let faceRTV = device.CreateRenderTargetView(specTexture, faceRTVDesc);

					// Set cb data
					let roughness = mip / Math.max(totalMips - 1.0, 1.0);
					cbData.set([roughness, face, mip], 0);
					context.UpdateSubresource(cb, 0, null, cbData, 0, 0);

					// Set the SRV for this render
					context.PSSetShaderResources(0, [srvForMip]);

					// Draw and flush to ensure we're done
					context.OMSetRenderTargets([faceRTV], null);
					context.Draw(3, 0);
					context.Flush();

					faceRTV.Release();
				}

				// Done with this mip?
				if (mip > 0 && usePreviousMipForNextMip)
				{
					srvForMip.Release();
				}
			}

			// Clean up and done
			cb.Release();
			specTexture.Release();
			context.RSSetViewports(oldVP);
			return specSRV;
		}



		function writeTGAFile(fileName, pixelData, width, height)
		{
			let header = new Uint8Array([
				0, 0, 2, // No ID field, no color map, image type 2
				0, 0, 0, 0, 0, // Color map details (none)
				0, 0, // Image origin X (0) as two bytes
				0, 0, // Image origin Y (0) as two bytes
				Math.floor(width % 256), Math.floor(width / 256), // Image width (two bytes)
				Math.floor(height % 256), Math.floor(height / 256), // Image height (two bytes)
				32, // Bytes per pixel
				0x20
			]);

			let fileBlob = new Blob([header, pixelData], { type: "image/x-targa" });
			let file = window.URL.createObjectURL(fileBlob);

			let aTag = document.createElement("a");
			aTag.setAttribute("download", fileName);
			aTag.href = file;
			aTag.click();
		}


		function writePNGFile(fileName, pixelData, width, height)
		{
			// Create a canvas element with the proper size
			let canvas = document.createElement("canvas");
			let canvasContext = canvas.getContext("2d");
			let imageData = canvasContext.createImageData(width, height);

			// Copy data to the canvas image
			// Need to flip the Y axis!
			let pixelWidth = width * 4;
			for (let y = 0; y < height; y++)
			{
				let flippedY = height - y - 1;
				for (let x = 0; x < width * 4; x++)
				{
					let readIndex = x + y * pixelWidth;
					let writeIndex = x + flippedY * pixelWidth;

					imageData.data[writeIndex] = pixelData[readIndex];
				}
			}

			// Put the data into the canvas
			canvas.width = width;
			canvas.height = height;
			canvasContext.putImageData(imageData, 0, 0);

			let aTag = document.createElement("a");
			aTag.setAttribute("download", fileName);
			aTag.href = canvas.toDataURL("image/png");
			aTag.click();
		}

		// Writes a cube map to a DDS file, following format details here: https://learn.microsoft.com/en-us/windows/win32/direct3ddds/dx-graphics-dds-pguide
		//
		// Starts with "magic number" representing characters 'DDS ', but backwards to match: 0x20534444
		//
		// Header details
		// - dwSize - Always 124
		// - dwFlags
		// - dwHeight
		// - dwWidth
		// - dwPitchOrLinearSize
		// - dwDepth
		// - dwMipMapCount
		// - dwReserved1[11]
		// - ddspf
		// - dwCaps
		// - dwCaps2
		// - dwCaps3
		// - dwCaps4
		// - dwReserved2

		function writeDDSFile(fileName, pixelData, width, height, mipLevels, isCube)
		{
			// Overall Flags
			const DDSD_CAPS = 0x1;
			const DDSD_HEIGHT = 0x2;
			const DDSD_WIDTH = 0x4;
			const DDSD_PITCH = 0x8;
			const DDSD_PIXELFORMAT = 0x1000;
			const DDSD_MIPMAPCOUNT = 0x20000;
			const DDSD_LINEARSIZE = 0x80000;
			const DDSD_DEPTH = 0x800000;

			const DDS_HEADER_FLAGS_TEXTURE =
				DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;

			// Caps flags
			const DDSCAPS_COMPLEX = 0x8; // Has more than once surface: mips, cube, etc.
			const DDSCAPS_MIPMAP = 0x400000;
			const DDSCAPS_TEXTURE = 0x1000;

			// Caps2 flags
			const DDSCAPS2_CUBEMAP = 0x200
			const DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;
			const DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;
			const DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;
			const DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;
			const DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;
			const DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;
			const DDSCAPS2_VOLUME = 0x200000;

			const DDS_CUBEMAP_ALLFACES =
				DDSCAPS2_CUBEMAP |
				DDSCAPS2_CUBEMAP_POSITIVEX |
				DDSCAPS2_CUBEMAP_NEGATIVEX |
				DDSCAPS2_CUBEMAP_POSITIVEY |
				DDSCAPS2_CUBEMAP_NEGATIVEY |
				DDSCAPS2_CUBEMAP_POSITIVEZ |
				DDSCAPS2_CUBEMAP_NEGATIVEZ;

			// Pixel format flags
			const DDPF_ALPHAPIXELS = 0x1;
			const DDPF_ALPHA = 0x2;
			const DDPF_FOURCC = 0x4; // Used when DXT10 header is needed, set FourCC to 'DX10' (backwards?)
			const DDPF_RGB = 0x40;
			const DDPF_YUV = 0x200;
			const DDPF_LUMINANCE = 0x20000;


			// Flags for header
			let flags = DDS_HEADER_FLAGS_TEXTURE | DDSD_PITCH | (mipLevels > 1 ? DDSD_MIPMAPCOUNT : 0);
			let caps =
				DDSCAPS_TEXTURE |
				(mipLevels > 1 || isCube ? DDSCAPS_COMPLEX : 0) |
				(mipLevels > 1 ? DDSCAPS_MIPMAP : 0);
			let caps2 = isCube ? DDS_CUBEMAP_ALLFACES : 0;
			let pixelFormatFlags = DDPF_RGB | DDPF_ALPHAPIXELS;

			// Calculations for header
			let bitsPerPixel = 32;
			let pitch = Math.trunc((width * bitsPerPixel + 7) / 8);
			// Pitch formula here: https://learn.microsoft.com/en-us/windows/win32/direct3ddds/dx-graphics-dds-pguide

			let header = new Uint32Array([
				0x20534444, // Magic number for 'DDS '
				// ------------
				124, // Header size, always 124
				flags,
				width, // Width
				height, // Height
				pitch,
				1, // Depth (Unused for non-volume textures - maybe just set to zero?)
				mipLevels,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 11x unused (reserved) entries
								// Pixel format ----
								/* dwSize        */ 32, // Always 32
								/* dwFlags       */ pixelFormatFlags,
								/* dwFourCC      */ 0,
								/* dwRGBBitCount */ bitsPerPixel, // Includes alpha!
								/* dwRBitMask    */ 0x000000ff, // Yes these feel "backwards" but are correct
								/* dwGBitMask    */ 0x0000ff00,
								/* dwBBitMask    */ 0x00ff0000,
								/* dwABitMask    */ 0xff000000,
				// End pixel format ---
				caps,
				caps2,
				0, 0, 0 // Caps3, caps4 & reserved2
			]);

			let fileBlob = new Blob([header, pixelData], { type: "image/vnd-ms.dds" });
			let file = window.URL.createObjectURL(fileBlob);

			let aTag = document.createElement("a");
			aTag.setAttribute("download", fileName);
			aTag.href = file;
			aTag.click();
		}



		let globalDevice = null;
		let globalContext = null;

		async function main()
		{
			let postprocessing = false;

			let input = new Input(document);

			// Some quick vars
			let float32Size = Float32Array.BYTES_PER_ELEMENT;

			// Init the API
			let device = D3D11CreateDevice(document.querySelector("#viewport"));
			let context = device.GetImmediateContext();

			globalDevice = device;
			globalContext = context;

			let gl = device.GetAdapter();
			gl.canvas.width = gl.canvas.clientWidth;
			gl.canvas.height = gl.canvas.clientHeight;

			let swapDesc = new DXGI_SWAP_CHAIN_DESC(
				gl.canvas.clientWidth,
				gl.canvas.clientHeight,
				DXGI_FORMAT_R8G8B8A8_UNORM);

			let swapChain = DXGICreateSwapChain(device, swapDesc);


			// Set up initial viewport
			let viewport = new D3D11_VIEWPORT(0, 0, gl.canvas.clientWidth, gl.canvas.clientHeight, 0, 1);
			context.RSSetViewports(viewport);

			// Make an RTV of the back buffer
			let backBuffer = swapChain.GetBuffer();
			let rtv = device.CreateRenderTargetView(backBuffer, null);
			backBuffer.Release();

			// Create a depth buffer
			let depthDesc = new D3D11_TEXTURE2D_DESC(
				gl.canvas.clientWidth,
				gl.canvas.clientHeight,
				1,
				1,
				DXGI_FORMAT_D24_UNORM_S8_UINT,
				new DXGI_SAMPLE_DESC(1, 0),
				D3D11_USAGE_DEFAULT,
				D3D11_BIND_DEPTH_STENCIL,
				0,
				0);
			let depthBuffer = device.CreateTexture2D(depthDesc, null);

			// Default DSV
			let depthDSV = device.CreateDepthStencilView(depthBuffer, null);
			depthBuffer.Release();

			// Set the targets
			context.OMSetRenderTargets([rtv], depthDSV);

			// Attempt to load an image
			let albedoSRV = await loadTexture2D(device, context, "../assets/textures/cobblestone_albedo.png");
			let normalSRV = await loadTexture2D(device, context, "../assets/textures/cobblestone_normals.png");
			let metalSRV = await loadTexture2D(device, context, "../assets/textures/cobblestone_metal.png");
			let roughSRV = await loadTexture2D(device, context, "../assets/textures/cobblestone_roughness.png");
			context.PSSetShaderResources(0, [albedoSRV, normalSRV, metalSRV, roughSRV]);

			// Create several solid textures
			let blackSRV = createSolidTexture(device, 2, 2, new Uint8Array([
				0, 0, 0, 255,
				0, 0, 0, 255,
				0, 0, 0, 255,
				0, 0, 0, 255]));

			let whiteSRV = createSolidTexture(device, 2, 2, new Uint8Array([
				255, 255, 255, 255,
				255, 255, 255, 255,
				255, 255, 255, 255,
				255, 255, 255, 255]));

			let flatNormalsSRV = createSolidTexture(device, 2, 2, new Uint8Array([
				127, 127, 255, 255,
				127, 127, 255, 255,
				127, 127, 255, 255,
				127, 127, 255, 255]));

			// Array of greyscale roughness textures
			let solidRoughSRVs = [];
			for (let i = 0; i < 11; i++)
			{
				let r = Math.floor((i / 10.0) * 255);
				let srv = createSolidTexture(device, 2, 2, new Uint8Array([
					r, r, r, 255,
					r, r, r, 255,
					r, r, r, 255,
					r, r, r, 255]));
				solidRoughSRVs.push(srv);
			}

			// Load a cube map
			let skySRV = await loadTextureCube(
				device,
				context,
				[
					"../assets/skies/cloudsblue/right.png",
					"../assets/skies/cloudsblue/left.png",
					"../assets/skies/cloudsblue/up.png",
					"../assets/skies/cloudsblue/down.png",
					"../assets/skies/cloudsblue/front.png",
					"../assets/skies/cloudsblue/back.png"
				],
				false
			);
			globalSkySRV = skySRV;
			context.PSSetShaderResources(4, [skySRV]);

			// Create/release test
			let crateSRV = await loadTexture2D(device, context, "../assets/textures/crate.png");
			crateSRV.Release();


			// Create a sampler
			let sampDesc = new D3D11_SAMPLER_DESC(
				D3D11_FILTER_ANISOTROPIC,
				D3D11_TEXTURE_ADDRESS_WRAP,
				D3D11_TEXTURE_ADDRESS_WRAP,
				D3D11_TEXTURE_ADDRESS_WRAP,
				0,
				16,
				0,
				0,
				0,
				D3D11_FLOAT32_MAX);
			let sampler = device.CreateSamplerState(sampDesc);

			// Make a clamp sampler, too
			sampDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
			sampDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
			sampDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
			let clampSampler = device.CreateSamplerState(sampDesc);

			context.PSSetSamplers(0, [sampler, clampSampler]);


			// Create a rasterizer state for the sky
			let skyRastDesc = new D3D11_RASTERIZER_DESC(
				D3D11_FILL_SOLID,
				D3D11_CULL_FRONT);
			let skyRastState = device.CreateRasterizerState(skyRastDesc);

			// Create a depth/stencil state for the sky
			let skyDepthDesc = new D3D11_DEPTH_STENCIL_DESC(
				true,
				D3D11_DEPTH_WRITE_MASK_ALL,
				D3D11_COMPARISON_LESS_EQUAL);
			let skyDepthState = device.CreateDepthStencilState(skyDepthDesc);

			// Common for all verts
			let vbStride = Vertex.GetStride();
			let vbOffset = 0;

			// Load an .obj file and set buffers
			let helixBuffs = await loadOBJFile(device, "../assets/meshes/helix.obj");
			let helixVB = helixBuffs[0];
			let helixIB = helixBuffs[1];
			let helixIndexCount = helixBuffs[2];

			let sphereBuffs = await loadOBJFile(device, "../assets/meshes/sphere.obj");
			let sphereVB = sphereBuffs[0];
			let sphereIB = sphereBuffs[1];
			let sphereIndexCount = sphereBuffs[2];

			let cubeBuffs = await loadOBJFile(device, "../assets/meshes/cube.obj");
			let cubeVB = cubeBuffs[0];
			let cubeIB = cubeBuffs[1];
			let cubeIndexCount = cubeBuffs[2];

			// Create constant buffer
			let elementCount = 16 * 3; // 3 matrices
			let vsCBDesc = new D3D11_BUFFER_DESC(
				elementCount * Float32Array.BYTES_PER_ELEMENT,
				D3D11_USAGE_DYNAMIC,
				D3D11_BIND_CONSTANT_BUFFER,
				D3D11_CPU_ACCESS_WRITE,
				0, 0);
			let vsCB = device.CreateBuffer(vsCBDesc, null);


			let aspectRatio = gl.canvas.clientWidth / gl.canvas.clientHeight;

			// Camera
			let cameraPosition = new Vector3(0, 0, -10);
			let cameraRotation = new Vector2(0, 0);
			let camDir = new Vector3(0, 0, 1);

			// Set up the initial VS CB data
			let wMat = Matrix4x4.RotationY(0);
			let vMat = Matrix4x4.ViewDirectionLH(cameraPosition, camDir, Vector3.UnitY);
			let pMat = Matrix4x4.PerspectiveFovLH(Math.PI / 4.0, aspectRatio, 0.01, 100);

			let vsData = new Float32Array(elementCount);
			vsData.set(wMat, 0);
			vsData.set(vMat, 16);
			vsData.set(pMat, 32);
			context.UpdateSubresource(vsCB, 0, null, vsData, 0, 0);

			// Cbuffer for pixel shader
			let lightCount = 8 + 3; // 8 point, 3 dir
			let lightSizeInFloats = 16;
			let elementsBeforeLights = 12; // 3 vectors worth
			let psElementCount = elementsBeforeLights + lightSizeInFloats * lightCount; // Two vectors, plus one for IBL, and N lights
			let psCBDesc = new D3D11_BUFFER_DESC(
				psElementCount * Float32Array.BYTES_PER_ELEMENT,
				D3D11_USAGE_DYNAMIC,
				D3D11_BIND_CONSTANT_BUFFER,
				D3D11_CPU_ACCESS_WRITE,
				0, 0);
			let psCB = device.CreateBuffer(psCBDesc, null);

			// Set up initial PS CB data
			let lightColors = [];
			for (let i = 0; i < 8; i++)
			{
				// Pick one to be bright
				let bright = Math.random() * 3;
				let r = bright < 1 ? 1 : Math.random();
				let g = bright >= 1 && bright < 2 ? 1 : Math.random();
				let b = bright >= 2 ? 1 : Math.random();
				lightColors.push([r, g, b]);
			}
			let psData = new Float32Array(psElementCount);
			psData.set(cameraPosition, 0); // Camera pos
			psData.set([1, 1, 1], 4); // Tint
			psData.set([lightCount], 9); // Light count
			for (let i = 0; i < 8; i++)
			{
				psData.set(
					[
						1, // type - 0:dir, 1:point
						1, // intensity
						6, // range
						0, // Pad
						Math.random() * 10 - 5, Math.random() * 10 - 5, Math.random() * 10 - 5, 0, // pos + pad
						0, 0, 0, 0, // direction + pad
						lightColors[i][0], lightColors[i][1], lightColors[i][2], 0 //color + pad
					],
					elementsBeforeLights + i * 16);
			}

			// Add the three dir lights after point lights
			let dirs = [];
			dirs.push([1, -1, 1]);
			dirs.push([-1, 0, 0]);
			dirs.push([0, 1, -0.5]);
			for (let i = 8; i < 11; i++)
			{
				psData.set(
					[
						0, // type - 0:dir, 1:point
						Math.random() * 0.5 + 0.5, // intensity
						0, // range
						0, // Pad
						0, 0, 0, 0, // pos + pad
						dirs[i - 8][0], dirs[i - 8][1], dirs[i - 8][2], 0, // direction + pad
						1, 1, 1, 0 //color + pad
					],
					elementsBeforeLights + i * 16);
			}


			// Cbuffer for solid color
			let solidCBDesc = new D3D11_BUFFER_DESC(
				4 * Float32Array.BYTES_PER_ELEMENT,
				D3D11_USAGE_DYNAMIC,
				D3D11_BIND_CONSTANT_BUFFER,
				D3D11_CPU_ACCESS_WRITE,
				0, 0);
			let solidCB = device.CreateBuffer(solidCBDesc, null);
			let solidData = new Float32Array(4);
			solidData.set([1, 1, 1], 0);
			context.UpdateSubresource(solidCB, 0, null, solidData, 0, 0);
			context.UpdateSubresource(psCB, 0, null, psData, 0, 0);

			// Set constant buffers
			context.VSSetConstantBuffers(0, [vsCB]);
			context.PSSetConstantBuffers(0, [psCB]);

			// Create an input layout
			let inputElements = [];
			inputElements[0] = new D3D11_INPUT_ELEMENT_DESC("POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0);
			inputElements[1] = new D3D11_INPUT_ELEMENT_DESC("TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 3 * float32Size, D3D11_INPUT_PER_VERTEX_DATA, 0);
			inputElements[2] = new D3D11_INPUT_ELEMENT_DESC("NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 5 * float32Size, D3D11_INPUT_PER_VERTEX_DATA, 0);
			inputElements[3] = new D3D11_INPUT_ELEMENT_DESC("TANGENT", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 8 * float32Size, D3D11_INPUT_PER_VERTEX_DATA, 0);
			let inputLayout = device.CreateInputLayout(inputElements);
			context.IASetInputLayout(inputLayout);

			// Create shaders
			let vs = device.CreateVertexShader(await loadText("../assets/shaders/PBR_VS.hlsl"));
			let ps = device.CreatePixelShader(await loadText("../assets/shaders/PBR_PS.hlsl"));
			let solidPS = device.CreatePixelShader(await loadText("../assets/shaders/SolidColorPS.hlsl"));
			let skyVS = device.CreateVertexShader(await loadText("../assets/shaders/SkyVS.hlsl"));
			let skyPS = device.CreatePixelShader(await loadText("../assets/shaders/SkyPS.hlsl"));
			let postprocPS = device.CreatePixelShader(await loadText("../assets/shaders/BlurPS.hlsl"));
			let fullscreenVS = device.CreateVertexShader(await loadText("../assets/shaders/FullscreenVS.hlsl"));

			// Shaders for IBL
			let brdfLutPS = device.CreatePixelShader(await loadText("../assets/shaders/IBLBrdfLookUpTablePS.hlsl"));
			let iblIrradiancePS = device.CreatePixelShader(await loadText("../assets/shaders/IBLIrradianceMapPS.hlsl"));
			let iblSpecularPS = device.CreatePixelShader(await loadText("../assets/shaders/IBLSpecularConvolutionPS.hlsl"));

			// Create IBL textures
			let iblSpecSize = 256;
			let iblSpecMipsToSkip = 3;
			let iblTotalMips = Math.max(Math.log2(iblSpecSize) + 1 - iblSpecMipsToSkip, 1);

			psData.set([iblTotalMips], 8);

			let lutSRV = createBrdfLookUpTable(device, context, 1024, brdfLutPS, fullscreenVS);
			let irrSRV = createIrradianceMap(device, context, 256, skySRV, sampler, iblIrradiancePS, fullscreenVS);
			let iblSpecSRV = createIBLSpecularMap(device, context, iblSpecSize, iblSpecMipsToSkip, skySRV, sampler, iblSpecularPS, fullscreenVS);
			globalIrrSRV = irrSRV;
			globalIBLSpecSRV = iblSpecSRV;

			// Save other globals for skybox load (TEMP)
			globalIBLSampler = sampler;
			globalIrrPS = iblIrradiancePS;
			globalIBLSpecPS = iblSpecularPS;
			globalFullscreenVS = fullscreenVS;

			// Create a texture for copy subresource testing
			//let copyTexDesc = new D3D11_TEXTURE2D_DESC(256, 256, 1, 1, DXGI_FORMAT_R8G8B8A8_UNORM, new DXGI_SAMPLE_DESC(1, 0), D3D11_USAGE_DEFAULT, D3D11_BIND_SHADER_RESOURCE, 0, 0);
			//let copyTexture = device.CreateTexture2D(copyTexDesc, null);
			//
			//let lutResource = lutSRV.GetResource();
			//context.CopySubresourceRegion(
			//	copyTexture,
			//	0,
			//	0, 0, 0,
			//	lutResource,
			//	0,
			//	new D3D11_BOX(0, 0, 256, 128));
			//lutResource.Release();
			//let copySRV = device.CreateShaderResourceView(copyTexture, null);

			// Create a texture for full resource copy testing
			let iblSpecRes = iblSpecSRV.GetResource();
			let iblSpecDesc = iblSpecRes.GetDesc();
			iblSpecDesc.BindFlags = 0;
			iblSpecDesc.Usage = D3D11_USAGE_STAGING;
			iblSpecDesc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
			let iblSpecCopyTexture = device.CreateTexture2D(iblSpecDesc, null);

			// Perform the copy and make a new SRV
			context.CopyResource(iblSpecCopyTexture, iblSpecRes);
			iblSpecRes.Release(); // Cleanup

			// Perform a readback of the data in one subresource
			//let w = iblSpecDesc.Width;
			//let h = iblSpecDesc.Height;
			//let readbackData = new Uint8Array(w * h * 4);
			//device.ReadFromSubresource(readbackData, iblSpecCopyTexture, 0, null);

			//writeTGAFile("test.tga", readbackData, w, h);
			//writePNGFile("test.png", readbackData, w, h);

			// DDS TEST --------------
			let ddsTest = false;
			if (ddsTest)
			{
				// Readback the entire resource into an array of Uint8Arrays
				let w = iblSpecDesc.Width;
				let h = iblSpecDesc.Height;
				let mipLevels = iblSpecDesc.MipLevels;

				// First, calculate the full size of the array
				let totalSize = w * h * 4 * 6; // X * Y * 4 pixels * 6 faces
				let mipSize = w;
				for (let mip = 1; mip < mipLevels; mip++)
				{
					// Calc mip size - ASSUMING SQUARE since cube map!
					mipSize = Math.max(Math.floor(mipSize / 2), 1);

					// Add this mip to the overall size
					totalSize += mipSize * mipSize * 4 * 6;
				}

				// Create an array big enough to hold all subresources
				let readbackData = new Uint8Array(totalSize);
				let dataOffset = 0;
				for (let face = 0; face < 6; face++)
				{
					// Mip size starts as the main texture size
					mipSize = w;
					for (let mip = 0; mip < mipLevels; mip++)
					{
						// Data for just this subresource
						let subResIndex = D3D11CalcSubresource(mip, face, mipLevels);
						let subResDataSize = mipSize * mipSize * 4;
						let subResData = new Uint8Array(subResDataSize);

						// Perform the read and copy to the overall array
						device.ReadFromSubresource(subResData, iblSpecCopyTexture, subResIndex, null);

						// Flip the data on Y by looping through top half and swapping
						let rowWidth = mipSize * 4;
						for (let y = 0; y < mipSize / 2; y++)
						{
							let flippedY = mipSize - y - 1;
							for (let x = 0; x < rowWidth; x++)
							{
								let top = x + y * rowWidth;
								let bot = x + flippedY * rowWidth;

								let bottomPixel = subResData[bot];
								subResData[bot] = subResData[top];
								subResData[top] = bottomPixel;
							}
						}

						// Add to the overall data
						readbackData.set(subResData, dataOffset);

						// Adjust data offset
						dataOffset += subResDataSize;

						// Update the mip size
						mipSize = Math.max(Math.floor(mipSize / 2), 1);
					}
				}

				writeDDSFile("test.dds", readbackData, w, h, mipLevels, true);
			}

			// Reset the render target
			context.OMSetRenderTargets([rtv], depthDSV);

			context.VSSetShader(vs);
			context.PSSetShader(ps);

			// Post process resources
			let ppTexDesc = new D3D11_TEXTURE2D_DESC(
				gl.canvas.width,
				gl.canvas.height,
				1,
				1,
				DXGI_FORMAT_R8G8B8A8_UNORM,
				new DXGI_SAMPLE_DESC(1, 0),
				D3D11_USAGE_DEFAULT,
				D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE,
				0,
				0);
			let ppTexture = device.CreateTexture2D(ppTexDesc, [null]);
			let ppSRV = device.CreateShaderResourceView(ppTexture, null);
			let ppRTV = device.CreateRenderTargetView(ppTexture, null);
			ppTexture.Release();

			// Ensure we're set for triangles
			context.IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);


			// Perform a readback
			// Need to actually copy to a staging resource!
			//let readback = new Uint8Array(256*256*4);
			//let lutResource = lutSRV.GetResource();
			//device.ReadFromSubresource(readback, lutResource, 0, null);
			//lutResource.Release();
			//
			//console.log(readback);

			function update(time)
			{
				// Update
				let speed = 0.2;
				if (input.IsKeyDown(Keys.Shift)) speed *= 5;
				if (input.IsKeyDown(Keys.Ctrl)) speed *= 0.25;

				let cameraMoveRelative = new Vector3();
				let cameraMoveAbsolute = new Vector3();
				let anyMove = false;
				if (input.IsKeyDown(Keys.A)) { anyMove = true; cameraMoveRelative.x -= speed; }
				if (input.IsKeyDown(Keys.D)) { anyMove = true; cameraMoveRelative.x += speed; }
				if (input.IsKeyDown(Keys.W)) { anyMove = true; cameraMoveRelative.z += speed; }
				if (input.IsKeyDown(Keys.S)) { anyMove = true; cameraMoveRelative.z -= speed; }
				if (input.IsKeyDown(Keys.Space)) { anyMove = true; cameraMoveAbsolute.y += speed; }
				if (input.IsKeyDown(Keys.X)) { anyMove = true; cameraMoveAbsolute.y -= speed; }

				if (input.IsMouseDown(MouseButtons.Left))
				{
					cameraRotation.x += input.GetMouseDeltaY() * 0.001;
					cameraRotation.y += input.GetMouseDeltaX() * 0.001;

					camDir.x = Math.sin(cameraRotation.y);
					camDir.z = Math.cos(cameraRotation.y);

					camDir.y = -Math.sin(cameraRotation.x);
				}

				if (anyMove)
				{
					// Relative movement based on rotation
					let moveRelative = Vector3.Rotate(cameraMoveRelative, cameraRotation.x, cameraRotation.y, 0);
					cameraPosition = Vector3.Add(cameraPosition, moveRelative);

					// Absolute movement
					cameraPosition = Vector3.Add(cameraPosition, cameraMoveAbsolute);
				}
			}

			function checkForResize()
			{
				// Has the window changed size?
				if (gl.canvas.width != gl.canvas.clientWidth ||
					gl.canvas.height != gl.canvas.clientHeight)
				{
					// Need to resize, so first release all references
					rtv.Release(); // Back buffer
					depthDSV.Release(); // Depth buffer

					// Ask the swap chain to resize and update the canvas
					gl.canvas.width = gl.canvas.clientWidth;
					gl.canvas.height = gl.canvas.clientHeight;
					swapChain.ResizeBuffers(gl.canvas.clientWidth, gl.canvas.clientHeight);

					// Make new RTV
					let bb = swapChain.GetBuffer();
					rtv = device.CreateRenderTargetView(bb, null);
					bb.Release();

					// Make new depth buffer
					let depthDesc = new D3D11_TEXTURE2D_DESC(
						gl.canvas.clientWidth,
						gl.canvas.clientHeight,
						1,
						1,
						DXGI_FORMAT_D24_UNORM_S8_UINT,
						new DXGI_SAMPLE_DESC(1, 0),
						D3D11_USAGE_DEFAULT,
						D3D11_BIND_DEPTH_STENCIL,
						0,
						0);
					let depthBuffer = device.CreateTexture2D(depthDesc, null);

					// Default DSV
					depthDSV = device.CreateDepthStencilView(depthBuffer, null);
					depthBuffer.Release();

					// Set the new views
					context.OMSetRenderTargets([rtv], depthDSV);

					// Update aspect ratio and camera
					aspectRatio = gl.canvas.clientWidth / gl.canvas.clientHeight;
					pMat = Matrix4x4.PerspectiveFovLH(Math.PI / 4.0, aspectRatio, 0.01, 100);
					vsData.set(pMat, 32);

					// Update  viewport, too
					viewport.Width = gl.canvas.clientWidth;
					viewport.Height = gl.canvas.clientHeight;
					context.RSSetViewports(viewport);
				}
			}


			function draw(time)
			{
				checkForResize();

				// Set up post processing
				if (postprocessing)
				{
					context.OMSetRenderTargets([ppRTV], depthDSV);
				}


				vMat = Matrix4x4.ViewDirectionLH(
					cameraPosition,
					camDir, //new Vector3(0, 0, 1),
					Vector3.UnitY);

				vsData.set(vMat, 16);

				// Clear the frame
				let black = [0, 0, 0, 1];
				let cornflowerBlue = [0.39, 0.58, 0.93, 1];
				context.ClearRenderTargetView(rtv, black);
				context.ClearDepthStencilView(depthDSV, D3D11_CLEAR_DEPTH, 1.0, 0);

				// Sphere draws
				{
					// Swap to sphere buffers
					context.VSSetShader(vs);
					context.PSSetShader(solidPS);
					context.PSSetConstantBuffers(0, [solidCB]);
					context.IASetVertexBuffers(0, [sphereVB], [vbStride], [vbOffset]);
					context.IASetIndexBuffer(sphereIB, DXGI_FORMAT_R16_UINT, 0);

					for (let i = 0; i < 8; i++)
					{
						let offset = (i / 4) * Math.PI * 2;
						let s = Math.sin(time * 0.0005 + offset);
						let c = Math.cos(time * 0.0005 + offset);

						let lightPos = [3 * s, i < 4 ? -3 : 3, 3 * c];

						wMat = Matrix4x4.Translation(lightPos[0], lightPos[1], lightPos[2]);
						vsData.set(wMat, 0);
						context.UpdateSubresource(vsCB, 0, null, vsData, 0, 0);

						// Update PS data for later (12 initial, 16 per light, 4 floats deep)
						psData.set(lightPos, elementsBeforeLights + i * 16 + 4);

						// Update data for this draw
						solidData.set(lightColors[i], 0);
						context.UpdateSubresource(solidCB, 0, null, solidData, 0, 0);

						// Draw sphere
						context.DrawIndexed(sphereIndexCount, 0, 0);
					}
				}

				// Pipeline for next several draws
				context.VSSetShader(vs);
				context.PSSetShader(ps);
				context.PSSetConstantBuffers(0, [psCB]);

				// Main shape draw
				{
					//let scale = 3;
					//let vb = helixVB;
					//let ib = helixIB;
					//let count = helixIndexCount;

					let scale = 7;
					let vb = sphereVB;
					let ib = sphereIB;
					let count = sphereIndexCount;

					//let scale = 4.5;
					//let vb = cubeVB;
					//let ib = cubeIB;
					//let count = cubeIndexCount;

					// Update vertex data
					let rot = new Matrix4x4();
					Matrix4x4.FillIdentity(rot);//Matrix4x4.RotationY(time * -0.00025);

					let sc = Matrix4x4.ScaleUniform(scale);
					wMat = Matrix4x4.Multiply(sc, rot);
					vsData.set(wMat, 0);
					context.UpdateSubresource(vsCB, 0, null, vsData, 0, 0);

					// Update pixel data (set above while lights are moving)
					psData.set(cameraPosition, 0);
					psData.set([lightCount], 9);  // Set light count (all lights)
					context.UpdateSubresource(psCB, 0, null, psData, 0, 0);

					// Textures
					context.PSSetShaderResources(0, [albedoSRV, normalSRV, metalSRV, roughSRV, lutSRV, globalIrrSRV, globalIBLSpecSRV]);

					// Draw
					context.IASetVertexBuffers(0, [vb], [vbStride], [vbOffset]);
					context.IASetIndexBuffer(ib, DXGI_FORMAT_R16_UINT, 0);
					context.DrawIndexed(count, 0, 0);
				}

				// Roughness spheres
				{
					let scale = 2;
					let y = 7;
					let spacing = 2;
					let sc = Matrix4x4.ScaleUniform(scale);
					let tr = Matrix4x4.Identity();

					// Turn off lights
					psData.set([0], 9); // Zero light count
					context.UpdateSubresource(psCB, 0, null, psData, 0, 0);

					// Set up the overall pipeline for spheres
					context.IASetVertexBuffers(0, [sphereVB], [vbStride], [vbOffset]);
					context.IASetIndexBuffer(sphereIB, DXGI_FORMAT_R16_UINT, 0);

					for (let row = 0; row < 2; row++)
					{
						for (let i = 0; i < 11; i++)
						{
							// Per object data
							Matrix4x4.FillTranslation(tr, (i - 5) * spacing, y + row * spacing, 0);
							wMat = Matrix4x4.Multiply(tr, sc);
							vsData.set(wMat, 0);
							context.UpdateSubresource(vsCB, 0, null, vsData, 0, 0);

							// Set textures for this sphere
							context.PSSetShaderResources(0, [whiteSRV, flatNormalsSRV, row == 0 ? blackSRV : whiteSRV, solidRoughSRVs[i], lutSRV, globalIrrSRV, globalIBLSpecSRV]);

							// Draw one sphere
							context.DrawIndexed(sphereIndexCount, 0, 0);
						}
					}
				}

				// Skybox
				{
					// Set up states
					context.RSSetState(skyRastState);
					context.OMSetDepthStencilState(skyDepthState);

					// Set up shaders
					context.VSSetShader(skyVS);
					context.PSSetShader(skyPS);

					// NOTE: Current cbuffers should be fine?
					// VS -> Using same w/v/p
					// PS -> Nothing necessary

					// Set up texture
					context.PSSetShaderResources(0, [globalSkySRV]); //[skySRV]); XXXXXXXXXXXXXXXXX

					// Draw cube
					context.IASetVertexBuffers(0, [cubeVB], [vbStride], [vbOffset]);
					context.IASetIndexBuffer(cubeIB, DXGI_FORMAT_R16_UINT, 0);
					context.DrawIndexed(cubeIndexCount, 0, 0);

					// Revert states
					context.RSSetState(null);
					context.OMSetDepthStencilState(null);
				}

				if (postprocessing)
				{
					// Finish post processing
					context.OMSetRenderTargets([rtv], null);
					context.VSSetShader(fullscreenVS);
					context.PSSetShader(postprocPS);
					context.PSSetShaderResources(0, [ppSRV]);
					context.Draw(3, 0);
				}

				// Flush the frame
				swapChain.Present();

				context.OMSetRenderTargets([rtv], depthDSV);
			}

			function frameloop(time)
			{
				update(time);
				draw(time);

				// End of frame work
				window.requestAnimationFrame(frameloop);
				input.EndOfFrame();
			}

			window.requestAnimationFrame(frameloop);

		}


		main();
	</script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
</body>
</html>

