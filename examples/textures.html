<!DOCTYPE html>
<html class="h-100" data-bs-theme="dark">
<head>
	<script src="../build/d3d11.js"></script>

	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
	<style>

		.fixed-size-custom {
			width: 250px !important;
		}

		.canvas-container {
			position: relative;
		}

		.canvas-fill-parent {
			width: 100%;
			height: 100%;
			max-height: 100vh;
			outline: none;
		}

		.over-canvas {
			position: absolute;
			top: 0px;
			left: 0px;
			z-index: 2;
			margin: 0 auto;
		}
	</style>
</head>
<body class="h-100 m-0 p-0">

	<!-- Trying out bootstrap -->
	<!-- Main "container", but skipping actual .container class to ensure edge-to-edge page! -->
	<div class="row h-100 m-0 p-0 overflow-hidden">

		<!-- Left "sidebar", scrollable-->
		<div class="col-3 h-100 overflow-y-auto">

			<!-- Overall title-->
			<h1>Cube Maps</h1>

			<!-- Testing accordian navigation -->
			<div class="accordion" id="main-nav">

				<!-- SCENE -->
				<div class="accordion-item">
					<h2 class="accordion-header">
						<button class="accordion-button collapsed p-2" type="button" data-bs-toggle="collapse" data-bs-target="#scene-accordion" aria-expanded="false" aria-controls="flush-collapseOne">
							<h5 class="m-0">&#127758; Scene</h5>
						</button>
					</h2>
					<div id="scene-accordion" class="accordion-collapse collapse">
						<div class="accordion-body p-3">

							<h6>&#127760; Model</h6>

							<!-- MODEL -->
							<div class="input-group input-group-sm mb-3">
								<!--<label for="sceneSet" class="input-group-text">&#127760; Model</label>-->
								<select id="sceneSet" class="form-select" onchange="setScene(this.value);">
									<option value="0" selected>Sphere</option>
									<option value="1">Helix</option>
									<option value="2">Cube</option>
									<option value="3">Roughness Grid</option>
									<option value="4">RGB Grid</option>
								</select>
							</div>

							<!-- MATERIAL -->
							<div id="material">
								<h6>&#127912; Material</h6>

								<!-- TEXTURES -->
								<div class="input-group input-group-sm row ms-0">
									<label for="textureSet" class="col input-group-text">Texture Set</label>
									<select id="textureSet" class="col form-select px-3" onchange="setTextureSet(this.value);">
										<option value="0">None (Custom Values)</option>
										<option value="1" selected>Cobblestone</option>
										<option value="2">Bronze</option>
										<option value="3">Metal Flooring</option>
										<option value="4">Scratched Paint</option>
									</select>
								</div>

								<!-- COLOR PICKER -->
								<div class="input-group input-group-sm row ms-0">
									<label for="material-color" class="col input-group-text">Color Tint</label>
									<input id="material-color" type="color" class="col form-control form-control-color px-3" value="#ffffff" title="Color Tint" onchange="" />
								</div>

								<!-- ROUGHNESS -->
								<div class="input-group input-group-sm row ms-0">
									<label for="material-roughness" class="col input-group-text">Roughness: 0.5</label>
									<input id="material-roughness" type="range" class="col form-control form-range p-3" min="0" max="1" step="0.01" value="0.5" oninput="setMatRoughness(this.value); this.previousElementSibling.innerHTML = 'Roughness: ' + this.value;" />
								</div>

								<!-- METALNESS -->
								<div class="row input-group input-group-sm ms-0">
									<label for="material-metalness" class="col input-group-text">Metalness: 0</label>
									<input id="material-metalness" type="range" class="col form-control form-range p-3" min="0" max="1" step="0.01" value="0" oninput="setMatMetalness(this.value); this.previousElementSibling.innerHTML = 'Metalness: ' + this.value;" />
								</div>
							</div>

						</div>
					</div>
				</div>

				<!-- ENVIRONMENT -->
				<div class="accordion-item">
					<h2 class="accordion-header">
						<button class="accordion-button p-2 collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#environment-accordion" aria-expanded="false" aria-controls="flush-collapseTwo">
							<h5 class="m-0">&#9925; Environment</h5>
						</button>
					</h2>
					<div id="environment-accordion" class="accordion-collapse collapse">
						<div class="accordion-body p-3">

							<!-- LIGHTS -->
							<h6>&#128161; Lights</h6>
							<div class="input-group input-group-sm mb-3">
								<!--<label for="lightSet" class="input-group-text">&#128161; Lights</label>-->
								<select id="lightSet" class="form-select" onchange="setLighting(this.value);">
									<option value="0" selected>One Directional</option>
									<option value="1">Three Directional</option>
									<option value="2">Eight Point</option>
									<option value="3">No Lights (Sky Only)</option>
								</select>
							</div>

							<h6>&#128269; Environment Mip Preview</h6>

							<div class="row input-group input-group-sm ms-0 mb-3">
								<label for="mipLevelRange" class="col-4 input-group-text">Mip: 0</label>
								<input id="mipLevelRange" type="range" class="col form-control form-range p-3" min="0" max="16" value="0" oninput="setSkyMipPreview(this.value); this.previousElementSibling.innerHTML = 'Mip: ' + this.value;" />
							</div>

							<h6>&#128256; Change Environment Map</h6>

							<div class="accordion m-1" id="loadAccordion">

								<!-- CHOOSE EXISTING -->
								<div class="accordion-item">
									<h2 class="accordion-header">
										<button class="accordion-button p-2 collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#choose-map" aria-expanded="false" aria-controls="collapseTwo">
											&#128194; Choose Environment
										</button>
									</h2>
									<div id="choose-map" class="accordion-collapse collapse" data-bs-parent="#loadAccordion">
										<div class="accordion-body p-2">
											Not yet implemented
										</div>
									</div>
								</div>

								<!-- SIX FACES -->
								<div class="accordion-item">
									<h2 class="accordion-header">
										<button class="accordion-button p-2 collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne">
											&#127922; Load 6 Faces
										</button>
									</h2>
									<div id="collapseOne" class="accordion-collapse collapse" data-bs-parent="#loadAccordion">
										<div class="accordion-body p-2">

											<div class="input-group text-center">
												<label for="sixFacesXPos" class="input-group-text" style="min-width:50px;">+X</label>
												<input class="form-control" type="file" id="sixFacesXPos" />
											</div>

											<div class="input-group">
												<label for="sixFacesXNeg" class="input-group-text" style="min-width: 50px;">- X</label>
												<input class="form-control" type="file" id="sixFacesXNeg" />
											</div>

											<div class="input-group">
												<label for="sixFacesYPos" class="input-group-text" style="min-width:50px;">+Y</label>
												<input class="form-control" type="file" id="sixFacesYPos" />
											</div>

											<div class="input-group">
												<label for="sixFacesYNeg" class="input-group-text" style="min-width:50px;">- Y</label>
												<input class="form-control" type="file" id="sixFacesYNeg" />
											</div>

											<div class="input-group">
												<label for="sixFacesZPos" class="input-group-text" style="min-width:50px;">+Z</label>
												<input class="form-control" type="file" id="sixFacesZPos" />
											</div>

											<div class="input-group">
												<label for="sixFacesZNeg" class="input-group-text" style="min-width:50px;">- Z</label>
												<input class="form-control" type="file" id="sixFacesZNeg" />
											</div>

											<button type="button" class="btn btn-primary mt-2" onclick="loadSixFaces()">Load</button>

										</div>
									</div>
								</div>

								<!-- DDS CUBE MAP -->
								<div class="accordion-item">
									<h2 class="accordion-header">
										<button class="accordion-button p-2 collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
											&#128230; Load DDS Cube Map
										</button>
									</h2>
									<div id="collapseTwo" class="accordion-collapse collapse" data-bs-parent="#loadAccordion">
										<div class="accordion-body p-2">

											<div class="input-group">
												<input class="form-control" type="file" id="ddsFile" aria-describedby="button-load-dds" aria-label="Load" />

												<button id="button-load-dds" type="button" class="btn btn-primary" onclick="loadDDS()">Load</button>
											</div>

										</div>
									</div>
								</div>

								<!-- HDR FILE -->
								<div class="accordion-item">
									<h2 class="accordion-header">
										<button class="accordion-button p-2 collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
											&#127748; Load HDR File
										</button>
									</h2>
									<div id="collapseThree" class="accordion-collapse collapse" data-bs-parent="#loadAccordion">
										<div class="accordion-body p-2">

											<div class="input-group">
												<input class="form-control" type="file" id="hdrFile" aria-describedby="button-load-hdr" aria-label="Load" />

												<button id="button-load-hdr" type="button" class="btn btn-primary" onclick="loadHDR()">Load</button>
											</div>



											<div class="mt-2">
												<label for="hdrExposure" class="form-label">Exposure Adjust: 0</label>
												<input type="range" class="form-range" min="-10" max="10" step="0.001" value="0" id="hdrExposure" oninput="setHDRExposure(this.value); this.previousElementSibling.innerHTML = 'Exposure Adjust: ' + this.value;" />
											</div>

										</div>
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>

				<!-- SAVE -->
				<div class="accordion-item">
					<h2 class="accordion-header">
						<button class="accordion-button p-2 collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#save-accordion" aria-expanded="false" aria-controls="flush-collapseTwo">
							<h5 class="m-0">&#128190; Save IBL Maps</h5>
						</button>
					</h2>
					<div id="save-accordion" class="accordion-collapse collapse">
						<div class="accordion-body p-3">
							<p>Save any of the generated Image-Based Lighting maps</p>
							<button class="btn btn-primary mb-1 w-100" id="buttonSaveSky" onclick="window.saveSkyToFile();" disabled>Save Skybox as DDS Cube Map</button><br />
							<button class="btn btn-primary mb-1 w-100" id="buttonSaveIrr" onclick="window.saveIrrToFile();" disabled>Save Irradiance as DDS Cube Map</button><br />
							<button class="btn btn-primary mb-1 w-100" id="buttonSaveIBL" onclick="window.saveIBLToFile();" disabled>Save IBL Specular as DDS Cube Map</button><br />
							<button class="btn btn-primary mb-1 w-100" id="buttonSaveLUT" onclick="window.saveLUTToFile();" disabled>Save BRDF Look Up Table as DDS Texture</button>
						</div>
					</div>
				</div>

				<!-- POST PROCESSING -->
				<div class="accordion-item">
					<h2 class="accordion-header">
						<button class="accordion-button p-2 collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#post-accordion" aria-expanded="false" aria-controls="flush-collapseTwo">
							<h5 class="m-0">&#127909; Post-Processing</h5>
						</button>
					</h2>
					<div id="post-accordion" class="accordion-collapse collapse">
						<div class="accordion-body p-3">
							<p>Fine-tune the rendered image in the viewport. This does not affect the IBL maps.</p>

							<h6>&#127912; Tonemapping (HDR Only)</h6>

							<label for="exposureRange" class="form-label">Exposure: 0</label>
							<input type="range" class="form-range" min="-10" max="10" step="0.001" value="0" id="exposureRange" oninput="setExposure(this.value); this.previousElementSibling.innerHTML = 'Exposure: ' + this.value;" />

							<label for="tonemapType" class="form-label">Type</label>
							<select id="tonemapType" class="form-select" onchange="setTonemapType(this.value);">
								<option value="0" selected>None (Linear)</option>
								<option value="1">Reinhard</option>
								<option value="2">Reinhard (White Point)</option>
								<option value="3">Exposure</option>
								<option value="4">Uncharted 2</option>
								<option value="5">Aces</option>
							</select>
						</div>
					</div>
				</div>

				<!-- SETTINGS -->
				<div class="accordion-item">
					<h2 class="accordion-header">
						<button class="accordion-button p-2 collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#settings-accordion" aria-expanded="false" aria-controls="flush-collapseTwo">
							<h5 class="m-0">&#128295; Settings</h5>
						</button>
					</h2>
					<div id="settings-accordion" class="accordion-collapse collapse">
						<div class="accordion-body p-3">

							<h6>&#127767; Color Mode</h6>
							<div class="btn-group">
								<input type="radio" class="btn-check" name="color-mode" id="color-mode-light" autocomplete="off" onchange="setColorMode('light');"/>
								<label class="btn btn-outline-secondary btn-sm" for="color-mode-light">Light</label>

								<input type="radio" class="btn-check" name="color-mode" id="color-mode-dark" autocomplete="off" checked onchange="setColorMode('dark');" />
								<label class="btn btn-outline-secondary btn-sm" for="color-mode-dark">Dark</label>
							</div>
						</div>
					</div>
				</div>

			</div>



		</div>

		<!-- Content (3D viewport) -->
		<div class="col m-0 p-0 canvas-container">
			<canvas id="viewport" tabindex="1" class="canvas-fill-parent"></canvas>

			<div id="loading-container" class="card m-3 opacity-75 invisible over-canvas">
				<div class="card-body">
					<div class="spinner-border spinner-border-sm me-2"></div>
					<span id="loading-text">Loading!</span>
				</div>
			</div>
		</div>

	</div>


	<!-- END bootstrap -->
	<script type="module">

		import { Vector2, Vector3, Matrix4x4 } from "../build/d3dmath.js";
		import { TextureUtils } from "../build/textureUtils.js";
		import { MappedArray } from "../build/mappedArray.js";
		import { Transform } from "../build/transform.js";
		import { FPSCamera, OrbitCamera } from "../build/camera.js";
		import { Material } from "../build/material.js";
		import { Entity } from "../build/entity.js";
		import { Vertex } from "../build/vertex.js";
		import { Light } from "../build/light.js";
		import { Scene } from "../build/scene.js";
		import { Mesh } from "../build/mesh.js";
		import { Sky } from "../build/sky.js";
		import { Input, Keys, MouseButtons } from "../build/input.js";

		// Global vars we can use in window functions
		let globalSky = null;
		let globalHDRExposure = 0;
		let globalSkyMipLevelPreview = 0;
		let globalTonemapType = 0;
		let globalTonemapExposure = 0;
		let globalDevice = null;
		let globalContext = null;

		let globalScenes = [];
		let globalCurrentScene = 0;
		let globalLightings = [];
		let globalCurrentLighting = 0;
		let globalMaterials = [];
		let globalCurrentMaterial = 1;
		let globalMatRoughness = 0.5;
		let globalMatMetalness = 0;

		const Lighting_OneDir = 0;
		const Lighting_ThreeDir = 1;
		const Lighting_EightPoints = 2;
		const Lighting_None = 3;

		const MaxLights = 64;

		window.setMatRoughness = function (val)
		{
			globalMatRoughness = val;
		}

		window.setMatMetalness = function (val)
		{
			globalMatMetalness = val;
		}

		window.setTextureSet = function (val)
		{
			globalCurrentMaterial = val;
		}

		window.setColorMode = function (mode)
		{
			document.documentElement.setAttribute("data-bs-theme", mode);
		}

		window.setScene = function (val)
		{
			globalCurrentScene = val;
		}

		window.setLighting = function (val)
		{
			globalCurrentLighting = val;
		}

		window.setTonemapType = function (val)
		{
			globalTonemapType = val;
		}

		window.setExposure = function (val)
		{
			globalTonemapExposure = val;
		}

		window.setSkyMipPreview = function (val)
		{
			globalSkyMipLevelPreview = val;
		}

		window.setHDRExposure = function (val)
		{
			// Adjust exposure and re-create all PBR assets
			globalHDRExposure = val;
			globalSky.SetHDRExposure(val);
		}

		window.loadSixFaces = async function ()
		{
			// Collect all input elements
			let inputs = [
				document.getElementById("sixFacesXPos"),
				document.getElementById("sixFacesXNeg"),
				document.getElementById("sixFacesYPos"),
				document.getElementById("sixFacesYNeg"),
				document.getElementById("sixFacesZPos"),
				document.getElementById("sixFacesZNeg")
			];

			// Validate files
			for (let i = 0; i < 6; i++)
			{
				// Ensure file has been set
				if (inputs[i].files.length == 0)
				{
					alert("Missing one or more files for skybox load");
					return;
				}

				// Check extension
				let filename = inputs[i].files[0].name;
				let extension = filename.slice(filename.lastIndexOf('.'));
				if (extension != ".jpg" && extension != ".jpeg" && extension != ".png")
				{
					alert("One or more files for skybox load have invalid extensions");
					return;
				}
			}

			// Files validated - Perform the load(s)
			let fileURLs = [];
			for (let i = 0; i < 6; i++)
			{
				let cubeDataArray = await readLocalFile(inputs[i].files[0]);
				fileURLs[i] = new Blob([cubeDataArray]);
			}

			// All loaded - Attempt to load as a cube map (assuming NOT hdr)
			globalSky.LoadCubeMap(await loadTextureCube(globalDevice, globalContext, fileURLs, true, true), false);
		}


		window.readLocalFile = async function (file)
		{
			return new Promise((resolve, reject) =>
			{
				let fr = new FileReader();
				fr.onerror = reject;
				fr.onload = function ()
				{
					resolve(fr.result);
				}
				fr.readAsArrayBuffer(file);
			});
		}

		window.getLineFromArrayBuffer = function (arrayBuffer, startPos)
		{
			// Create a character view into the array buffer
			let charArray = new Uint8Array(arrayBuffer, startPos);

			// Track where we are
			let offset = 0;
			let line = "";
			let char = "";
			do
			{
				// Append character from array buffer
				char = String.fromCharCode(charArray[offset]);
				line += char;

				// Move forward
				offset++;
			}
			while (offset < charArray.length && char != "\n");

			return line;
		}


		window.loadHDR = async function ()
		{
			let fileInput = document.getElementById("hdrFile");
			let [width, height, data] = await TextureUtils.LoadHDRFileLocal(fileInput);

			globalSky.LoadEquirectHDR(width, height, data, globalHDRExposure);
		}

		window.loadDDS = async function ()
		{
			let fileInput = document.getElementById("ddsFile");
			let [width, height, mips, format, faceDataArrays] = await TextureUtils.LoadDDSFileLocal(fileInput);

			globalSky.LoadDDS(width, height, mips, format, faceDataArrays);
		}


		window.loadTextureCube = async function (device, context, faceURLs, filesAreLocal, generateMips)
		{
			let faceTextures = [];
			let size = -1;
			let mips = 1;
			for (let i = 0; i < faceURLs.length; i++)
			{
				// Fetch and grab the binary data, then turn into an image
				const resp = filesAreLocal ? faceURLs[i] : await fetch(faceURLs[i]);
				const imageBlob = filesAreLocal ? resp : await resp.blob();
				const bitmap = await createImageBitmap(imageBlob, { imageOrientation: "flipY" });

				// Set size and mips on first bitmap
				if (size == -1)
				{
					size = bitmap.width;

					if (generateMips)
					{
						mips = Math.floor(Math.log2(size)) + 1;
					}
				}

				// Validate bitmap aspect ratio
				if (bitmap.width != bitmap.height)
				{
					console.log("Error: Texture cube faces must be square");
					return;
				}

				// Validate size matches
				if (size != bitmap.width)
				{
					console.log("Error: Texture cube faces must all be the same size");
				}

				// Add to array of initial data
				faceTextures.push(bitmap);

				// Note: Must also add nulls for other mips of this face
				for (let i = 1; generateMips && i < mips; i++)
					faceTextures.push(null); // No data for this mip yet!
			}

			// Set up the texture cube
			let desc = new D3D11_TEXTURE2D_DESC(
				faceTextures[0].width,
				faceTextures[0].height,
				mips,
				6, // 6 faces (as array elements)
				DXGI_FORMAT_R8G8B8A8_UNORM,
				new DXGI_SAMPLE_DESC(1, 0),
				D3D11_USAGE_DEFAULT,
				D3D11_BIND_SHADER_RESOURCE | (generateMips ? D3D11_BIND_RENDER_TARGET : 0),
				0,
				D3D11_RESOURCE_MISC_TEXTURECUBE | (generateMips ? D3D11_RESOURCE_MISC_GENERATE_MIPS : 0));
			let texture = device.CreateTexture2D(desc, faceTextures);

			let srv = device.CreateShaderResourceView(texture, null);

			// Generate mip maps for the enviroment map for later IBL steps
			if (generateMips)
			{
				context.GenerateMips(srv);
			}

			// Release the texture
			texture.Release();
			return srv;
		}

		window.saveSkyToFile = function ()
		{
			let [w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels] = TextureUtils.ReadPixelDataFromSRV(globalDevice, globalContext, globalSky.SkyCubeSRV);
			TextureUtils.WriteDDSFile("sky_cube.dds", w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels);
		}

		window.saveIrrToFile = function ()
		{
			let [w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels] = TextureUtils.ReadPixelDataFromSRV(globalDevice, globalContext, globalSky.IrradianceCubeSRV);
			TextureUtils.WriteDDSFile("ibl_irradiance_cube.dds", w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels);
		}

		window.saveIBLToFile = function ()
		{
			let [w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels] = TextureUtils.ReadPixelDataFromSRV(globalDevice, globalContext, globalSky.SpecularIBLCubeSRV);
			TextureUtils.WriteDDSFile("ibl_specular_cube.dds", w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels);
		}

		window.saveLUTToFile = function ()
		{
			let [w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels] = TextureUtils.ReadPixelDataFromSRV(globalDevice, globalContext, globalSky.BRDFLookUpTableSRV);
			TextureUtils.WriteDDSFile("brdf_look_up_table.dds", w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels);
		}

		async function main()
		{
			// Grab canvas html element
			let viewportElement = document.getElementById("viewport");

			// Input manager setup
			let input = new Input(viewportElement);

			// Init the API
			const swapChainDesc = new DXGI_SWAP_CHAIN_DESC(
				viewportElement.clientWidth,
				viewportElement.clientHeight,
				DXGI_FORMAT_R8G8B8A8_UNORM);

			let [device, context, swapChain] =
				D3D11CreateDeviceAndSwapChain(viewportElement, 0, swapChainDesc);
			globalDevice = device;
			globalContext = context;

			// Set up initial viewport
			let viewport = new D3D11_VIEWPORT(0, 0, viewportElement.clientWidth, viewportElement.clientHeight, 0, 1);
			context.RSSetViewports([viewport]);

			// Make an RTV of the back buffer
			let backBuffer = swapChain.GetBuffer();
			let rtv = device.CreateRenderTargetView(backBuffer, null);
			backBuffer.Release();

			// Create a depth buffer
			let depthDesc = new D3D11_TEXTURE2D_DESC(
				viewportElement.clientWidth,
				viewportElement.clientHeight,
				1,
				1,
				DXGI_FORMAT_D24_UNORM_S8_UINT,
				new DXGI_SAMPLE_DESC(1, 0),
				D3D11_USAGE_DEFAULT,
				D3D11_BIND_DEPTH_STENCIL,
				0,
				0);
			let depthBuffer = device.CreateTexture2D(depthDesc, null);

			// Default DSV
			let depthDSV = device.CreateDepthStencilView(depthBuffer, null);
			depthBuffer.Release();

			// Set the default render targets
			context.OMSetRenderTargets([rtv], depthDSV);

			// Ensure we're set for triangles
			context.IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

			// Create an input layout
			let inputElements = [];
			inputElements[0] = new D3D11_INPUT_ELEMENT_DESC("POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0);
			inputElements[1] = new D3D11_INPUT_ELEMENT_DESC("TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 3 * Float32Array.BYTES_PER_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0);
			inputElements[2] = new D3D11_INPUT_ELEMENT_DESC("NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 5 * Float32Array.BYTES_PER_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0);
			inputElements[3] = new D3D11_INPUT_ELEMENT_DESC("TANGENT", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 8 * Float32Array.BYTES_PER_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0);
			let inputLayout = device.CreateInputLayout(inputElements);
			context.IASetInputLayout(inputLayout);

			// Create a sampler
			let sampDesc = new D3D11_SAMPLER_DESC(
				D3D11_FILTER_ANISOTROPIC,
				D3D11_TEXTURE_ADDRESS_WRAP,
				D3D11_TEXTURE_ADDRESS_WRAP,
				D3D11_TEXTURE_ADDRESS_WRAP,
				0,
				16,
				0,
				0,
				0,
				D3D11_FLOAT32_MAX);
			let sampler = device.CreateSamplerState(sampDesc);

			// Make a clamp sampler, too
			sampDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
			sampDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
			sampDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
			let clampSampler = device.CreateSamplerState(sampDesc);



			// Create several solid textures
			let blackSRV = TextureUtils.CreateSolidTexture2D(device, 2, 2, 0, 0, 0, 255);
			let whiteSRV = TextureUtils.CreateSolidTexture2D(device, 2, 2, 255, 255, 255, 255);
			let blueSRV = TextureUtils.CreateSolidTexture2D(device, 2, 2, 0, 0, 192, 255);
			let greenSRV = TextureUtils.CreateSolidTexture2D(device, 2, 2, 0, 128, 0, 255);
			let redSRV = TextureUtils.CreateSolidTexture2D(device, 2, 2, 255, 0, 0, 255);
			let flatNormalsSRV = TextureUtils.CreateSolidTexture2D(device, 2, 2, 127, 127, 255, 255);

			// Array of greyscale roughness textures
			let solidRoughSRVs = [];
			for (let i = 0; i < 11; i++)
			{
				let r = Math.floor((i / 10.0) * 255);
				solidRoughSRVs.push(TextureUtils.CreateSolidTexture2D(device, 2, 2, r, r, r, 255));
			}

			// Mesh loading
			let sphereMesh = await Mesh.LoadFromFile(device, "../assets/meshes/sphere.obj");
			let helixMesh = await Mesh.LoadFromFile(device, "../assets/meshes/helix.obj");
			let cubeMesh = await Mesh.LoadFromFile(device, "../assets/meshes/cube.obj");

			// Camera
			let camera = new FPSCamera(0, 0, -10, viewportElement.clientWidth / viewportElement.clientHeight);
			//let camera = new OrbitCamera(10, viewportElement.clientWidth / viewportElement.clientHeight);


			// Create shaders
			let ps = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/PBR_PS.hlsl"));
			let vs = device.CreateVertexShader(await HLSL.LoadTextFromURL("../assets/shaders/PBR_VS.hlsl"));
			let solidPS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/SolidColorPS.hlsl"));
			let mipReducePS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/MipReducePS.hlsl"));
			let skyVS = device.CreateVertexShader(await HLSL.LoadTextFromURL("../assets/shaders/SkyVS.hlsl"));
			let skyPS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/SkyPS.hlsl"));
			let tonemapPS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/TonemapPS.hlsl"));
			let postprocPS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/BlurPS.hlsl"));
			let quadVS = device.CreateVertexShader(await HLSL.LoadTextFromURL("../assets/shaders/QuadVS.hlsl"));
			let fullscreenVS = device.CreateVertexShader(await HLSL.LoadTextFromURL("../assets/shaders/FullscreenVS.hlsl"));
			let simpleTexturePS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/SimpleTexturePS.hlsl"));

			let equirectToCubePS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/EquirectToCubePS.hlsl"));

			// Shaders for IBL
			let brdfLutPS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/IBLBrdfLookUpTablePS.hlsl"));
			let iblIrradiancePS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/IBLIrradianceMapPS.hlsl"));
			let iblSpecularPS = device.CreatePixelShader(await HLSL.LoadTextFromURL("../assets/shaders/IBLSpecularConvolutionPS.hlsl"));


			// Load a cube map
			let skySRV = await loadTextureCube(
				device,
				context,
				[
					"../assets/skies/cloudsblue/right.png",
					"../assets/skies/cloudsblue/left.png",
					"../assets/skies/cloudsblue/up.png",
					"../assets/skies/cloudsblue/down.png",
					"../assets/skies/cloudsblue/front.png",
					"../assets/skies/cloudsblue/back.png"
				],
				false,
				true
			);

			// Create the sky object
			globalSky = new Sky(device, context,
				skyVS, skyPS, cubeMesh,
				DXGI_FORMAT_R16G16_FLOAT, 1024, brdfLutPS,
				DXGI_FORMAT_R32G32B32A32_FLOAT, 64, iblIrradiancePS,
				DXGI_FORMAT_R32G32B32A32_FLOAT, 512, 3, iblSpecularPS,
				equirectToCubePS, mipReducePS, fullscreenVS,
				true, 128);
			globalSky.LoadCubeMap(skySRV, false);


			// ----------------- Materials --------------------

			let matCobble = new Material(vs, ps, new Vector3(1, 1, 1));
			matCobble.SetPSTextureSRV(0, await TextureUtils.LoadTexture2D(device, context, "../assets/textures/cobblestone_albedo.png"));
			matCobble.SetPSTextureSRV(1, await TextureUtils.LoadTexture2D(device, context, "../assets/textures/cobblestone_normals.png"));
			matCobble.SetPSTextureSRV(2, await TextureUtils.LoadTexture2D(device, context, "../assets/textures/cobblestone_metal.png"));
			matCobble.SetPSTextureSRV(3, await TextureUtils.LoadTexture2D(device, context, "../assets/textures/cobblestone_roughness.png"));
			matCobble.SetPSSamplerState(0, sampler);
			matCobble.SetPSSamplerState(1, clampSampler);

			let matBronze = new Material(vs, ps, new Vector3(1, 1, 1));
			matBronze.SetPSTextureSRV(0, await TextureUtils.LoadTexture2D(device, context, "../assets/textures/bronze_albedo.png"));
			matBronze.SetPSTextureSRV(1, await TextureUtils.LoadTexture2D(device, context, "../assets/textures/bronze_normals.png"));
			matBronze.SetPSTextureSRV(2, await TextureUtils.LoadTexture2D(device, context, "../assets/textures/bronze_metal.png"));
			matBronze.SetPSTextureSRV(3, await TextureUtils.LoadTexture2D(device, context, "../assets/textures/bronze_roughness.png"));
			matBronze.SetPSSamplerState(0, sampler);
			matBronze.SetPSSamplerState(1, clampSampler);

			let matFloor = new Material(vs, ps, new Vector3(1, 1, 1));
			matFloor.SetPSTextureSRV(0, await TextureUtils.LoadTexture2D(device, context, "../assets/textures/floor_albedo.png"));
			matFloor.SetPSTextureSRV(1, await TextureUtils.LoadTexture2D(device, context, "../assets/textures/floor_normals.png"));
			matFloor.SetPSTextureSRV(2, await TextureUtils.LoadTexture2D(device, context, "../assets/textures/floor_metal.png"));
			matFloor.SetPSTextureSRV(3, await TextureUtils.LoadTexture2D(device, context, "../assets/textures/floor_roughness.png"));
			matFloor.SetPSSamplerState(0, sampler);
			matFloor.SetPSSamplerState(1, clampSampler);

			let matScratched = new Material(vs, ps, new Vector3(1, 1, 1));
			matScratched.SetPSTextureSRV(0, await TextureUtils.LoadTexture2D(device, context, "../assets/textures/scratched_albedo.png"));
			matScratched.SetPSTextureSRV(1, await TextureUtils.LoadTexture2D(device, context, "../assets/textures/scratched_normals.png"));
			matScratched.SetPSTextureSRV(2, await TextureUtils.LoadTexture2D(device, context, "../assets/textures/scratched_metal.png"));
			matScratched.SetPSTextureSRV(3, await TextureUtils.LoadTexture2D(device, context, "../assets/textures/scratched_roughness.png"));
			matScratched.SetPSSamplerState(0, sampler);
			matScratched.SetPSSamplerState(1, clampSampler);

			let matCustom = new Material(vs, ps, new Vector3(1, 1, 1));
			matCustom.SetPSTextureSRV(0, whiteSRV);
			matCustom.SetPSTextureSRV(1, flatNormalsSRV);
			matCustom.SetPSTextureSRV(2, whiteSRV);
			matCustom.SetPSTextureSRV(3, whiteSRV);
			matCustom.SetPSSamplerState(0, sampler);
			matCustom.SetPSSamplerState(1, clampSampler);

			// Order must match UI!
			globalMaterials.push(matCustom);
			globalMaterials.push(matCobble);
			globalMaterials.push(matBronze);
			globalMaterials.push(matFloor);
			globalMaterials.push(matScratched);

			// -------------- Entity setup -------------------
			// --- SPHERE SCENE ---
			let sphereEntity = new Entity(
				sphereMesh,
				matCustom);
			sphereEntity.Transform.ScaleUniform(7);

			globalScenes.push([sphereEntity]);

			// --- HELIX SCENE ---
			let helixEntity = new Entity(
				helixMesh,
				matCustom);
			helixEntity.Transform.ScaleUniform(3);

			globalScenes.push([helixEntity]);

			// --- CUBE SCENE ---
			let cubeEntity = new Entity(
				cubeMesh,
				matCustom);
			cubeEntity.Transform.ScaleUniform(4);

			globalScenes.push([cubeEntity]);

			// --- ROUGHNESS SPHERES ---
			let roughRowTextures = [
				// Albedo,	normals,        metals
				[whiteSRV, flatNormalsSRV, whiteSRV], // Metal
				[whiteSRV, flatNormalsSRV, blackSRV], // White plastic
				[blackSRV, flatNormalsSRV, blackSRV]  // Black plastic
			];

			let spacing = 1.1;
			let startY = roughRowTextures.length / 2;
			let roughScene = [];
			for (let row = 0; row < roughRowTextures.length; row++)
			{
				for (let col = 0; col < 11; col++)
				{
					let m = new Material(vs, ps, new Vector3(1, 1, 1));
					m.SetPSTextureSRV(0, roughRowTextures[row][0]);
					m.SetPSTextureSRV(1, roughRowTextures[row][1]);
					m.SetPSTextureSRV(2, roughRowTextures[row][2]);
					m.SetPSTextureSRV(3, solidRoughSRVs[col]);
					m.SetPSSamplerState(0, sampler);
					m.SetPSSamplerState(1, clampSampler);

					let e = new Entity(sphereMesh, m);
					e.Transform.SetPosition((col - 5) * spacing, startY - row * spacing, 0);
					e.Transform.SetScaleUniform(1);

					roughScene.push(e);
				}
			}
			globalScenes.push(roughScene);


			// --- RGB SPHERES ---
			let rgbRowTextures = [
				// Albedo,	normals,        metals
				[whiteSRV, flatNormalsSRV, blackSRV], // White plastic
				[redSRV, flatNormalsSRV, blackSRV],   // Red plastic
				[greenSRV, flatNormalsSRV, blackSRV], // Green plastic
				[blueSRV, flatNormalsSRV, blackSRV],  // Blue plastic
				[blackSRV, flatNormalsSRV, blackSRV]  // Black plastic
			];

			startY = rgbRowTextures.length / 2;
			let rgbScene = [];
			for (let row = 0; row < rgbRowTextures.length; row++)
			{
				for (let col = 0; col < 11; col++)
				{
					let m = new Material(vs, ps, new Vector3(1, 1, 1));
					m.SetPSTextureSRV(0, rgbRowTextures[row][0]);
					m.SetPSTextureSRV(1, rgbRowTextures[row][1]);
					m.SetPSTextureSRV(2, rgbRowTextures[row][2]);
					m.SetPSTextureSRV(3, solidRoughSRVs[col]);
					m.SetPSSamplerState(0, sampler);
					m.SetPSSamplerState(1, clampSampler);

					let e = new Entity(sphereMesh, m);
					e.Transform.SetPosition((col - 5) * spacing, startY - row * spacing, 0);
					e.Transform.SetScaleUniform(1);

					rgbScene.push(e);
				}
			}
			globalScenes.push(rgbScene);


			// ----------- Lighting setups ---------------

			// --- No lights ---
			globalLightings[Lighting_None] = [];

			// --- One Dir Light ---
			globalLightings[Lighting_OneDir] = [
				new Light(Light.TypeDirectional, Vector3.One, 1.0, Vector3.Normalize(new Vector3(1, -1, 1)))
			];

			// --- Three Dir Lights ---
			globalLightings[Lighting_ThreeDir] = [
				new Light(Light.TypeDirectional, Vector3.One, 1.0, Vector3.Normalize(new Vector3(1, -1, 1))),
				new Light(Light.TypeDirectional, Vector3.One, 1.0, Vector3.Normalize(new Vector3(-1, -0.1, -0.1))),
				new Light(Light.TypeDirectional, Vector3.One, 0.3, Vector3.Normalize(new Vector3(0, 1, -0.5)))
			];

			// --- Eight Point Lights ---
			globalLightings[Lighting_EightPoints] = [];
			for (let i = 0; i < 8; i++)
			{
				let color = Vector3.One;
				if (i % 4 == 1) color = Vector3.UnitX;
				else if (i % 4 == 2) color = Vector3.UnitY;
				else if (i % 4 == 3) color = Vector3.UnitZ;

				let offset = (i / 4) * Math.PI * 2;
				let s = Math.sin(offset);
				let c = Math.cos(offset);

				let pos = new Vector3(3 * s, i < 4 ? -3 : 3, 3 * c);

				globalLightings[Lighting_EightPoints].push(new Light(
					Light.TypePoint,
					color,
					1.0,
					Vector3.Zero,
					pos,
					10
				));
			}

			// Texture saving test
			let ddsTest = false;
			if (ddsTest)
			{
				let [w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels] = TextureUtils.ReadPixelDataFromSRV(device, context, irrSRV);
				TextureUtils.WriteDDSFile("spec.dds", w, h, mips, arrSizeOrCubeCount, isCube, dxgiFormat, pixels);
			}


			// Create constant buffers -----------------
			let cbDesc = new D3D11_BUFFER_DESC(
				0, // Will be filled in below
				D3D11_USAGE_DYNAMIC,
				D3D11_BIND_CONSTANT_BUFFER,
				D3D11_CPU_ACCESS_WRITE,
				0, 0);

			// VS Per Frame = 2 matrices (view & proj)
			cbDesc.ByteWidth = 16 * 2 * Float32Array.BYTES_PER_ELEMENT;
			let vsPerFrameCB = device.CreateBuffer(cbDesc, null);
			let vsPerFrameData = new MappedArray(16 * 2);
			vsPerFrameData.PushMapping("view", 16);
			vsPerFrameData.PushMapping("proj", 16);

			// VS Per Object = 1 matrix (world)
			cbDesc.ByteWidth = 16 * Float32Array.BYTES_PER_ELEMENT;
			let vsPerObjectCB = device.CreateBuffer(cbDesc, null);
			let vsPerObjectData = new MappedArray(16);
			vsPerObjectData.PushMapping("world", 16);

			// PS Per Frame = 8 floats + 64 lights
			cbDesc.ByteWidth =
				8 * Float32Array.BYTES_PER_ELEMENT +
				MaxLights * Light.SizeInBytes;
			let psPerFrameCB = device.CreateBuffer(cbDesc, null);
			let psPerFrameData = new MappedArray(cbDesc.ByteWidth / Float32Array.BYTES_PER_ELEMENT);
			psPerFrameData.PushMapping("cameraPos", 3);
			psPerFrameData.PushMapping("pad", 1);
			psPerFrameData.PushMapping("iblSpecMips", 1);
			psPerFrameData.PushMapping("lightCount", 1);
			psPerFrameData.PushMapping("envIsHDR", 1);
			psPerFrameData.PushMapping("pad2", 1);
			psPerFrameData.PushMapping("lights", MaxLights * Light.SizeInFloats);

			// PS Per Object = 8 floats (RGB color tint + roughness + metalness + float3 padding)
			cbDesc.ByteWidth = 8 * Float32Array.BYTES_PER_ELEMENT;
			let psPerObjectCB = device.CreateBuffer(cbDesc, null);
			let psPerObjectData = new MappedArray(8);
			psPerObjectData.PushMapping("tint", 3);
			psPerObjectData.PushMapping("pad", 1);
			psPerObjectData.PushMapping("roughness", 1);
			psPerObjectData.PushMapping("metalness", 1);

			// Set initial values
			psPerObjectData.SetData("roughness", 1);
			psPerObjectData.SetData("metalness", 1);


			// Cbuffer for solid color
			let solidCBDesc = new D3D11_BUFFER_DESC(
				4 * Float32Array.BYTES_PER_ELEMENT,
				D3D11_USAGE_DYNAMIC,
				D3D11_BIND_CONSTANT_BUFFER,
				D3D11_CPU_ACCESS_WRITE,
				0, 0);
			let solidCB = device.CreateBuffer(solidCBDesc, null);
			let solidData = new Float32Array(4);
			solidData.set([1, 1, 1], 0);
			context.UpdateSubresource(solidCB, 0, null, solidData, 0, 0);


			// Cbuffer for quad UI
			let quadCBDesc = new D3D11_BUFFER_DESC(
				8 * Float32Array.BYTES_PER_ELEMENT,
				D3D11_USAGE_DYNAMIC,
				D3D11_BIND_CONSTANT_BUFFER,
				D3D11_CPU_ACCESS_WRITE,
				0, 0);
			let quadCB = device.CreateBuffer(quadCBDesc, null);
			let quadData = new Float32Array(8);

			// Post process resources
			let ppTexDesc = new D3D11_TEXTURE2D_DESC(
				viewportElement.width,
				viewportElement.height,
				1,
				1,
				DXGI_FORMAT_R32G32B32A32_FLOAT,
				new DXGI_SAMPLE_DESC(1, 0),
				D3D11_USAGE_DEFAULT,
				D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE,
				0,
				0);
			let ppTexture = device.CreateTexture2D(ppTexDesc, [null]);
			let ppSRV = device.CreateShaderResourceView(ppTexture, null);
			let ppRTV = device.CreateRenderTargetView(ppTexture, null);
			ppTexture.Release();

			// Post process constant buffer
			let ppCBDesc = new D3D11_BUFFER_DESC(
				Float32Array.BYTES_PER_ELEMENT * 4,
				D3D11_USAGE_DYNAMIC,
				D3D11_BIND_CONSTANT_BUFFER,
				D3D11_CPU_ACCESS_WRITE,
				0, 0);
			let ppCB = device.CreateBuffer(ppCBDesc, null);
			let ppData = new Float32Array(4);

			function showSkyLoading(text)
			{
				let load = document.getElementById("loading-container");
				load.classList.remove("invisible");

				let loadText = document.getElementById("loading-text");
				loadText.innerHTML = text;
			}

			function hideSkyLoading()
			{
				let load = document.getElementById("loading-container");
				load.classList.add("invisible");
			}

			function update(deltaTime, totalTime)
			{
				camera.Update(input, deltaTime);

				// Check for any progressive IBL updates
				globalSky.Update();

				// Check for sky assets being ready
				let saveSky = document.getElementById("buttonSaveSky");
				let saveIBL = document.getElementById("buttonSaveIBL");
				let saveIrr = document.getElementById("buttonSaveIrr");
				let saveLUT = document.getElementById("buttonSaveLUT");

				// TODO: Tie disabling to the actual new skybox load
				if (saveSky.disabled && globalSky.SkyCubeSRV != null) saveSky.disabled = false;
				else if (!saveSky.disabled && globalSky.SkyCubeSRV == null) saveSky.disabled = true;

				if (saveIBL.disabled && globalSky.SpecularIBLReady) saveIBL.disabled = false;
				else if (!saveIBL.disabled && !globalSky.SpecularIBLReady) saveIBL.disabled = true;

				if (saveIrr.disabled && globalSky.IrradianceReady) saveIrr.disabled = false;
				else if (!saveIrr.disabled && !globalSky.IrradianceReady) saveIrr.disabled = true;

				if (saveLUT.disabled && globalSky.BRDFLookUpTableReady) saveLUT.disabled = false;
				else if (!saveLUT.disabled && !globalSky.BRDFLookUpTableReady) saveLUT.disabled = true;

				// Set up loading messages based on order of IBL map creation
				if (!globalSky.BRDFLookUpTableReady)
					showSkyLoading("Generating environment BRDF look up table");
				else if (!globalSky.IrradianceReady)
					showSkyLoading("Generating environment irradiance map");
				else if (!globalSky.SpecularIBLReady)
					showSkyLoading("Generating environment specular convolution map");
				else
					hideSkyLoading();

				// Update the point lights
				for (let i = 0; i < globalLightings[Lighting_EightPoints].length; i++)
				{
					let offset = (i / 4) * Math.PI * 2;
					let s = Math.sin(totalTime + offset);
					let c = Math.cos(totalTime + offset);

					globalLightings[Lighting_EightPoints][i].Position = new Vector3(3 * s, i < 4 ? -3 : 3, 3 * c);
				}
			}

			function checkForResize()
			{
				// Has the window changed size?
				if (viewportElement.width != viewportElement.clientWidth ||
					viewportElement.height != viewportElement.clientHeight)
				{
					// Need to resize, so first release all references
					rtv.Release(); // Back buffer
					depthDSV.Release(); // Depth buffer

					// Ask the swap chain to resize and update the canvas
					viewportElement.width = viewportElement.clientWidth;
					viewportElement.height = viewportElement.clientHeight;
					swapChain.ResizeBuffers(viewportElement.clientWidth, viewportElement.clientHeight);

					// Make new RTV
					let bb = swapChain.GetBuffer();
					rtv = device.CreateRenderTargetView(bb, null);
					bb.Release();

					// Make new depth buffer
					let depthDesc = new D3D11_TEXTURE2D_DESC(
						viewportElement.clientWidth,
						viewportElement.clientHeight,
						1,
						1,
						DXGI_FORMAT_D24_UNORM_S8_UINT,
						new DXGI_SAMPLE_DESC(1, 0),
						D3D11_USAGE_DEFAULT,
						D3D11_BIND_DEPTH_STENCIL,
						0,
						0);
					let depthBuffer = device.CreateTexture2D(depthDesc, null);

					// Default DSV
					depthDSV = device.CreateDepthStencilView(depthBuffer, null);
					depthBuffer.Release();

					// Set the new views
					context.OMSetRenderTargets([rtv], depthDSV);

					// Update aspect ratio and camera
					camera.AspectRatio = viewportElement.clientWidth / viewportElement.clientHeight;

					// Update rendering viewport, too
					viewport.Width = viewportElement.clientWidth;
					viewport.Height = viewportElement.clientHeight;
					context.RSSetViewports([viewport]);

					// Create new post processing resource, too
					ppSRV.Release();
					ppRTV.Release();
					let ppTexDesc = new D3D11_TEXTURE2D_DESC(
						viewportElement.width,
						viewportElement.height,
						1,
						1,
						DXGI_FORMAT_R32G32B32A32_FLOAT,
						new DXGI_SAMPLE_DESC(1, 0),
						D3D11_USAGE_DEFAULT,
						D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE,
						0,
						0);
					let ppTexture = device.CreateTexture2D(ppTexDesc, [null]);
					ppSRV = device.CreateShaderResourceView(ppTexture, null);
					ppRTV = device.CreateRenderTargetView(ppTexture, null);
					ppTexture.Release();
				}
			}


			function draw(deltaTime, totalTime)
			{
				checkForResize();

				// Set up tone mapping if necessary
				if (globalSky.IsHDR())
				{
					context.OMSetRenderTargets([ppRTV], depthDSV);
				}

				// Set VS constant buffers for main draw
				context.VSSetConstantBuffers(0, [vsPerFrameCB, vsPerObjectCB]);

				// Set per-frame data and update CB
				vsPerFrameData.SetData("view", camera.ViewMatrix);
				vsPerFrameData.SetData("proj", camera.ProjectionMatrix);
				context.UpdateSubresource(vsPerFrameCB, 0, null, vsPerFrameData, 0, 0);

				// Clear the frame
				let black = [0, 0, 0, 1];
				let cornflowerBlue = [0.39, 0.58, 0.93, 1];
				context.ClearRenderTargetView(rtv, black);
				context.ClearDepthStencilView(depthDSV, D3D11_CLEAR_DEPTH, 1.0, 0);

				// Light sphere draws
				if (globalCurrentLighting == Lighting_EightPoints)
				{
					// Swap to sphere buffers
					context.VSSetShader(vs);
					context.PSSetShader(solidPS);
					context.PSSetConstantBuffers(0, [solidCB]);
					context.IASetVertexBuffers(0, [sphereMesh.VertexBuffer], [Vertex.GetStrideInBytes()], [0]);
					context.IASetIndexBuffer(sphereMesh.IndexBuffer, DXGI_FORMAT_R16_UINT, 0);

					let sMat = Matrix4x4.ScaleUniform(0.5);

					for (let i = 0; i < globalLightings[Lighting_EightPoints].length; i++)
					{
						let light = globalLightings[Lighting_EightPoints][i];

						// Set per-object VS data
						vsPerObjectData.SetData(
							"world",
							Matrix4x4.Multiply(sMat, Matrix4x4.Translation(light.Position.x, light.Position.y, light.Position.z)));
						context.UpdateSubresource(vsPerObjectCB, 0, null, vsPerObjectData, 0, 0);

						// Update data for this draw
						solidData.set(light.Color, 0);
						context.UpdateSubresource(solidCB, 0, null, solidData, 0, 0);

						// Draw sphere
						context.DrawIndexed(sphereMesh.IndexCount, 0, 0);
					}
				}

				// Pipeline for next several draws
				context.VSSetShader(vs);
				context.PSSetShader(ps);
				context.PSSetConstantBuffers(0, [psPerFrameCB, psPerObjectCB]);

				// Set per-frame PS data and update CB
				psPerFrameData.SetData("cameraPos", camera.Position);
				psPerFrameData.SetData("iblSpecMips", [globalSky.SpecularIBLMipsTotal]);
				psPerFrameData.SetData("lightCount", [globalLightings[globalCurrentLighting].length]);
				psPerFrameData.SetData("envIsHDR", [globalSky.IsHDR() ? 1 : 0]);
				for (let i = 0; i < globalLightings[globalCurrentLighting].length; i++)
					psPerFrameData.SetData("lights", globalLightings[globalCurrentLighting][i], i * Light.SizeInFloats);
				context.UpdateSubresource(psPerFrameCB, 0, null, psPerFrameData, 0, 0);

				function DrawEntity(e)
				{
					// Set shaders
					context.VSSetShader(e.Material.VertexShader);
					context.PSSetShader(e.Material.PixelShader);

					// Update vertex data
					vsPerObjectData.SetData("world", e.Transform.WorldMatrix);
					context.UpdateSubresource(vsPerObjectCB, 0, null, vsPerObjectData, 0, 0);

					// Which material?
					let mat = e.Material;
					let customMat = false;
					if (globalCurrentScene == 0 || globalCurrentScene == 1 || globalCurrentScene == 2)
					{
						// Use proper material
						mat = globalMaterials[globalCurrentMaterial];
						customMat = true;
					}

					// Set up material
					mat.PrepareMaterial(context);
					psPerObjectData.SetData("tint", mat.Color);
					psPerObjectData.SetData("roughness", customMat && globalCurrentMaterial == 0 ? [globalMatRoughness] : [1]);
					psPerObjectData.SetData("metalness", customMat && globalCurrentMaterial == 0 ? [globalMatMetalness] : [1]);
					context.UpdateSubresource(psPerObjectCB, 0, null, psPerObjectData, 0, 0);

					// Set up IBL
					context.PSSetShaderResources(4, [
						globalSky.BRDFLookUpTableSRV, globalSky.IrradianceCubeSRV, globalSky.SpecularIBLCubeSRV
					]);

					// Draw
					context.IASetVertexBuffers(0, [e.Mesh.VertexBuffer], [Vertex.GetStrideInBytes()], [0]);
					context.IASetIndexBuffer(e.Mesh.IndexBuffer, DXGI_FORMAT_R16_UINT);
					context.DrawIndexed(e.Mesh.IndexCount, 0);
				}

				// Main scene draw
				{
					for (let i = 0; i < globalScenes[globalCurrentScene].length; i++)
					{
						DrawEntity(globalScenes[globalCurrentScene][i]);
					}
				}


				// Skybox
				{
					globalSky.Draw(camera.ViewMatrix, camera.ProjectionMatrix, globalSkyMipLevelPreview);
				}

				// Finalize post processing if necessary
				if (globalSky.IsHDR())
				{
					context.OMSetRenderTargets([rtv], null);
					context.VSSetShader(fullscreenVS);
					context.PSSetShader(tonemapPS);
					context.PSSetShaderResources(0, [ppSRV]);
					context.PSSetConstantBuffers(0, [ppCB]);
					ppData.set([
						globalTonemapType, // Tonemap type
						globalTonemapExposure // Exposure
					], 0);
					context.UpdateSubresource(ppCB, 0, null, ppData, 0, 0);
					context.Draw(3, 0);
				}

				// Draw "UI"
				{
					//quadData.set([
					//	100, 100, // Position in pixels
					//	800, 400, // Size in pixels
					//	viewportElement.clientWidth, viewportElement.clientHeight // Window size
					//]);
					//context.UpdateSubresource(quadCB, 0, null, quadData, 0, 0);

					//context.VSSetShader(quadVS);
					//context.VSSetConstantBuffers(0, [quadCB]);

					//context.PSSetShader(simpleTexturePS);
					//context.PSSetShaderResources(0, [globalSky.EquirectSRV]);

					//context.Draw(6, 0);
				}

				// Flush the frame
				swapChain.Present();

				context.OMSetRenderTargets([rtv], depthDSV);
			}

			let startTime = -1;
			let prevTime = 0;
			function frameloop(time)
			{
				if (startTime == -1)
					startTime = time;

				let totalTime = (time - startTime) / 1000;
				let deltaTime = (time - prevTime) / 1000;

				update(deltaTime, totalTime);
				draw(deltaTime, totalTime);

				// End of frame work
				window.requestAnimationFrame(frameloop);
				input.EndOfFrame();

				prevTime = time;
			}

			window.requestAnimationFrame(frameloop);

		}


		main();
	</script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
</body>
</html>

